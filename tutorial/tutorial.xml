<!DOCTYPE book [

<!ENTITY % tutorial-entities SYSTEM "tutorial-entities.xml">
%tutorial-entities;

]>

<book xmlns="http://docbook.org/ns/docbook" version ="5.0"
      xmlns:xi="http://docbook.sourceforge.net/release/xsl/current/xhtml5/docbook.xsl">

 <title>GTK+ 3 Tutorial for Lisp</title>

 <info>
  <legalnotice>
    <para>Copyright (C) 2012 - 2020 Dieter Kaiser</para
  ></legalnotice>
  <author>
   <personname>
    <firstname>Dieter</firstname><surname>Kaiser</surname>
   </personname>
  </author>
 </info>

 <preface>
  <title>Introduction</title>
  <para>
   The <code>cl-cffi-gtk</code> library is a Lisp binding to GTK+ (GIMP Toolkit) which is a library for
   creating graphical user interfaces. GTK+ is licensed using the LGPL which has been adopted for the
   <code>cl-cffi-gtk</code> library with a preamble that clarifies the terms for use with Lisp programs and
   is referred as the LLGPL.
  </para>
  <para>
   This work is based on the <code>cl-gtk2</code> library which has been developed by Kalyanov Dmitry and
   already is a fairly complete Lisp binding to GTK+. The focus of the <code>cl-cffi-gtk</code> library is
   to document the Lisp library much more complete and to do the implementation as consistent as possible.
   Most informations about GTK+ can be gained by reading the C documentation. Therefore, the C documentation
   from <ulink url="https://developer.gnome.org/gtk3/stable/">GTK+ 3 Reference Manual</ulink> is included
   into the Lisp files as an API documentation to document the Lisp binding to the GTK+ library. This way the
   calling conventions are easier to determine and missing functionality is easier to detect. The Lisp API
   documentation is available online at <ulink url="http://crategus.com/books/cl-cffi-gtk">
   cl-cffi-gtk API documentation</ulink>.
  </para>
  <para>
   The GTK+ library is called the GIMP toolkit because GTK+ was originally written for developing the GNU
   Image Manipulation Program (GIMP), but GTK+ has now been used in a large number of software projects,
   including the GNU Network Object Model Environment (GNOME) project. GTK+ is built on top of GDK (GIMP
   Drawing Kit) which is basically a wrapper around the low-level functions for accessing the underlying
   windowing functions (Xlib in the case of the X windows system), and GdkPixbuf, a library for client-side
   image manipulation.
  </para>
  <para>
   GTK+ is essentially an object oriented application programmers interface (API). Although written
   completely in C, GTK+ is implemented using the idea of classes and callback functions (pointers to
   functions).
  </para>
  <para>
   A third component is called GLib which contains replacements for standard calls, as well as additional
   functions for handling linked lists, etc. The replacement functions are used to increase the portability
   of GTK+, as some of the functions implemented here are not available or are non standard on other Unixes
   such as <code>g_strerror()</code>. Some also contain enhancements to the libc versions, such as
   <code>g_malloc()</code> that has enhanced debugging utilities.
  </para>
  <para>
   In version 2.0, GLib has picked up the type system which forms the foundation for the class hierarchy of
   GTK+, the signal system which is used throughout GTK+, a thread API which abstracts the different native
   thread APIs of the various platforms and a facility for loading modules.
  </para>
  <para>
   As the last components, GTK+ uses the Pango library for internationalized text output, the Cario library,
   which is a 2D graphics library with support for multiple output devices, and the GIO library, which is a
   modern easy-to-use VFS API including abstractions for files, drives, volumes, stream IO, as well as
   network programming and DBus communication.
  </para>
  <para>
   This tutorial describes the Lisp interface to GTK+. It includes a lot of material and code from different
   sources. See <link linkend="Licenses">Licences</link> for more information.
  </para>
 </preface>

 <chapter id="Getting_started">
  <title>Getting started</title>
  <section id="Installation">
   <title>Installation</title>
   <para>
    The first thing to do is to download the <code>cl-cffi-gtk</code> source and to install it. The latest
    version is available from the repository at <ulink url="http://github.com/crategus/cl-cffi-gtk">
    github.com/crategus/cl-cffi-gtk</ulink>. The <code>cl-cffi-gtk</code> library is ASDF installable and can
    be loaded with the command <code>(asdf:load-system :cl-cffi-gtk)</code> from the Lisp prompt. The library
    is developed with the Lisp SBCL 2.0 on a Linux system and GTK+ 3.24. Furthermore, the library runs
    successfully with Clozure Common Lisp and CLISP on Linux. The library compiles and the demos run with
    Windows 10.
   </para>
   <para>
    The minimum version requirements are GTK+ 3.16 and GLIB 2.32.
   </para>
   <para>
    GTK+ depends on the libraries GLib, GObject, GDK, GDK-Pixbuf, GIO, Pango, and Cairo. These libraries
    can be loaded separately with the following commands:
   </para>
   <programlisting>
(asdf:load-system 'cl-cffi-gtk-glib)
(asdf:load-system 'cl-cffi-gtk-gobject)
(asdf:load-system 'cl-cffi-gtk-gdk)
(asdf:load-system 'cl-cffi-gtk-gdk-pixbuf)
(asdf:load-system 'cl-cffi-gtk-gio)
(asdf:load-system 'cl-cffi-gtk-pango)
(asdf:load-system 'cl-cffi-gtk-cairo)
   </programlisting>
   <para>
    Please consult the ASDF documentation which is available at
    <ulink url="http://common-lisp.net/project/asdf/">common-lisp.net/project/asdf/</ulink>
    for configuring ASDF to find your systems.
   </para>
   <para>
    The <code>cl-cffi-gtk</code> library depends further on the following libraries:
   </para>
   <variablelist>
    <varlistentry>
     <term>CFFI</term>
     <listitem>
      <para>
       the Common Foreign Function Interface, purports to be a portable foreign function interface for
       Common Lisp.
       See <ulink url="http://common-lisp.net/project/cffi/">common-lisp.net/project/cffi/</ulink>.
      </para>
      <para>
       <emphasis>Warning:</emphasis> Yout must use the version 0.11.2 or newer of the CFFI library.
       Older versions of CFFI are no longer compatible with the implementation of <code>cl-cffi-gtk</code>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Trivial-Garbage</term>
     <listitem>
      <para>
       provides a portable API to finalizers, weak hash-tables and weak pointers on all major CL
       implementations. See <ulink url="http://common-lisp.net/project/trivial-garbage/">
       common-lisp.net/project/trivial-garbage</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Iterate</term>
     <listitem>
      <para>
       is a lispy and extensible replacement for the LOOP macro.
       See <ulink url="http://common-lisp.net/project/iterate/">common-lisp.net/project/iterate/</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bordeaux-Threads</term>
     <listitem>
      <para>
       lets you write multi-threaded applications in a portable way.
       See <ulink url="http://common-lisp.net/project/bordeaux-threads/">
       common-lisp.net/project/bordeaux-threads/</ulink>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Closer-MOP</term>
     <listitem>
      <para>
       Closer to MOP is a compatibility layer that rectifies many of the absent or incorrect MOP features as
       detected by MOP Feature Tests. See
       <ulink url="http://common-lisp.net/project/closer/closer-mop.html">
       common-lisp.net/project/closer/closer-mop.html</ulink>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Information about the installation can be obtained with the function &cl-cffi-gtk-build-info;. This is an
    example for the output, when calling the function from the Lisp prompt after loading the library:
   </para>
   <programlisting>
* (cl-cffi-gtk-build-info)

cl-cffi-gtk version: 1.0.0
cl-cffi-gtk build date: 21:3 9/28/2020
GTK+ version: 3.24.20
GLIB version: 2.64.3
GDK-Pixbuf version: 2.40.0
Pango version: 1.44.7
Cairo version: 1.16.0
Machine type: X86-64
Machine version: Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz
Software type: Linux
Software version: 5.4.0-48-generic
Lisp implementation type: SBCL
Lisp implementation version: 2.0.1.debian
   </programlisting>
  </section>

  <section id="Simple_Window">
   <title>Simple Window</title>
   <figure id="figure-simple-window">
    <title>Simple Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/simple-window202x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <code>cl-cffi-gtk</code> source distribution contains the complete source to all of the examples
    used in this tutorial. To begin the introduction to GTK+, the output of the simplest program possible
    is shown in figure <link linkend="figure-simple-window">Simple Window</link>.
   </para>
   <para>
    The program creates a 200 x 200 pixel window. In this case the window has the default title "sbcl".
    The window can be sized and moved. First in example <link linkend="example-simple-window-c">
    Simple Window in C</link> the C program of the
    <ulink url="http://developer.gnome.org/gtk3/3.14/gtk-getting-started.html#id-1.2.3.3">
    GTK+ 3 Reference Manual (Version 3.14)</ulink> is presented to show the close connection between the
    C library and the implementation of the Lisp binding. The code of the Lisp program is shown in example
    <link linkend="example-simple-window">Simple Window</link>.
   </para>
   <example id="example-simple-window-c">
    <title>Simple window in the programming language C</title>
    <programlisting>
#include &#x3C;gtk/gtk.h>

int main (int argc, char *argv[])
{
  GtkWidget *window;

  gtk_init (&#x26;argc, &#x26;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

  g_signal_connect (window, "destroy", G_CALLBACK (gtk_main_quit), NULL);

  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
    </programlisting>
   </example>
   <example id="example-simple-window">
    <title>Simple Window in the programming language Lisp</title>
    <programlisting>
(asdf:load-system :cl-cffi-gtk)

(defpackage :gtk-tutorial
  (:use :gtk :gdk :gdk-pixbuf :gobject
   :glib :gio :pango :cairo :common-lisp))

(in-package :gtk-tutorial)

(defun example-simple-window ()
  (within-main-loop
    (let (;; Create a toplevel window.
          (window (gtk-window-new :toplevel)))
      ;; Signal handler for the window to handle the signal "destroy".
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Show the window.
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    The first four lines of code load the <code>cl-cffi-gtk</code> library and define an own package
    <code>:gtk-tutorial</code> for the example program. The package <code>:gtk-tutorial</code> includes the
    symbols from the packages <code>:gtk</code> for GTK, <code>:gdk</code> for GDK, <code>:gdk-pixbuf</code>
    for GDK-Pixbuf, <code>:gobject</code> for GObject, <code>:glib</code> for GLib, <code>:gio</code> for
    GIO, <code>:pango</code> for Pango, and <code>:cairo</code> for Cairo. Most of the symbols of the
    included packages are not needed for the first simple examples, but we include all packages so later no
    symbol is missing. In further examples of this tutorial these first lines of code are omitted.
   </para>
   <para>
    The macro &within-main-loop; is a wrapper around a GTK+ program. The functionality of the macro
    corresponds to the C functions <code>gtk_init()</code> and <code>gtk_main()</code> which initialize and
    start a GTK+ program. Both functions have corresponding Lisp functions. The function
    <code>gtk_main()</code> is exported as the Lisp function &gtk-main;. The corresponding Lisp function to
    <code>gtk_init()</code> is called internally when loading the library, but is not exported.
   </para>
   <para>
    Already in this simple example we have connected a signal to the created window. More about signals and
    callback functions follows in section <link linkend="Introduction_to_Signals_and_Callbacks">
    Introduction to Signals and Callbacks</link>. The signal "destroy" is emitted when the user quits the
    window. The function &g-signal-connect; connects a Lisp lambda function to this signal, which calls the
    function &leave-gtk-main; to destroy the GTK+ main loop. Like the macro &within-main-loop; the function
    &leave-gtk-main; is special for the Lisp binding. It calls internally the C function
    <code>gtk_main_quit()</code>, but does some extra work to finish the Lisp program. The C function
    <code>gtk_main_quit()</code> is available in the Lisp binding as &gtk-main-quit;, but do not call this
    function in your code.
   </para>
   <para>
    Only two further functions are needed in this simple example. The window is created with the function
    &gtk-window-new;. The keyword <code>:toplevel</code> tells GTK+ to create a toplevel window. The second
    function &gtk-widget-show-all; displays the new window.
   </para>
   <para>
    In addition to the function &gtk-widget-show-all; the function &gtk-widget-show; is available. It only
    displays the widget, which is the argument to the function. The function &gtk-widget-show-all; displays
    the window and all including child widgets. For the first simple window this makes no difference, because
    the window has no child widgets.
   </para>
  </section>

  <section id="More_about_the_Lisp_binding_to_GTK+">
   <title>More about the Lisp binding to GTK+</title>
   <figure id="figure-getting-started">
    <title>Getting started</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/getting-started252x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The figure <link linkend="figure-getting-started">Getting Started</link> and example
    <link linkend="example-getting-started">Getting Started</link> show a second implementation of the
    simple program discussed in section <link linkend="Simple_Window">Simple Window</link>. The second
    implementation uses the fact, that all GTK+ widgets are internally represented in the Lisp binding
    through a Lisp class. The Lisp class &gtk-window; represents the required window, which corresponds to
    the C class <code>GtkWindow</code>. An instance of the Lisp class &gtk-window; can be created with the
    function <code>make-instance</code>. Furthermore, the slots of the window class can be given new values
    to overwrite the default values. These slots represent the properties of the C classes. In addition an
    instance has all properties of the inherited classes. The object hierarchy in the
    <ulink url="http://crategus.com/books/cl-cffi-gtk">cl-cffi-gtk API documentation</ulink> shows, that the
    class &gtk-window; inherits all properties of the classes &gtk-widget;, &gtk-container;, and &gtk-bin;.
   </para>
   <para>
    In example <link linkend="example-getting-started">Getting Started</link> the property &gtk_window_type;
    with the keyword <code>:toplevel</code> creates again a toplevel window. In addition a title is set
    assigning the string <code>"Getting started"</code> to the property &gtk_window_title; and the width of
    the window is a little enlarged assigning the value 250 to the property &gtk_window_default-width;.
    The result of the example program is shown in figure
    <link linkend="figure-getting-started">Getting Started</link>.
   </para>
   <para>
    The keyword <code>:toplevel</code> is one of the values of the enumeration type
    <code>GtkWindowType</code> in C. In the Lisp binding this enumeration is implemented as &gtk-window-type;
    with the two possible keywords <code>:toplevel</code> for <code>GTK_WINDOW_TOPLEVEL</code> and
    <code>:popup</code> for <code>GTK_WINDOW_POPUP</code>. Most windows are of the type
    <code>:toplevel</code>. Windows with this type are managed by the window manager and have a frame by
    default. Windows with type <code>:popup</code> are ignored by the window manager and are used to
    implement widgets such as menus or tooltips.
   </para>
   <example id="example-getting-started">
    <title>Getting started</title>
    <programlisting>
(defun example-getting-started ()
  (within-main-loop
    (let (;; Create a toplevel window with a title and a default width.
          (window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Getting started"
                                 :default-width 250)))
      ;; Signal handler for the window to handle the signal "destroy".
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Show the window.
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    The example <link linkend="example-getting-started">Getting Started</link> shows, that the Lisp function
    &gtk-window-new; is not really needed. The function &gtk-window-new; is internally implemented in the
    Lisp binding simply as:
   </para>
   <programlisting>
(defun gtk-window-new (type)
  (make-instance 'gtk-window :type type))
   </programlisting>
   <para>
    To set the title of the window or to change the default width of a window the C library knows accessor
    functions to set the corresponding values. In C the title of the window is set with the function
    <code>gtk_window_set_title()</code>. The corresponding Lisp function is &gtk-window-title;. Accordingly,
    the default width of the window can be set in C with the function
    <code>gtk_window_set_default_size()</code>, which sets both the default width and the default height. In
    Lisp this function is named &gtk-window-default-size;.
   </para>
   <para>
    At last, in Lisp it is possible to use the accessors of the slots to get or set the value of a widget
    property. The properties &gtk_window_default-width; and &gtk_window_default-height; of the Lisp class
    &gtk-window; have the Lisp accessor functions &gtk-window-default-width; and &gtk-window-default-height;.
    With these accessor functions the C function <code>gtk_window_set_default_size()</code> is implemented
    the following way in the Lisp library as the function <code>(setf gtk-window-default-size)</code>:
   </para>
   <programlisting>
(defun (setf gtk-window-default-size) (size window)
  (destructuring-bind (width height) size
     (values (setf (gtk-window-default-width window) width)
             (setf (gtk-window-default-height window) height))))
   </programlisting>
   <para>
    As a second example the Lisp implementation of the C function <code>gtk_window_get_default_size()</code>
    is shown:
   </para>
   <programlisting>
(defun gtk-window-default-size (window)
  (values (gtk-window-default-width window)
          (gtk-window-default-height window)))
   </programlisting>
   <para>
    In distinction to the C function <code>gtk_window_get_default_size()</code>, which is implemented as
   </para>
   <programlisting>
void gtk_window_get_default_size (GtkWindow *window,
                                  gint      *width,
                                  gint      *height)
   </programlisting>
   <para>
    the Lisp implementation does not modify the arguments <code>width</code> and <code>height</code>, but
    returns the values.
   </para>
   <para>
    Note the naming conventions for the translation of C accessor functions to Lisp generic functions.
    C reader functions with the name <code>gtk_&#x3c;class>_get_&#x3c;property></code> get the Lisp name
    <code>gtk-&#x3c;class>-&#x3c;property></code> and the C writer functions
    <code>gtk_&#x3c;class>_set_&#x3c;property></code> are replaced by the corresponding
    <code>(setf gtk-&#x3c;class>-&#x3c;property>)</code> functions. That is, for example, to get the property
    &gtk_window_title; of a &gtk-window; use the generic function &gtk-window-title; and to set the title use
    the generic function <code>(setf gtk-window-title)</code>.
   </para>
  </section>

  <section id="Hello_World_in_GTK+">
   <title>Hello World in GTK+</title>
   <figure id="figure-hello-world">
    <title>Hello World</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/hello-world252x80.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Now a program with a button is presented. The output is shown in figure
    <link linkend="figure-hello-world">Hello World</link>. Again the C program from the
    <ulink url="http://developer.gnome.org/gtk3/3.14/gtk-getting-started.html">
    GTK+ 3 Reference Manual</ulink> is shown first in <link linkend="example-hello-world-c">
    Example Hello World in C</link> to learn more about the differences between a C and a Lisp implementation.
   </para>
   <example id="example-hello-world-c">
    <title>Hello World in the programming language C</title>
    <programlisting>
#include &#x3c;gtk/gtk.h>

/* This is a callback function. The data arguments are ignored
 * in this example. More on callbacks below. */
static void hello( GtkWidget *widget, gpointer data )
{
    g_print ("Hello World\n");
}

static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    /* If you return FALSE in the "delete-event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete-event". */

    return TRUE;
}

/* Another callback */
static void destroy( GtkWidget *widget, gpointer data )
{
    gtk_main_quit ();
}

int main( int argc, char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&#x26;argc, &#x26;argv);

    /* create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    /* When the window is given the "delete-event" signal (this is given
     * by the window manager, usually by the "close" option, or on the
     * titlebar), we ask it to call the delete_event () function
     * as defined above. The data passed to the callback
     * function is NULL and is ignored in the callback function. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);

    /* Here we connect the "destroy" event to a signal handler.
     * This event occurs when we call gtk_widget_destroy() on the window,
     * or if we return FALSE in the "delete-event" callback. */
    g_signal_connect (window, "destroy",
		      G_CALLBACK (destroy), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* Creates a new button with the label "Hello World". */
    button = gtk_button_new_with_label ("Hello World");

    /* When the button receives the "clicked" signal, it will call the
     * function hello() passing it NULL as its argument.  The hello()
     * function is defined above. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (hello), NULL);

    /* This will cause the window to be destroyed by calling
     * gtk_widget_destroy(window) when "clicked".  Again, the destroy
     * signal could come from here, or the window manager. */
    g_signal_connect_swapped (button, "clicked",
			      G_CALLBACK (gtk_widget_destroy),
                              window);

    /* This packs the button into the window (a gtk container). */
    gtk_container_add (GTK_CONTAINER (window), button);

    /* The final step is to display this newly created widget. */
    gtk_widget_show (button);

    /* and the window */
    gtk_widget_show (window);

    /* All GTK applications must have a gtk_main(). Control ends here
     * and waits for an event to occur (like a key press or
     * mouse event). */
    gtk_main ();

    return 0;
}
    </programlisting>
   </example>
   <para>
    Now, the Lisp implementation is presented in example <link linkend="example-hello-world">
    Hello World</link>. One difference is, that the function <code>make-instance</code> is used to create
    the window and the button. Another point is, that the definition of separate callback functions is
    avoided. The callback functions are short, implemented through Lisp <code>lambda</code> functions and
    are passed as the third argument to the function &g-signal-connect;.
    More about signals and callback functions follows in
    <link linkend="Introduction_to_Signals_and_Callbacks">Indroduction to Signals and Callbacks</link>.
   </para>
   <para>
    In example <link linkend="example-hello-world">Hello World</link> a border with a width of 12 is added
    to the window setting the property &gtk_container_border-width; when creating the window with the
    function <code>make-instance</code>. The C implementation uses the function
    <code>gtk_container_set_border_width()</code> which is available in Lisp as the accessor
    &gtk-container-border-width;. The property &gtk_container_border-width; is inherited from the C class
    <code>GtkContainer</code>, which in the Lisp library is represented through the Lisp class
    &gtk-container;. Therefore, the accessor function has the prefix <code>gtk_container</code> in C and
    <code>gtk-container</code> in Lisp. A full list of properties of <code>GtkContainer</code> is available
    in the &gtk-container; documentation.
   </para>
   <example id="example-hello-world">
    <title>Hello World in the programming language Lisp</title>
    <programlisting>
(defun example-hello-world ()
  (within-main-loop
    (let (;; Create a toplevel window, set a border width.
          (window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Hello World"
                                 :default-width 250
                                 :border-width 12))
          ;; Create a button with a label.
          (button (make-instance 'gtk-button :label "Hello World")))
      ;; Signal handler for the button to handle the signal "clicked".
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Hello world.~%")
                          (gtk-widget-destroy window)))
      ;; Signal handler for the window to handle the signal "destroy".
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Signal handler for the window to handle the signal "delete-event".
      (g-signal-connect window "delete-event"
                        (lambda (widget event)
                          (declare (ignore widget event))
                          (format t "Delete Event Occured.~%")
                          +gdk-event-stop+))
      ;; Put the button into the window.
      (gtk-container-add window button)
      ;; Show the window and the button.
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    An attentive reader notes that in distinction to the C implementation the function &gtk-widget-show; is
    not called for every single widget, which are in example <link linkend="example-hello-world">
    Hello World</link> the window and the button. Instead the function &gtk-widget-show-all; is used to
    display the window with all including widgets.
   </para>
   <para>
    Three more functions are introduced in example <link linkend="example-hello-world">Hello World</link>.
    The function <ulink url="&gtk-widget-destroy;"><code>gtk-widget-destroy</code></ulink> takes as an
    argument any widget and destroys it. In the above example this function is called by the signal handler
    of the button. When the button is clicked by the user, the signal "clicked" is catched by the signal
    handler, which causes a call of the function <ulink url="&gtk-widget-destroy;">
    <code>gtk-widget-destroy</code></ulink> for the toplevel window. Now the toplevel window receives the
    signal "destroy", which is handled by a signal handler of the toplevel window. This signal handler
    calls the function &leave-gtk-main;, which stops the event loop and finishes the application.
   </para>
   <para>
    A second signal handler is connected to the toplevel window to catch the signal "delete-event". The
    signal "delete-event" occurs, when the user or the window manager tries to close the window. In this
    case, the signal handler prints a message on the console. Because the value of the constant
    <ulink url="&gdk-event-stop;"><code>+gdk-event-stop+</code></ulink> is <emphasis>true</emphasis> the
    signal handler stops the handling of the signal and the window is not closed, but the execution of the
    application is continued. To close the window, the user has to press the button in this example. There
    is a second constant <ulink url="&gdk-event-propagate;"><code>+gdk-event-propagate+</code></ulink> which
    is used to make sure that the propagation of the event is continued. At last, the function
    &gtk-container-add; is used to put the button into the toplevel window. The section
    <link linkend="Packing_Widgets"> Packing Widgets</link> shows how it is possible to put more than one
    widget into a window.
   </para>
  </section>

  <section id="Introduction_to_Signals_and_Callbacks">
   <title>Introduction to Signals and Callbacks</title>
   <para>
    GTK+ is an event driven toolkit, which means GTK+ will sleep until an event occurs and control is passed
    to the appropriate function. This passing of control is done using the idea of "signals". (Note that
    these signals are not the same as the Unix system signals, and are not implemented using them, although
    the terminology is almost identical.) When an event occurs, such as the press of a mouse button, the
    appropriate signal will be "emitted" by the widget that was pressed. This is how GTK+ does most of its
    useful work. There are signals that all widgets inherit, such as "destroy", and there are signals that
    are widget specific, such as "toggled" on a toggle button.
   </para>
   <para>
    To make a button perform an action, a signal handler is set up to catch these signals and to call the
    appropriate function. This is done in the C GTK+ library by using a function such as
   </para>
   <programlisting>
gulong g_signal_connect( gpointer      *object,
                         const gchar   *name,
                         GCallback     func,
                         gpointer      func_data );
   </programlisting>
   <para>
    where the first argument is the widget which will be emitting the signal, and the second the name of the
    signal to catch. The third is the function to be called when the signal is caught, and the fourth, the
    data to have passed to this function.
   </para>
   <para>
    The function specified in the third argument is called a "callback function", and is for a C program of
    the form
   </para>
   <programlisting>
void callback_func( GtkWidget *widget,
                    ... /* other signal arguments */
                    gpointer   callback_data );
   </programlisting>
   <para>
    where the first argument will be a pointer to the widget that emitted the signal, and the last a pointer
    to the data given as the last argument to the C function <code>g_signal_connect()</code> as shown above.
    Note that the above form for a signal callback function declaration is only a general guide, as some
    widget specific signals generate different calling parameters.
   </para>
   <para>
    This mechanism is realized in Lisp with a similar function &g-signal-connect; which has the arguments
    <code>widget</code>, <code>name</code>, and <code>func</code>. In distinction from C the Lisp function
    &g-signal-connect; has not the argument <code>func_data</code>. The functionality of passing data to a
    callback function can be realized with the help of a <code>lambda</code> function in Lisp.
   </para>
   <para>
    As an example the following code shows a typical C implementation which is used in the Hello World
    program.
   </para>
   <programlisting>
g_signal_connect (window, "destroy", G_CALLBACK (destroy), NULL);
   </programlisting>
   <para>
    This is the corresponding callback function which is called when the event "destroy" occurs.
   </para>
   <programlisting>
static void destroy (GtkWidget *widget, gpointer data)
{
    gtk_main_quit ();
}
   </programlisting>
   <para>
    In the corresponding Lisp implementation we simply declare a <code>lambda</code> function as a callback
    function which is passed as the third argument.
   </para>
   <programlisting>
(g-signal-connect window "destroy"
                  (lambda (widget)
                    (declare (ignore widget))
                    (leave-gtk-main)))
   </programlisting>
   <para>
    If it is necessary to have a separate function which needs user data, the following implementation is
    possible
   </para>
   <programlisting>
(defun separate-event-handler (widget arg1 arg2 arg3)
  [ here is the code of the event handler ] )

(g-signal-connect window "destroy"
                  (lambda (widget)
                    (separate-event-handler widget arg1 arg2 arg3)))
   </programlisting>
   <para>
    If no extra data is needed, but the callback function should be separated out than it is also possible
    to implement something like
   </para>
   <programlisting>
(g-signal-connect window "destroy" #'separate-event-handler)
   </programlisting>
  </section>

  <section id="Upgraded_Hello_World">
   <title>Upgraded Hello World</title>
   <figure id="figure-upgraded-hello-world">
    <title>Upgraded Hello World</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/upgraded-hello-world252x104.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Figure <link linkend="figure-upgraded-hello-world">Upgraded Hello World</link> and example
    <link linkend="example-upgraded-hello-world">Upraded Hello World</link> show a slightly improved Hello
    World with better examples of callbacks. This will also introduce the next topic, packing widgets.
    First, the C program is shown in example <link linkend="example-upgraded-hello-world-c">
    Upgraded Hello World in C</link>.
   </para>
   <example id="example-upgraded-hello-world-c">
    <title>An upgraded Hello World in the programming language C</title>
    <programlisting>
#include &#x3c;gtk/gtk.h>

/* Our new improved callback.  The data passed to this function
 * is printed to stdout. */
static void callback( GtkWidget *widget, gpointer data )
{
    g_print ("Hello again - %s was pressed\n", (gchar *) data);
}

/* another callback */
static gboolean delete_event( GtkWidget *widget,
                              GdkEvent  *event,
                              gpointer   data )
{
    gtk_main_quit ();
    return FALSE;
}

int main( int argc, char *argv[] )
{
    /* GtkWidget is the storage type for widgets */
    GtkWidget *window;
    GtkWidget *button;
    GtkWidget *box1;

    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    gtk_init (&#x26;argc, &#x26;argv);

    /* Create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    /* This is a new call, which just sets the title of our
     * new window to "Hello Buttons!" */
    gtk_window_set_title (GTK_WINDOW (window), "Hello Buttons!");

    /* Here we just set a handler for delete_event that immediately
     * exits GTK. */
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (delete_event), NULL);

    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);

    /* We create a box to pack widgets into.  This is described in detail
     * in the "packing" section. The box is not really visible, it
     * is just used as a tool to arrange widgets. */
    box1 = gtk_hbox_new (FALSE, 0);

    /* Put the box into the main window. */
    gtk_container_add (GTK_CONTAINER (window), box1);

    /* Creates a new button with the label "Button 1". */
    button = gtk_button_new_with_label ("Button 1");

    /* Now when the button is clicked, we call the "callback" function
     * with a pointer to "button 1" as its argument */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 1");

    /* Instead of gtk_container_add, we pack this button into the invisible
     * box, which has been packed into the window. */
    gtk_box_pack_start (GTK_BOX(box1), button, TRUE, TRUE, 0);

    /* Always remember this step, this tells GTK that our preparation for
     * this button is complete, and it can now be displayed. */
    gtk_widget_show (button);

    /* Do these same steps again to create a second button */
    button = gtk_button_new_with_label ("Button 2");

    /* Call the same callback function with a different argument,
     * passing a pointer to "button 2" instead. */
    g_signal_connect (button, "clicked",
		      G_CALLBACK (callback), (gpointer) "button 2");

    gtk_box_pack_start(GTK_BOX (box1), button, TRUE, TRUE, 0);

    /* The order in which we show the buttons is not really important, but I
     * recommend showing the window last, so it all pops up at once. */
    gtk_widget_show (button);

    gtk_widget_show (box1);

    gtk_widget_show (window);

    /* Rest in gtk_main and wait for the fun to begin! */
    gtk_main ();

    return 0;
}
    </programlisting>
   </example>
   <para>
    The Lisp implementation in example <link linkend="example-upgraded-hello-world">
    Upgraded Hello World</link> tries to be close to the C program. Therefore, the window and the box are
    created with the functions &gtk-window-new; and &gtk-box-new;. Various properties like the title of the
    window, the default size or the border width are set with the functions &gtk-window-title;,
    &gtk-window-default-size; and &gtk-container-border-width;. As described for the example
    <link linkend="example-hello-world">Hello World</link> the function &gtk-widget-show-all; is used to
    display the window including all child widgets.
   </para>
   <para>
    One main difference of the Lisp implementation is the use of the function &gtk-box-new; with an argument
    <code>:horizontal</code> to create a horizontal box. The <code>GtkHBox</code> widget which is used in the
    <ulink url="http://developer.gnome.org/gtk3/3.14/gtk-getting-started.html">
    GTK+ 3 Reference Manual</ulink> is deprecated and is replaced by <code>GtkBox</code> with the property
    &gtk_orientable_orientation;. More about boxes and their usages follows in section
    <link linkend="Packing_Widgets"> Packing Widgets</link>.
   </para>
   <example id="example-upgraded-hello-world">
    <title>Upgraded Hello World in the programming language C</title>
    <programlisting>
(defun example-upgraded-hello-world ()
  (within-main-loop
    (let ((window (gtk-window-new :toplevel))
          (box (gtk-box-new :horizontal 6))
          (button  nil))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (setf (gtk-window-title window) "Hello Buttons")
      (setf (gtk-window-default-size window) '(250 75))
      (setf (gtk-container-border-width window) 12)
      (setf button (gtk-button-new-with-label "Button 1"))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Button 1 was pressed.~%")))
      (gtk-box-pack-start box button :expand t :fill t :padding 0)
      (setf button (gtk-button-new-with-label "Button 2"))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Button 2 was pressed.~%")))
      (gtk-box-pack-start box button :expand t :fill t :padding 0)
      (gtk-container-add window box)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    The second implementation in example <link linkend="example-upgraded-hello-world-2">
    Upgraded Hello World</link> makes more use of a Lisp style. The window is created with the Lisp function
    <code>make-instance</code>. All desired properties of the window are initialized by assigning values to
    the slots of the classes &gtk-window; and &gtk-box;. The Lisp implementation uses a lot keywords
    arguments with default values for long lists of arguments. In example
    <link linkend="example-upgraded-hello-world-2">Upgraded Hello World</link> the keyword arguments
    <code>expand</code>, <code>fill</code>, and <code>padding</code> of the function "&gtk-box-pack-start;
    take their default values. In future examples of this tutorial the style shown in example
    <link linkend="example-upgraded-hello-world-2">Upgraded Hello World</link> is preferred. Furthermore,
    the C code is no longer presented for comparison.
   </para>
   <example id="example-upgraded-hello-world-2">
    <title>Second implementation of Upgraded Hello World</title>
    <programlisting>
(defun example-upgraded-hello-world-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Hello Buttons"
                                 :default-width 250
                                 :default-height 75
                                 :border-width 12))
          (box (make-instance 'gtk-box
                              :orientation :horizontal
                              :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (let ((button (gtk-button-new-with-label "Button 1")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (format t "Button 1 was pressed.~%")))
        (gtk-box-pack-start box button))
      (let ((button (gtk-button-new-with-label "Button 2")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (format t "Button 2 was pressed.~%")))
        (gtk-box-pack-start box button))
      (gtk-container-add window box)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Drawing_in_response_to_input">
   <title>Drawing in response to input</title>
   <figure id="figure-drawing">
    <title>Drawing in response to input</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/drawing278x255.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Many widgets, like buttons, do all their drawing themselves. You just tell them the label you want to
    see, and they figure out what font to use, draw the button outline and focus rectangle, etc. Sometimes,
    it is necessary to do some custom drawing. In that case, a &gtk-drawing-area; might be the right widget
    to use. It offers a canvas on which you can draw by connecting to the "draw" signal.
   </para>
   <para>
    The contents of a widget often need to be partially or fully redrawn, e.g. when another window is moved
    and uncovers part of the widget, or when the window containing it is resized. It is also possible to
    explicitly cause part or all of the widget to be redrawn, by calling the function &gtk-widget-queue-draw;
    or its variants. GTK+ takes care of most of the details by providing a ready-to-use Cairo context to the
    "draw" signal handler.
   </para>
   <para>
    The following example shows a "draw" signal handler. It is a more complicated than the previous examples,
    since it also demonstrates input event handling by means of "button-press" and "motion-notify" handlers.
   </para>
   <example id="example-drawing">
    <title>Drawing in response to input</title>
    <programlisting>
(let ((surface nil))
  (defun example-drawing ()
    (within-main-loop
      (let ((window (make-instance 'gtk-window
                                   :type :toplevel
                                   :title "Example Drawing"))
            (frame (make-instance 'gtk-frame
                                  :shadow-type :in))
            (area (make-instance 'gtk-drawing-area
                                 :width-request 250
                                 :height-request 200)))
        (g-signal-connect window "destroy"
                          (lambda (widget)
                            (declare (ignore widget))
                            (leave-gtk-main)))
        ;; Signals used to handle the backing surface
        (g-signal-connect area "draw"
           (lambda (widget cr)
             (declare (ignore widget))
             (let ((cr (pointer cr)))
               (cairo-set-source-surface cr surface 0.0 0.0)
               (cairo-paint cr)
               (cairo-destroy cr)
               +gdk-event-propagate+)))
        (g-signal-connect area "configure-event"
           (lambda (widget event)
             (declare (ignore event))
             (when surface
               (cairo-surface-destroy surface))
             (setf surface
                   (gdk-window-create-similar-surface
                                   (gtk-widget-window widget)
                                   :color
                                   (gtk-widget-allocated-width widget)
                                   (gtk-widget-allocated-height widget)))
             ;; Clear surface
             (let ((cr (cairo-create surface)))
               (cairo-set-source-rgb cr 1.0 1.0 1.0)
               (cairo-paint cr)
               (cairo-destroy cr))
             (format t "leave event 'configure-event'~%")
             +gdk-event-stop+))
        ;; Event signals
        (g-signal-connect area "motion-notify-event"
           (lambda (widget event)
             (format t "MOTION-NOTIFY-EVENT ~A~%" event)
             (when (member :button1-mask (gdk-event-motion-state event))
               (let ((cr (cairo-create surface))
                     (x (gdk-event-motion-x event))
                     (y (gdk-event-motion-y event)))
                 (cairo-rectangle cr (- x 3.0) (- y 3.0) 6.0 6.0)
                 (cairo-fill cr)
                 (cairo-destroy cr)
                 (gtk-widget-queue-draw-area widget
                                             (truncate (- x 3.0))
                                             (truncate (- y 3.0))
                                             6
                                             6)))
             ;; We have handled the event, stop processing
             +gdk-event-stop+))
        (g-signal-connect area "button-press-event"
           (lambda (widget event)
             (format t "BUTTON-PRESS-EVENT ~A~%" event)
             (if (eql 1 (gdk-event-button-button event))
                 (let ((cr (cairo-create surface))
                       (x (gdk-event-button-x event))
                       (y (gdk-event-button-y event)))
                   (cairo-rectangle cr (- x 3.0) (- y 3.0) 6.0 6.0)
                   (cairo-fill cr)
                   (cairo-destroy cr)
                   (gtk-widget-queue-draw-area widget
                                               (truncate (- x 3.0))
                                               (truncate (- y 3.0))
                                               6
                                               6))
                 ;; Clear surface
                 (let ((cr (cairo-create surface)))
                   (cairo-set-source-rgb cr 1.0 1.0 1.0)
                   (cairo-paint cr)
                   (cairo-destroy cr)
                   (gtk-widget-queue-draw widget)))))
        (gtk-widget-add-events area
                               '(:button-press-mask
                                 :pointer-motion-mask))
        (gtk-container-add frame area)
        (gtk-container-add window frame)
        (gtk-widget-show-all window)))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Packing_Widgets">
  <title>Packing Widgets</title>
  <section id="Packing_Boxes">
   <title>Packing Boxes</title>
   <para>
    When creating an application, it is necessary to put more than one widget inside a window. The first
    Hello world example only used one button so it could simply use the function &gtk-container-add; to
    "pack" the button into the window. But when more than one widget must be put into a window packing comes
    in.
   </para>
   <para>
    Packing is done by creating boxes or grids. Grids are more general and powerful than boxes. Grids are
    explained later in this tutorial. Boxes are invisible widget containers that can pack widgets into,
    which come in two forms, a horizontal box, and a vertical box. When packing widgets into a horizontal
    box, the objects are inserted horizontally from left to right or right to left depending on the call
    used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use any
    combination of boxes inside or beside other boxes to create the desired effect.
   </para>
   <para>
    To create a new box of the type &gtk-box;, the function &gtk-box-new; or the call
    <code>(make-instance 'gtk-box)</code> is used. The first argument of the function &gtk-box-new; takes a
    keyword of the enumeration type <code>GtkOrientation</code>, which, in the Lisp binding, is implemented
    as the &gtk-orientation; enumeration with the values <code>:horizontal</code> or <code>:vertical</code>
    to determine a horizontal or a vertical box. Because &gtk-box; implements the interface &gtk-orientable;
    an instance of &gtk-box; has the property &gtk_orientable_orientation; of type &gtk-orientation;.
   </para>
   <table id="table-gtk-box" frame='all'>
    <title>Functions for GtkBox</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Function</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>gtk-box-new</code></entry>
       <entry valign="top">Creates a new <code>gtk-box</code> container.</entry>
      </row>
      <row>
       <entry valign="top"><code>gtk-box-homogeneous</code></entry>
       <entry valign="top">Accessor of the <code>homogeneous</code> property.</entry>
      </row>
      <row>
       <entry valign="top"><code>gtk-box-spacing</code></entry>
       <entry valign="top">Accessor of the <code>spacing</code> property.</entry>
      </row>
      <row>
       <entry valign="top"><code>gtk-box-pack-start</code></entry>
       <entry valign="top">Adds a child to the box, packed with reference to the start of the box.</entry>
      </row>
      <row>
       <entry valign="top"><code>gtk-box-pack-end</code></entry>
       <entry valign="top">Adds a child to the box, packed with reference to the end of the box.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    The following examples show two equivalent ways to create an instance of a horizontal box. The first
    argument of the function &gtk-box-new; takes the value of the property &gtk_orientable_orientation;. The
    second argument is the value of the property &gtk_box_spacing;, which is described in section
    <link linkend="Details_of_Boxes">Details of Boxes</link>
   </para>
   <programlisting>
(let ((box (gtk-box-new :horizontal 3)))
  ... )
   </programlisting>
   <para>or</para>
   <programlisting>
(let ((box (make-instance 'gtk-box
                          :orientation :horizontal
                          :spacing 3)))
  ... )
   </programlisting>
   <para>
    The functions &gtk-box-pack-start; and &gtk-box-pack-end; are used to place widgets inside of boxes. The
    function &gtk-box-pack-start; starts at the top and works its way down in a vertical box, and packs left
    to right in a horizontal box. The function &gtk-box-pack-end; does the opposite, packing from bottom to
    top in a vertical box, and right to left in a horizontal box. The widgets, which are packed into a box,
    can be containers, which are composed of other widgets. Using the functions for packing widgets in boxes
    allows to right justify or left justify the widgets. The functions can be mixed in any way to achieve the
    desired effect. Most of the examples in this tutorial use the function &gtk-box-pack-start;>. In the
    following example a vertical box is created. Then two label widgets are packed into the box with the
    function &gtk-box-pack-start;.
   </para>
   <programlisting>
(let ((box (gtk-box-new :vertical 3)))
  (gtk-box-pack-start box (gtk-label-new "LABEL 1"))
  (gtk-box-pack-start box (gtk-label-new "LABEL 2"))
  ... )
   </programlisting>
   <para>
    By using boxes, GTK+ knows where to place the widgets so GTK+ can do automatic resizing and other nifty
    things. A number of options control as to how the widgets should be packed into boxes. This method of
    packing boxes gives the user quite a bit of flexibility when placing widgets.
   </para>
   <note>
    <para>
     The classes GtkHBox for horizontal and GtkVBox for vertical boxes are deprecated, but still present in
     GTK+ 3. In this tutorial these classes are not used. In addition a single-row or single-column &gtk-grid;
     provides exactly the same functionality as &gtk-box;. See section <link linkend="Packing_Using_Grids">
     Packing Using Grids</link> for examples to replace &gtk-box; with &gtk-grid;.
    </para>
   </note>
  </section>

  <section id="Details_of_Boxes">
   <title>Details of Boxes</title>
   <para>
    Because of the flexibility, packing boxes in GTK+ can be confusing at first. A lot of options control
    the packing of boxes, and it is not immediately obvious how the options all fit together. In the end,
    however, basically five different styles are available.
   </para>
   <para>
    Boxes have the properties &gtk_box_homogeneous; and &gtk_box_spacing;. The functions &gtk-box-homogeneous;
    and &gtk-box-spacing; are used to write and read the properties. The property &gtk_box_homogeneous;
    controls whether each widget in the box has the same width in a horizontal box or the same height in a
    vertical box. The property &gtk_box_spacing; controls the amount of space between children in the box. A
    complete example for creating a box is therefore
   </para>
   <programlisting>
(let ((box (make-instance 'gtk-box
                          :orientation :vertical
                          :spacing 3
                          :homogeneous t)))
  ... )
   </programlisting>
   <figure id="figure-box-packing">
    <title>Box Packing with a spacing of 3</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/box-packing629x323.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Figure <link linkend="figure-box-packing">Box Packing</link> shows an example of packing buttons into
    horizontal boxes. The buttons have a small spacing of 3. Each line of the example contains one
    horizontal box with several buttons. The first button represents the call of the function
    &gtk-box-pack-start; and the following buttons represent the arguments of the function. The first two
    arguments are <code>box</code> for the box and <code>child</code> for the child widgets to put into the
    box, which are in our example buttons. The further arguments of &gtk-box-pack-start; are in the C
    implementation <code>expand</code>, <code>fill</code> and <code>padding</code>. In the Lisp binding to
    GTK+ these arguments are defined as the keyword arguments <code>:expand</code> and <code>:fill</code>,
    which both have a default value of <emphasis>true</emphasis>, and <code>:padding</code> with a default
    value of <code>0</code>. The keyword arguments can be omitted, in which case the default values will
    be used.
   </para>
   <para>
    The keyword argument <code>:expand</code> with a value <emphasis>true</emphasis> to the functions
    &gtk-box-pack-start; and &gtk-box-pack-end; controls whether the widgets are laid out in the box to fill
    in all the extra space in the box so the box is expanded to fill the area allotted to it; or with a value
    <code>nil</code> the box is shrunk to just fit the widgets. Setting expand to <code>nil</code> allows to
    do right and left justification of the widgets. Otherwise, the widgets expand to fit into the box. The
    same effect can be achieved by using only one of the functions &gtk-box-pack-start; or &gtk-box-pack-end;.
   </para>
   <para>
    The keyword argument <code>:fill</code> with a value <emphasis>true</emphasis> to the
    <code>gtk-box-pack</code> functions control whether the extra space is allocated to the objects
    themselves, or with a value <code>nil</code> as extra padding in the box around these objects. It only
    has an effect if the keyword argument <code>expand</code> is also <emphasis>true</emphasis>.
   </para>
   <para>
    The difference between spacing, set when the box is created, and padding, set when elements are packed,
    is, that spacing is added between objects, and padding is added on either side of a child widget.
   </para>
   <para>
    The code for figure <link linkend="figure-box-packing">Box Packing</link> is shown in example
    <link linkend="example-box-packing">Box Packing</link>. The function <code>example-box-packing</code>
    takes an optional argument <code>spacing</code>, which has the default value <code>0</code> and controls
    the spacing of the buttons in the boxes.
   </para>
   <para>
    The example uses two widgets which are not introduced up to now. The first one is the &gtk-label; widget,
    which is described in <link linkend="Labels">Labels</link> and is used to display text. The second one is
    the &gtk-separator; widget, which draws a horizontal or vertical line. The orientation of the line depends
    on the only argument to the function &gtk-separator-new;, which is of the enumeration type
    &gtk-orientation; with the values <code>:horizontal</code> for a horizontal line and
    <code>:vertical</code> for a vertical line.
   </para>
   <example id="example-box-packing">
    <title>Packing Boxes</title>
    <programlisting>
(defun make-box (homogeneous spacing expand fill padding)
  (let ((box (make-instance 'gtk-box
                            :orientation :horizontal
                            :homogeneous homogeneous
                            :spacing spacing)))
    (gtk-box-pack-start box
                        (gtk-button-new-with-label "gtk-box-pack")
                        :expand expand
                        :fill fill
                        :padding padding)
    (gtk-box-pack-start box
                        (gtk-button-new-with-label "box")
                        :expand expand
                        :fill fill
                        :padding padding)
    (gtk-box-pack-start box
                        (gtk-button-new-with-label "button")
                        :expand expand
                        :fill fill
                        :padding padding)
    (gtk-box-pack-start box
                        (if expand
                            (gtk-button-new-with-label "T")
                            (gtk-button-new-with-label "NIL"))
                        :expand expand
                        :fill fill
                        :padding padding)
    (gtk-box-pack-start box
                        (if fill
                            (gtk-button-new-with-label "T")
                            (gtk-button-new-with-label "NIL"))
                        :expand expand
                        :fill fill
                        :padding padding)
    (gtk-box-pack-start box
                        (gtk-button-new-with-label (format nil "&#x7e;A" padding))
                        :expand expand
                        :fill fill
                        :padding padding)
    box))

(defun example-box-packing (&#x26;optional (spacing 0))
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Box Packing"
                                 :type :toplevel
                                 :border-width 12))
          (vbox (make-instance 'gtk-box
                               :orientation :vertical
                               :spacing 6))
          (button (make-instance 'gtk-button
                                 :label "Quit"))
          (quitbox (make-instance 'gtk-box
                                  :orientation :horizontal)))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-box-pack-start vbox
                          (make-instance 'gtk-label
                                         :label
                                         (format nil
                                          "GtkBox   ~
                                           :orientation :horizontal   ~
                                           :homogeneous nil   ~
                                           :spacing ~A"
                                          spacing)
                                         :xalign 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (make-box nil spacing nil nil 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (make-box nil spacing t nil 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (make-box nil spacing t t 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (make-instance 'gtk-label
                                         :label
                                         (format nil
                                            "GtkBox   ~
                                             :orientation :horizontal   ~
                                             :homogeneous t   ~
                                             :spacing ~A"
                                            spacing)
                                         :xalign 0)
                          :expand nil
                          :padding 6)
      (gtk-box-pack-start vbox
                          (make-box t spacing t nil 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (make-box t spacing t t 0)
                          :expand nil)
      (gtk-box-pack-start vbox
                          (gtk-separator-new :horizontal)
                          :expand nil
                          :padding 6)
      ;; Align the quit-button on the right side
      (gtk-box-pack-end quitbox button :expand nil)
      (gtk-box-pack-start vbox quitbox :expand nil)
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Packing_Using_Tables">
   <title>Packing Using Tables</title>
   <para>
    Tables are another way of packing widgets and can be extremely useful in certain situations. Using tables
    a grid is created that widgets can placed in. The widgets may take up as many spaces as specified. Tables
    can be created with the function &gtk-table-new;. The function takes three arguments which set the
    properties of a table. Alternatively, the table is created with the function <code>make-instance</code>.
   </para>
   <para>
    The first argument of &gtk-table-new; is the number of rows to make in the table, while the second is the
    number of columns. The last argument <code>homogeneous</code> has to do with how the boxes of the table
    are sized. If <code>homogeneous</code> is <code>T</code>, the table boxes are resized to the size of the
    largest widget in the table. If <code>homogeneous</code> is <code>NIL</code>, the size of a table boxes is
    dictated by the tallest widget in its same row, and the widest widget in its column. The rows and columns
    are laid out from <code>0</code> to <code>n</code>, where <code>n</code> is the number specified in the
    call to the function &gtk-table-new;. For <code>rows = 2</code> and <code>columns = 2</code>, the layout
    is shown in figure <link linkend="figure-table-layout"> Layout of a 2 x 2 Table</link>. Note that the
    coordinate system starts in the upper left hand corner.
   </para>
   <figure id="figure-table-layout">
    <title>Layout of a 2 x 2 Table</title>
    <programlisting>
 0          1          2
0+----------+----------+
 |          |          |
1+----------+----------+
 |          |          |
2+----------+----------+
    </programlisting>
   </figure>
   <para>
    To place a widget into a table, the function &gtk-table-attach; can be used. The arguments are listed in
    the table <link linkend="table-gtk-table-attach">Table Attach</link>. The first argument
    <code>table</code> is the table you have created and the second <code>child</code> the widget you wish to
    place into the table. The left and right attach arguments specify where to place the widget, and how many
    boxes to use. If you want a button in the lower right table entry of a 2 x 2 table, and want it to fill
    that entry only, <code>left-attach</code> is <code>= 1</code>, <code>right-attach = 2</code>,
    <code>top-attach = 1</code>, <code>bottom-attach = 2</code>. Now, if you wanted a widget to take up the
    whole top row of a 2 x 2 table, you would use <code>left-attach = 0</code>, <code>right-attach = 2</code>,
    <code>top-attach = 0</code>, <code>bottom-attach = 1</code>.
   </para>
   <table id="table-gtk-table-attach" frame='all'>
    <title>Arguments of the function <code>gtk-table-attach</code></title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Argument&#x2003;&#x2003;&#x2003;</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>table</code></entry>
       <entry valign="top">The GtkTable to add a new widget to.</entry>
      </row>
      <row>
       <entry valign="top"><code>child</code></entry>
       <entry valign="top">The widet to add.</entry>
      </row>
      <row>
       <entry valign="top"><code>left-attach</code></entry>
       <entry valign="top">The column number to attach the left side of a child widget to.</entry>
      </row>
      <row>
       <entry valign="top"><code>right-attach</code></entry>
       <entry valign="top">The column number to attach the right side of a child widget to.</entry>
      </row>
      <row>
       <entry valign="top"><code>top-attach</code></entry>
       <entry valign="top">The row number to attach the top of a child widget to.</entry>
      </row>
      <row>
       <entry valign="top"><code>bottom-attach</code></entry>
       <entry valign="top">The row number to attach the bottom of a child widget to.</entry>
      </row>
      <row>
       <entry valign="top"><code>:xoptions</code></entry>
       <entry valign="top">
        Used to specify the properties of the child widget when the table is resized.
        The default value is <code>'(:expand :fill)</code>.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:yoptions</code></entry>
       <entry valign="top">
        The same as <code>xoptions</code>, except this field determines behavior of vertical resizing.
        The default value is <code>'(:expand :fill)</code>.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:xpadding</code></entry>
       <entry valign="top">
        An integer value specifying the padding on the left and right of the widget being added to the table.
        The default value is <code>0</code>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    The arguments <code>:xoptions</code> and <code>:yoptions</code> are of the enumeration type
    &gtk-attach-options; and used to specify packing options. The packing options can be OR'ed together to
    allow multiple options. In the Lisp binding a list of options is used to combine multiple options.
    Possible values of the enumeration type &gtk-attach-options; are listed in the table
    <link linkend="table-gtk-attach-options">GtkAttachOptions</link>.
   </para>
   <para>
    Padding is just like in boxes, creating a clear area around the widget specified in pixels and is
    controlled with the arguments <code>:xpadding</code> and <code>:ypadding</code>.
   </para>
   <table id="table-gtk-attach-options" frame='all'>
    <title>Values of the type GtkAttachOptions</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:fill</code></entry>
       <entry valign="top">
        If the table box is larger than the widget, and <code>:fill</code> is specified, the widget will
        expand to use all the room available.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:shrink</code></entry>
       <entry valign="top">
        If the table widget was allocated less space then was requested (usually by the user resizing the
        window), then the widgets would normally just be pushed off the bottom of the window and disappear.
        If <code>:shrink</code> is specified, the widgets will shrink with the table.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:expand</code></entry>
       <entry valign="top">
         This will cause the table to expand to use up any remaining space in the window.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    In the Lisp binding the arguments <code>:xoptions</code>, <code>:yoptions</code>, <code>:xpadding</code>,
    and <code>:ypadding</code> of the function &gtk-table-attach; are defined as keyword arguments with
    default values as shown in table <link linkend="table-gtk-table-attach">GtkTableAttach</link>. In the C
    library this is realized with a second function <code>gtk_table_attach_defaults()</code>. In the Lisp
    binding the function &gtk-table-attach-defaults; is a second equivalent implementation of
    &gtk-table-attach;, when using the default values of the keyword arguments.
   </para>
   <para>
    The functions &gtk-table-set-row-spacing; and &gtk-table-set-col-spacing; places spacing between the rows
    at the specified row or column. The first argument of the functions is a &gtk-table;, the second argument
    a row or a column and the third argument the spacing. Note that for columns, the space goes to the right
    of the column, and for rows, the space goes below the row.
   </para>
   <para>
    You can also set a consistent spacing of all rows and columns with the functions
    &gtk-table-set-row-spacings; and &gtk-table-set-col-spacings;. Both functions take a &gtk-table; as the
    first argument and the desired spacing <code>spacing</code> as the second argument. Note that with these
    calls, the last row and last column do not get any spacing.
   </para>
   <note>
    <para>
     &gtk-table; has been deprecated since GTK+ 3.4. It is recommended to use &gtk-grid; instead. &gtk-grid;
     provides the same capabilities as &gtk-table; for arranging widgets in a rectangular grid, but does
     support height-for-width geometry management, which is newly introduced for widgets in GTK+ 3. This
     chapter will vanish in the near future.
    </para>
   </note>
  </section>

  <section id="Table_Packing_Example">
   <title>Table Packing Example</title>
   <para>
    The figure <link linkend="figure-table-packing">Table Packing</link> is a window with three buttons in a
    2 x 2 table. The first two buttons are placed in the upper row. A third, quit button, is placed in the
    lower row, spanning both columns. The code of this example is shown in the example
    <link linkend="example-table-packing">Table Packing</link>.
   </para>
   <figure id="figure-table-packing">
    <title>Table Packing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/table-packing306x108.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-table-packing">
    <title>Table Packing</title>
    <programlisting>
(defun example-table-packing ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Table Packing"
                                 :border-width 12
                                 :default-width 300))
          (table (make-instance 'gtk-table
                                :n-columns 2
                                :n-rows 2
                                :homogeneous t))
          (button1 (make-instance 'gtk-button
                                  :label "Button 1"))
          (button2 (make-instance 'gtk-button
                                  :label "Button 2"))
          (quit (make-instance 'gtk-button
                               :label "Quit")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect quit "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (gtk-table-attach table button1 0 1 0 1)
      (gtk-table-attach table button2 1 2 0 1)
      (gtk-table-attach table quit    0 2 1 2)
      (gtk-container-add window table)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    Figure <link linkend="figure-table-packing-2">Table Packing</link> is an extended example to show the
    possibility to increase the spacing of the rows and columns. This is implemented through two toggle
    buttons which increase and decrease the spacings. Toggle buttons are described in
    <link linkend="Toggle_Buttons">Toggle Buttons</link> later in this tutorial. The code of
    <link linkend="figure-table-packing-2">Table Packing</link> is shown in example
    <link linkend="example-table-packing-2">Table Packing</link>.
   </para>
   <figure id="figure-table-packing-2">
    <title>Table Packing with more spacing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/table-packing-2-306x120.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-table-packing-2">
    <title>Table Packing with more spacing</title>
    <programlisting>
(defun example-table-packing-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Table Packing"
                                 :border-width 12
                                 :default-width 300))
          (table (make-instance 'gtk-table
                                :n-columns 2
                                :n-rows 2
                                :homogeneous t))
          (button1 (make-instance 'gtk-toggle-button
                                  :label "More Row Spacing"))
          (button2 (make-instance 'gtk-toggle-button
                                  :label "More Col Spacing"))
          (quit (make-instance 'gtk-button
                               :label "Quit")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect button1 "toggled"
         (lambda (widget)
           (if (gtk-toggle-button-active widget)
               (progn
                 (gtk-table-set-row-spacings table 12)
                 (setf (gtk-button-label widget) "Less Row Spacing"))
               (progn
                 (gtk-table-set-row-spacings table 0)
                 (setf (gtk-button-label widget) "More Row Spacing")))))
      (g-signal-connect button2 "toggled"
         (lambda (widget)
           (if (gtk-toggle-button-active widget)
               (progn
                 (gtk-table-set-col-spacings table 12)
                 (setf (gtk-button-label widget) "Less Col Spacing"))
               (progn
                 (gtk-table-set-col-spacings table 0)
                 (setf (gtk-button-label widget) "More Col Spacing")))))
      (g-signal-connect quit "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (gtk-table-attach table button1 0 1 0 1)
      (gtk-table-attach table button2 1 2 0 1)
      (gtk-table-attach table quit    0 2 1 2)
      (gtk-container-add window table)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Packing_Using_Grids">
   <title>Packing Using Grids</title>
   <para>
    &gtk-grid; is an attempt to write a comprehensive, legacy-free, box-layout container that is flexible
    enough to replace &gtk-box;, &gtk-table; and the like.
   </para>
   <para>
    The layout model of &gtk-grid; is to arrange its children in rows and columns. This is done by assigning
    positions on a two-dimensions grid that stretches arbitrarily far in all directions. Children can span
    multiple rows or columns.
   </para>

   <section id="GtkBox_versus_GtkGrid_packing">
    <title>GtkBox versus GtkGrid - packing</title>
    <para>
     &gtk-box; works by arranging child widgets in a single line, either horizontally or vertically. It
     allows packing children from the beginning or end, using &gtk-box-pack-start; and &gtk-box-pack-end;.
    </para>
    <para>
     The following code creates a simple box with two labels:
    </para>
    <programlisting>
(let ((box (gtk-box-new :horizontal 0)))
  (gtk-box-pack-start box (gtk-label-new "ONE") nil nil 0)
  (gtk-box-pack-start box (gtk-label-new "TWO") nil nil 0)
  ... )
    </programlisting>
    <para>
     This can be done with &gtk-grid; as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child1 (gtk-label-new "ONE"))
      (child2 (gtk-label-new "TWO")))
  (gtk-grid-attach grid child1 0 0 1 1)
  (gtk-grid-attach-next-to grid child2 child1 :right 1 1)
  ... )
    </programlisting>
    <para>
     And similarly for &gtk-box-pack-end;. In that case, you would use <code>:left</code> to place the grid
     children from left to right.
    </para>
    <para>
     If you only need to pack children from the start, using the function &gtk-container-add; is an even
     simpler alternative. &gtk-grid; places children added with &gtk-container-add; in a single row or column
     according to its "orientation".
    </para>
    <para>
     One difference to keep in mind is that the &gtk-box-pack-start; and &gtk-box-pack-end; functions allow
     you to place an arbitrary number of children from either end without ever 'colliding in the middle'.
     With &gtk-grid;, you have to leave enough space between the two ends, if you want to combine packing
     from both ends towards the middle. In practice, this should be easy to avoid; and &gtk-grid; simply
     ignores entirely empty rows or columns for layout and spacing.
    </para>
    <para>
     On the other hand, &gtk-grid; is more flexible in that its grid extends indefinitively in both directions
     - there is no problem with using negative numbers for the grid positions. So, if you discover that you
     need to place a widget before your existing arrangement, you always can.
    </para>
   </section>

   <section id="GtkBox_versus_GtkGrid_sizing">
    <title>GtkBox versus GtkGrid - sizing</title>
    <para>
     When adding a child to a &gtk-box;, there are two hard-to-remember parameters (child properties, more
     exactly) named <code>expand</code> and <code>fill</code> that determine how the child size behaves in
     the main direction of the box. If <code>expand</code> is set, the box allows the position occupied by
     the child to grow when extra space is available. If <code>fill</code> is also set, the extra space is
     allocated to the child widget itself. Otherwise it is left 'free'. There is no control about the 'minor'
     direction; children are always given the full size in the minor direction.
    </para>
    <para>
     &gtk-grid; does not have any custom child properties for controlling size allocation to children.
     Instead, it fully supports the newly introduced &gtk_widget_hexpand;, &gtk_widget_vexpand;,
     &gtk_widget_halign;, and &gtk_widget_valign; properties for widgets.
    </para>
    <para>
     The &gtk_widget_hexpand; and &gtk_widget_vexpand; properties operate in a similar way to the expand child
     properties of &gtk-box;. As soon as a column contains a hexpanding child, &gtk-grid; allows the column to
     grow when extra space is available (similar for rows and &gtk_widget_vexpand;). In contrast to &gtk-box;,
     all the extra space is always allocated to the child widget, there are no 'free' areas.
    </para>
    <para>
     To replace the functionality of the <code>fill</code> child properties, you can set the
     &gtk_widget_halign; and &gtk_widget_valign; properties. An align value of <code>:fill</code> has the
     same effect as setting <code>fill</code> to <emphasis>true</emphasis>, a value of <code>:center</code>
     has the same effect as setting <code>fill</code> to <code>nil</code>.
    </para>
    <para>
     Expansion and alignment with &gtk-box;:
    </para>
    <programlisting>
(let ((box (gtk-box-new :horizontal 0)))
  (gtk-box-pack-start box (gtk-label-new "ONE") t nil 0)
  (gtk-box-pack-start box (gtk-label-new "TWO") t t 0)
  ... )
    </programlisting>
    <para>
     This can be done with &gtk-grid; as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child1 (make-instance 'gtk-label
                             :label "ONE"
                             :hexpand t
                             :halign :center))
      (child2 (make-instance 'gtk-label
                             :label "TWO"
                             :hexpand t
                             :halign :fill))
  (gtk-grid-attach grid child1 0 0 1 1)
  (gtk-grid-attach-next-to grid child2 child1 :right 1 1)
  ... )
    </programlisting>
    <para>
     One difference between the new &gtk-widget; expand properties and the &gtk-box; child property of the
     same name is that widget expandability is 'inherited' from children. What this means is that a container
     will become itself expanding as soon as it has an expanding child. This is typically what you want, it
     lets you e.g. mark the content pane of your application window as expanding, and all the intermediate
     containers between the content pane and the toplevel window will automatically do the right thing. This
     automatism can be overridden at any point by setting the expand flags on a container explicitly.
    </para>
    <para>
     Another difference between &gtk-box; and &gtk-grid; with respect to expandability is when there are no
     expanding children at all. In this case, &gtk-box; will forcibly expand all children whereas &gtk-grid;
     will not. In practice, the effect of this is typically that a grid will 'stick to the corner' when the
     toplevel containing it is grown, instead of spreading out its children over the entire area. The problem
     can be fixed by setting some or all of the children to expand.
    </para>
    <para>
     When you set the &gtk_box_homogeneous; property on a &gtk-box;, it reserves the same space for all its
     children. &gtk-grid; does this in a very similar way, with &gtk_grid_row-homogeneous; and
     &gtk_grid_column-homogeneous; properties which control whether all rows have the same height and whether
     all columns have the same width.
    </para>
   </section>

   <section id="GtkBox_versus_GtkGrid_spacing">
    <title>GtkBox versus GtkGrid - spacing</title>
    <para>
     With &gtk-box;, you have to specify the "spacing" when you construct it. This property specifies the
     space that separates the children from each other. Additionally, you can specify extra space to put
     around each child individually, using the <code>padding</code> child property.
    </para>
    <para>
     &gtk-grid; is very similar when it comes to spacing between the children, except that it has two separate
     properties, &gtk_grid_row-spacing; and &gtk_grid_column-spacing;, for the space to leave between rows and
     columns. Note that &gtk_grid_row-spacing; is the space between rows, not inside a row. So, if you doing
     a horizontal layout, you need to set &gtk_grid_column-spacing;.
    </para>
    <para>
     &gtk-grid; does not have any custom child properties to specify per-child padding; instead you can use
     the &gtk_widget_margin; property. You can also set different padding on each side with the
     &gtk_widget_margin-start;, &gtk_widget_margin-end;, &gtk_widget_margin-top; and
     &gtk_widget_margin-bottom; properties.
    </para>
    <para>
     Example with spacing in boxes:
    </para>
    <programlisting>
(let ((box (gtk-box-new :vertical 6))
      (child (gtk-label-new "Child")))
  (gtk-box-pack-start box child nil nil 12)
  ... )
    </programlisting>
    <para>
     This can be done with &gtk-grid; as follows:
    </para>
    <programlisting>
(let ((grid (gtk-grid-new))
      (child (make-instance 'gtk-label
                            :label "Child"
                            :margin 12)))
  (gtk-grid-attach box child 0 0 1 1)
  ... )
    </programlisting>
   </section>
  </section>

  <section id="Grid_Packing_Examples">
   <title>Grid Packing Examples</title>
   <para>
    We repeat the implementation of the example <link linkend="example-box-packing">Box Packing</link> and
    the example <link linkend="example-table-packing">Table Packing</link> using <code>GtkGrid</code>. The
    first example <link linkend="example-grid-packing">Grid Packing</link> shows how to replace
    &gtk-box; with &gtk-grid; to create vertical and horizontal boxes. In the second example
    <link linkend="example-grid-packing-2">Grid Packing</link> &gtk-table; is replaced with &gtk-grid;.
    See the figures <link linkend="figure-box-packing">Box Packing</link> and
    <link linkend="figure-table-packing">Table Packing</link> for the output of the example programs.
   </para>
   <example id="example-grid-packing">
    <title>Box Packing using GtkGrid</title>
    <programlisting>
(defun make-grid (homogeneous spacing expand align margin)
  (let ((box (make-instance 'gtk-grid
                            :orientation :horizontal
                            :column-homogeneous homogeneous
                            :column-spacing spacing)))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label "gtk-container-add"
                                      :hexpand expand
                                      :halgin align
                                      :margin margin))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label "box"
                                      :hexpand expand
                                      :halign align
                                      :margin margin))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label "button"
                                      :hexpand expand
                                      :halign align
                                      :margin margin))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label (if expand "T" "NIL")
                                      :hexpand expand
                                      :halign align
                                      :margin margin))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label (format nil "&#x7e;A" align)
                                      :hexpand expand
                                      :halign align
                                      :margin margin))
    (gtk-container-add box
                       (make-instance 'gtk-button
                                      :label (format nil "&#x7e;A" margin)
                                      :hexpand expand
                                      :halign align
                                      :margin margin))
    box))

(defun example-grid-packing (&#x26;optional (spacing 0))
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Grid Packing"
                                 :type :toplevel
                                 :border-width 12
                                 :default-height 200
                                 :default-width 300))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical
                               :row-spacing 6))
          (button (make-instance 'gtk-button
                                 :label "Quit"))
          (quitbox (make-instance 'gtk-box
                                  :orientation :horizontal)))
      (g-signal-connect button "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add vbox
                         (make-instance 'gtk-label
                                        :label
                                        (format nil
                                         "GtkGrid homogeneous nil spacing ~A"
                                         spacing)
                                        :xalign 0
                                        :yalign 0
                                        :vexpand nil
                                        :valign :start))
      (gtk-container-add vbox (gtk-separator-new :horizontal))
      (gtk-container-add vbox (make-grid nil spacing nil :center 0))
      (gtk-container-add vbox (make-grid nil spacing t :center 0))
      (gtk-container-add vbox (make-grid nil spacing t :fill 0))
      (gtk-container-add vbox (gtk-separator-new :horizontal))
      (gtk-container-add vbox
                         (make-instance 'gtk-label
                                        :label
                                        (format nil
                                           "GtkGrid homogeneous t spacing ~A"
                                           spacing)
                                         :xalign 0
                                         :yalign 0
                                         :vexpand nil
                                         :valign :start
                                         :margin 6))
      (gtk-container-add vbox (gtk-separator-new :horizontal))
      (gtk-container-add vbox (make-grid t spacing t :center 0))
      (gtk-container-add vbox (make-grid t spacing t :fill 0))
      (gtk-container-add vbox (gtk-separator-new :horizontal))
      (gtk-container-add quitbox button)
      (gtk-container-add vbox quitbox)
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <example id="example-grid-packing-2">
    <title>Table Packing using GtkGrid</title>
    <programlisting>
(defun example-grid-packing-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Grid Packing"
                                 :border-width 12
                                 :default-width 300))
          (grid (make-instance 'gtk-grid
                                :column-homogeneous t
                                :row-homogeneous t))
          (button1 (make-instance 'gtk-button
                                  :label "Button 1"))
          (button2 (make-instance 'gtk-button
                                  :label "Button 2"))
          (quit (make-instance 'gtk-button
                               :label "Quit")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect quit "clicked"
                        (lambda (widget)
                          (declare (ignore widget))
                          (gtk-widget-destroy window)))
      (gtk-grid-attach grid button1 0 1 1 1)
      (gtk-grid-attach grid button2 1 1 1 1)
      (gtk-grid-attach grid quit    0 2 2 1)
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Button_Widgets">
  <title>Button Widgets</title>
  <section id="Normal_Buttons">
   <title>Normal Buttons</title>
   <para>
    We have almost seen all there is to see of the button widget, which is represented by the &gtk-button;
    class. The button widget is pretty simple. There is however more than one way to create a button. You can
    use the the function &gtk-button-new-with-label; or the function &gtk-button-new-with-mnemonic; to create
    a button with a label, use the function &gtk-button-new-from-icon-name; to create a button containing the
    image from the current icon theme or use the function &gtk-button-new; to create a blank button. It is
    then up to you to pack a label or pixmap into this new button. To do this, create a new box, and then
    pack your objects into this box using the function &gtk-box-pack-start;, and then use the function
    &gtk-container-add; to pack the box into the button.
   </para>
   <figure id="figure-button">
    <title>Button with an image from a file</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/button158x90.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The figure <link linkend="figure-button">Button</link> shows an example of using the function
    &gtk-button-new; to create a button with an image and a label in it. The image is loaded from a file with
    the function &gtk-image-new-from-file;. The code to create a box is shown in the example
    <link linkend="example-image-label-box">Image Label Box</link> and breaken up from the rest so you can
    use it in your programs. The main program which uses this subroutine is shown in the example
    <link linkend="example-button">Button</link>.
   </para>
   <para>
    The function <code>image-label-box</code> could be used to pack images and labels into any widget that
    can be a container.
   </para>
   <example id="example-button">
    <title>Button with an image and a label</title>
    <programlisting>
(defun example-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Cool Button"
                                 :type :toplevel
                                 :border-width 12))
          (button (make-instance 'gtk-button))
          (box (image-label-box "save.png" "Save to File")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add button box)
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <example id="example-image-label-box">
    <title>Code to create a button with an image and a label</title>
    <programlisting>
(defun image-label-box (filename text)
  (let ((box (make-instance 'gtk-box
                            :orientation :horizontal
                            :border-width 3))
        (label (make-instance 'gtk-label
                              :label text))
        (image (gtk-image-new-from-file filename)))
    (gtk-box-pack-start box image :expand nil :fill nil :padding 3)
    (gtk-box-pack-start box label :expand nil :fill nil :padding 3)
    box))
     </programlisting>
   <para>
    The figure <link linkend="figure-more-buttons">Buttons</link> shows more buttons, which are created with
    standard functions and with the function <code>make-instance</code>. The buttons created with the function
    <code>make-instance</code> show both a label and an image. The images are created with the function
    <code>make-instance</code> from the current icon theme by setting the &gtk_image_icon-name; property to
    the icon name of the image. More about the &gtk-image; class follows in section
    <link linkend="Images">Images</link>. To show the images, the &gtk_button_always-show-image; property must
    be set to the value <code>T</code>. This is done in the call to the function <code>make-instance</code>.
    The code of the figure <link linkend="figure-more-buttons">Buttons</link> is shown in example
    <link linkend="example-more-buttons">Buttons</link>.
   </para>
   </example>
   <figure id="figure-more-buttons">
    <title>More Examples to create buttons</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/buttons256x185.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-more-buttons">
    <title>More buttons</title>
    <programlisting>
(defun example-more-buttons ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Buttons"
                                 :type :toplevel
                                 :default-width 250
                                 :border-width 12))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :spacing 6))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :spacing 6))
          (hbox  (make-instance 'gtk-box
                                :orientation :horizontal
                                :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; These are the standard functions to create a button.
      (gtk-box-pack-start vbox1
                          (gtk-button-new-with-label "Label"))
      (gtk-box-pack-start vbox1
                          (gtk-button-new-with-mnemonic "_Mnemonic"))
      (gtk-box-pack-start vbox1
                          (gtk-button-new-from-icon-name "gtk-apply" :button))
      ;; Create some buttons with make-instance.
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-button
                                         :image-position :left
                                         :always-show-image t
                                         :image
                                         (make-instance 'gtk-image
                                                        :icon-name "gtk-edit")
                                         :label "Bearbeiten"))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-button
                                         :image-position :top
                                         :always-show-image t
                                         :image
                                         (make-instance 'gtk-image
                                                        :icon-name "gtk-cut")
                                         :label "Ausschneiden"))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-button
                                         :image-position :bottom
                                         :always-show-image t
                                         :image
                                         (make-instance 'gtk-image
                                                        :icon-name "gtk-cancel")
                                         :label "Abbrechen"))
      (gtk-box-pack-start hbox vbox1)
      (gtk-box-pack-start hbox vbox2)
      (gtk-container-add window hbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Toggle_Buttons">
   <title>Toggle Buttons</title>
   <para>
    Toggle buttons are derived from normal buttons and are very similar, except toggle buttons always are in
    one of two states, alternated by a click. Toggle buttons can be depressed, and when clicked again, the
    toggle button will pop back up. Toggle buttons are the basis for check buttons and radio buttons, as
    such, many of the calls used for toggle buttons are inherited by radio and check buttons.
   </para>
   <para>
    Beside <code>make-instance</code>, toggle buttons can be created with the functions
    &gtk-toggle-button-new;, &gtk-toggle-button-new-with-label;, and &gtk-toggle-button-new-with-mnemonic;.
    The first function creates a blank toggle button, and the last two functions, a toggle button with a
    label widget already packed into it. The &gtk-toggle-button-new-with-mnemonic; variant additionally
    parses the label for '_'-prefixed mnemonic characters.
   </para>
   <para>
    To retrieve the state of the toggle widget, including radio and check buttons, a construct as shown in
    the example below is used. This tests the state of the toggle button, by accessing the active field of
    the toggle widget's structure with the function &gtk-toggle-button-active;. The signal of interest to us
    emitted by toggle buttons (the toggle button check button, and radio button widgets) is the "toggled"
    signal. To check the state of these buttons, set up a signal handler to catch the toggled signal, and
    access the property &gtk_toggle_button_active; to determine the state of the button. A signal handler
    will look something like:
   </para>
   <programlisting>
(g-signal-connect button "toggled"
   (lambda (widget)
     (if (gtk-toggle-button-active widget)
         (progn
           ;; If control reaches here, the toggle button is down
         )
        (progn
           ;; If control reaches here, the toggle button is up
         ))))
   </programlisting>
   <para>
    To force the state of a toggle button, and its children, the radio and check buttons, use this function
    &gtk-toggle-button-active;. This function can be used to set the state of the toggle button, and its
    children the radio and check buttons. Passing in your created button as the first argument, and a
    <code>T</code> or <code>NIL</code> for the second state argument to specify whether it should be down
    (depressed) or up (released). Default is up, or <code>NIL</code>.
   </para>
   <para>
    Note that when you use the &gtk-toggle-button-active; function, and the state is actually changed, it
    causes the "clicked" and "toggled" signals to be emitted from the button. The current state of the toggle
    button as a boolean <code>T</code> or <code>NIL</code> value is returned from the slot access function
    &gtk-toggle-button-active;.
   </para>
   <para>
    In example <link linkend="example-table-packing-2">Table Packing</link> the usage of toggle buttons is
    shown.
   </para>
  </section>

  <section id="Check_Buttons">
   <title>Check Buttons</title>
   <para>
    Check buttons are implemented as the class &gtk-check-button; and inherit many properties and functions
    from the toggle buttons above, but look a little different. Rather than being buttons with text inside
    them, they are small squares with the text to the right of them. These are often used for toggling
    options on and off in applications.
   </para>
   <para>
    The creation functions are similar to those of the normal button: &gtk-check-button-new;,
    &gtk-check-button-new-with-label;, &gtk-check-button-new-with-mnemonic;. The
    &gtk-check-button-new-with-label; function creates a check button with a label beside it.
   </para>
   <para>
    Checking the state of the check button is identical to that of the toggle button. The figure
    <link linkend="figure-toggle-buttons">Toggle Buttons</link> shows toggle buttons and the example
    <link linkend="example-toggle-buttons">Toggle Buttons</link> the code to create toggle buttons.
   </para>
  </section>

  <section id="Radio_Buttons">
   <title>Radio Buttons</title>
   <para>
    Radio buttons are similar to check buttons except they are grouped so that only one may be selected or
    depressed at a time. This is good for places in your application where you need to select from a short
    list of options.
   </para>
   <para>
    Creating a new radio button is done with one of these calls: &gtk-radio-button-new;,
    &gtk-radio-button-new-with-label;, and &gtk-radio-button-new-with-mnemonic;. These functions take a list
    of radio buttons as the first argument or <code>NIL</code>. When <code>NIL</code> a new list of radio
    buttons is created. The newly created list for the radio buttons can be get with the function
    &gtk-radio-button-get-group;. More radio buttons can then be added to this list. The important thing to
    remember is that &gtk-radio-button-get-group; must be called for each new button added to the group, with
    the previous button passed in as an argument. The result is then passed into the next call to
    &gtk-radio-button-new; or the other two functions for creating a radio button. This allows a chain of
    buttons to be established. The example <link linkend="example-toggle-buttons">Toggle Buttons</link>
    creates a radio button group with three buttons.
   </para>
   <para>
    You can shorten this slightly by using the following syntax, which removes the need for a variable to
    hold the list of buttons:
   </para>
   <programlisting>
(setq button
      (gtk-radio-button-new-with-label (gtk-radio-button-get-group button)
                                       "Button"))
   </programlisting>
   <para>
    Each of these functions has a variant, which take a radio button as the first argument and allows to omit
    the &gtk-radio-button-get-group; call. In this case the new radio button is added to the list of radio
    buttons the argument is already a part of. These functions are: &gtk-radio-button-new-from-widget;,
    &gtk-radio-button-new-with-label-from-widget;, and &gtk-radio-button-new-with-mnemonic-from-widget;.
   </para>
   <figure id="figure-toggle-buttons">
    <title>Toggle Buttons</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/toggle-buttons305x201.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    It is also a good idea to explicitly set which button should be the default depressed button with the
    function &gtk-toggle-button-active;. This is described in the section on toggle buttons, and works in
    exactly the same way. Once the radio buttons are grouped together, only one of the group may be active at
    a time. If the user clicks on one radio button, and then on another, the first radio button will first
    emit a "toggled" signal (to report becoming inactive), and then the second will emit its "toggled" signal
    (to report becoming active).
   </para>
   <example id="example-toggle-buttons">
    <title>Radio and Toggle Buttons</title>
    <programlisting>
(defun example-toggle-buttons ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Toggle Buttons"
                                 :type :toplevel))
          (vbox (make-instance 'gtk-box
                               :orientation :vertical))
          (hbox (make-instance 'gtk-box
                               :orientation :horizontal)))
      ;; Handler for the signal "destroy"
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Create three radio buttons and put the buttons in a vbox
      (let ((vbox (make-instance 'gtk-box
                                 :orientation :vertical
                                 :spacing 12
                                 :border-width 12))
            (button (gtk-radio-button-new-with-label nil "Radio Button 1")))
        (gtk-box-pack-start vbox button)
        (setq button
              (gtk-radio-button-new-with-label
                                          (gtk-radio-button-get-group button)
                                          "Radio Button 2"))
        (setf (gtk-toggle-button-active button) t)
        (gtk-box-pack-start vbox button)
        (setq button
              (gtk-radio-button-new-with-mnemonic
                                          (gtk-radio-button-get-group button)
                                          "_Radio Button 3"))
        (gtk-box-pack-start vbox button)
        ;; Put the vbox with the radio buttons in a hbox
        (gtk-box-pack-start hbox vbox :expand nil :fill nil))
      ;; Create three check buttons and put the buttons in a vbox
      (let ((vbox (make-instance 'gtk-box
                                 :orientation :vertical
                                 :homogeneous nil
                                 :spacing 12
                                 :border-width 12)))
        (gtk-box-pack-start
                          vbox
                          (gtk-check-button-new-with-label "Check Button 1"))
        (gtk-box-pack-start
                          vbox
                          (gtk-check-button-new-with-label "Check Button 2"))
        (gtk-box-pack-start
                          vbox
                          (gtk-check-button-new-with-label "Check Button 3"))
        ;; Put the vbox with the buttons in a hbox
        (gtk-box-pack-start hbox vbox :expand nil :fill nil))
      ;; Put the hbox in a vbox
      (gtk-box-pack-start vbox hbox :expand nil :fill nil)
      ;; Add a separator to the vbox
      (gtk-box-pack-start vbox
                          (make-instance 'gtk-separator
                                         :orientation :horizontal)
                          :expand nil :fill nil)
      ;; Add a quit button to the vbox
      (let ((vbox-quit (make-instance 'gtk-box
                                      :orientation :vertical
                                      :spacing 12
                                      :border-width 12))
            (button (make-instance 'gtk-button :label "Close")))
        (gtk-box-pack-start vbox-quit button :expand nil :fill nil)
        (gtk-box-pack-start vbox vbox-quit :expand nil)
        (g-signal-connect button "clicked"
                          (lambda (button)
                            (declare (ignore button))
                            (gtk-widget-destroy window))))
      ;; Put the vbox in the window widget
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Link_Buttons">
   <title>Link Buttons</title>
   <figure id="figure-link-button">
    <title>Link Buttons</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/link-button272x159.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    A &gtk-link-button; is a &gtk-button; with a hyperlink, similar to the one used by web browsers, which
    triggers an action when clicked. It is useful to show quick links to resources.
   </para>
   <para>
    A link button is created by calling either the functions &gtk-link-button-new; or
    &gtk-link-button-new-with-label;. If using the former, the URI you pass to the constructor is used as a
    label for the widget.
   </para>
   <para>
    The URI bound to a &gtk-link-button; can be set specifically or retrieved using the slot access function
    &gtk-link-button-uri;.
   </para>
   <para>
    By default, &gtk-link-button; calls &gtk-show-uri; when the button is clicked. This behaviour can be
    overridden by connecting to the "activate-link" signal and returning <code>T</code> from the signal
    handler.
   </para>
   <para>
    The figure <link linkend="figure-link-button">Link Button</link> shows two different styles of link
    buttons. The code is shown in example <link linkend="example-link-button">Link Button</link>.
   </para>
   <example id="example-link-button">
    <title>Link Buttons</title>
    <programlisting>
(defun example-link-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Link Button"
                                 :default-width 270
                                 :border-width 12))
          (grid (make-instance 'gtk-grid
                               :orientation :vertical
                               :row-spacing 6
                               :column-homogeneous t)))
      (g-signal-connect window "destroy"
                               (lambda (widget)
                                 (declare (ignore widget))
                                 (leave-gtk-main)))
      (gtk-container-add grid
                         (make-instance 'gtk-label
                                        :use-markup t
                                        :label
                                        "&#x3c;b&#x3e;Link Button with url&#x3c;/b&#x3e;"))
      (gtk-container-add grid
                         (gtk-link-button-new "http://www.gtk.org/"))
      (gtk-container-add grid
                         (make-instance 'gtk-label
                                        :use-markup t
                                        :label
                                        "&#x3c;b&#x3e;Link Button with Label&#x3c;/b&#x3e;"))
      (gtk-container-add grid
                         (gtk-link-button-new-with-label
                                                        "http://www.gtk.org/"
                                                        "Project WebSite"))
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Switches">
   <title>Switches</title>
    <figure id="figure-switch">
     <title>Switch</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/switch232x100.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
   </figure>
   <para>
    &gtk-switch; is a widget that has two states: on or off. The user can control which state should be
    active by clicking the empty area, or by dragging the handle. The switch is created with the function
    &gtk-switch-new; or the call <code>(make-instance 'gtk-switch)</code>.
   </para>
   <para>
    &gtk-switch; has the property &gtk_switch_active;, which can be set or retrieved with the slot access
    function &gtk-switch-active;.
   </para>
   <para>
    An example of a switch is shown in figure <link linkend="figure-switch">Switch</link>. The code is
    shown in example <link linkend="example-switch">Switch</link>. Note that in the example the signal
    "notify::active" is connected to the switch to display a label with the state of the switch.
   </para>
   <example id="example-switch">
    <title>Switch</title>
    <programlisting>
(defun example-switch ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Switch"
                                 :default-width 230
                                 :border-width 12))
          (switch (make-instance 'gtk-switch
                                 :active t))
          (label (make-instance 'gtk-label
                                :label "The Switch is ON"))
          (grid (make-instance 'gtk-grid
                               :orientation :vertical
                               :row-spacing 6
                               :column-homogeneous t)))
      (g-signal-connect window "destroy"
                               (lambda (widget)
                                 (declare (ignore widget))
                                 (leave-gtk-main)))
      (g-signal-connect switch "notify::active"
         (lambda (widget param)
           (declare (ignore param))
           (if (gtk-switch-active widget)
               (setf (gtk-label-label label) "The Switch is ON")
               (setf (gtk-label-label label) "The Switch is OFF"))))
      (gtk-container-add grid switch)
      (gtk-container-add grid label)
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Display_Widgets">
  <title>Display Widgets</title>
  <section id="Labels">
   <sectioninfo>
    <itermset>
     <indexterm zone="Labels"><primary>GtkLabel</primary></indexterm>
     <indexterm zone="Labels"><primary>label, gtk-label</primary></indexterm>
     <indexterm zone="Labels"><primary>label-new, gtk-label-new</primary></indexterm>
     <indexterm zone="Labels"><primary>label-new-with-mnemonic, gtk-label-new-with-mnemonic</primary></indexterm>
     <indexterm zone="Labels"><primary>label-text, gtk-label-text</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Labels</title>
   <para>
    Labels are used a lot in GTK+, and are relatively simple. The &gtk-label; widget displays a small amount
    of text.  As the name implies, most labels
    are used to label another widget such as a &gtk-button;, a
    <ulink url="&gtk-menu-item;"><code>gtk-menu-item</code></ulink>, or a <ulink url="&gtk-combo-box;">
    <code>gtk-combo-box</code></ulink>.  Labels emit no signals as they do not have an associated X window.
    If you need to catch signals, or do clipping, place it inside a <ulink url="&gtk-event-box;">
    <code>gtk-event-box</code></ulink> widget or a button widget.
   </para>
   <para>
    To create a new label, use <code>make-instance</code> with the class name &gtk-label; or the functions
    <ulink url="&gtk-label-new;">
    <code>gtk-label-new</code></ulink> or <ulink url="&gtk-label-new-with-mnemonic;">
    <code>gtk-label-new-with-mnemonic</code></ulink>.  The sole argument of the functions is the string you
    wish the label to display.  To change the text of the label after creation, use the function
    <ulink url="&gtk-label-text;"><code>gtk-label-text</code></ulink>.  The first argument is the label you
    created previously, and the second is the new string.  The space needed for the new string will be
    automatically adjusted if needed.  You can produce multi-line labels by putting line breaks in the label
    string.  To retrieve the current string, use <ulink url="&gtk-label-text;">
    <code>gtk-label-text</code></ulink>.
   </para>
   <figure id="figure-labels">
    <title>Labels</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/labels507x440.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <section id="Label_with_Mnemonics">
    <sectioninfo>
     <itermset>
      <indexterm zone="Label_with_Mnemonics"><primary>label-new-with-mnemonic, gtk-label-new-with-mnemonic</primary></indexterm>
      <indexterm zone="Label_with_Mnemonics"><primary>label-set-text-with-mnemonic, gtk-label-set-text-with-mnemonic</primary></indexterm>
      <indexterm zone="Label_with_Mnemonics"><primary>label-mnemonic-widget, gtk-label-mnemonic-widget</primary></indexterm>
     </itermset>
    </sectioninfo>
    <title>Label with Mnemonics</title>
    <para>
     Labels may contain mnemonics.  Mnemonics are underlined characters in the label, used for keyboard
     navigation.  Mnemonics are created by providing a string with an underscore before the mnemonic
     character, such as "_File", to the functions <ulink url="&gtk-label-new-with-mnemonic;">
     <code>gtk-label-new-with-mnemonic</code></ulink> or <ulink url="&gtk-label-set-text-with-mnemonic;">
     <code>gtk-label-set-text-with-mnemonic</code></ulink>.
    </para>
    <para>
     Mnemonics automatically activate any activatable widget the label is inside, such as a
     &gtk-button;; if the label is not inside the mnemonic's
     target widget, you have to tell the label about the target using
     <ulink url="&gtk-label-mnemonic-widget;"><code>gtk-label-mnemonic-widget</code></ulink>.
    </para>
    <para>
     Here is a simple example where the label is inside a button:
    </para> 
    <programlisting>
;; Pressing Alt+H will activate this button
(let* ((button (gtk-button-new))
       (label (gtk-label-new-with-mnemonic "_Hello")))
  (gtk-container-add button label)
  [...] )
    </programlisting>
    <para>
     There is a convenience function to create buttons with a mnemonic label already inside:
    </para>
    <programlisting>
;; Pressing Alt+H will activate this button
(let ((button (gtk-button-new-with-mnemonic "_Hello")))
  [...] )
    </programlisting>
    <para>
     To create a mnemonic for a widget alongside the label, such as a <ulink url="&gtk-entry;">
     <code>gtk-entry</code></ulink>, you have to point the label at the entry with
     <ulink url="&gtk-label-mnemonic-widget;"><code>gtk-label-mnemonic-widget</code></ulink>:
    </para>
    <programlisting>
;; Pressing Alt+H will focus the entry
(let* ((entry (gtk-entry-new))
       (label (gtk-label-new-with-mnemonic "_Hello")))
  (gtk-label-mnemonic-widget label entry)
  [...] )
    </programlisting>
   </section>

   <section id="Markup">
    <sectioninfo>
     <itermset>
      <indexterm zone="Markup"><primary>label-set-markup, gtk-label-set-markup</primary></indexterm>
      <indexterm zone="Markup"><primary>label-attributes, gtk-label-attributes</primary></indexterm>
     </itermset>
    </sectioninfo>
    <title>Markup (styled text)</title>
    <para>
     To make it easy to format text in a label (changing colors, fonts, etc.), label text can be provided in
     a simple markup format.  Here's how to create a label with a small font:
    </para>
    <programlisting>
(let ((label (gtk-label-new)))
  (gtk-label-set-markup label
                        "&#x3C;small>Small text&#x3C;/small>")
  [...] )
    </programlisting>
    <para>
     or
    </para>
    <programlisting>
(let ((label (make-instance 'gtk-label
                            :use-markup t
                            :label "&#x3C;small>Small text&#x3C;/small>")))
  [...] )
    </programlisting>
    <para>
     (See complete documentation of available tags in the Pango manual.)
    </para>
    <para>
     The markup passed to <ulink url="&gtk-label-set-markup;"><code>gtk-label-set-markup</code></ulink> must
     be valid; for example, literal &#x3C;, > and &#x26; characters must be escaped as \&#x3C;, \gt;, and
     \&#x26;.  If you pass text obtained from the user, file, or a network to
     <ulink url="&gtk-label-set-markup;"><code>gtk-label-set-markup</code></ulink>, you will want to escape
     it with <code>g_markup_escape_text ()</code> or <code>g_markup_printf_escaped ()</code>.  (Note: The
     functions <code>g_markup_escape_text ()</code> and <code>g_markup_printf_escaped ()</code> are not
     implemented in the Lisp binding.)
    </para>
    <para>
     Markup strings are just a convenient way to set the <ulink url="&pango-attr-list;">
     <code>pango-attr-list</code></ulink> on a label; <ulink url="&gtk-label-attributes;">
     <code>gtk-label-attributes</code></ulink> may be a simpler way to set attributes in some cases.  Be
     careful though; <ulink url="&pango-attr-list;"><code>pango-attr-list</code></ulink> tends to cause
     internationalization problems, unless you're applying attributes to the entire string (i.e. unless you
     set the range of each attribute to <code>[0, G_MAXINT)</code>).  The reason is that specifying the
     <code>start_index</code> and <code>end_index</code> for a <code>PangoAttribute</code> requires knowledge
     of the exact string being displayed, so translations will cause problems.
    </para>
   </section>

   <section id="Selectable_Labels">
    <sectioninfo>
     <itermset>
      <indexterm zone="Selectable_Labels"><primary>label-selectable, gtk-label-selectable</primary></indexterm>
     </itermset>
    </sectioninfo>
    <title>Selectable Labels</title>
    <para>
     Labels can be made selectable with <ulink url="&gtk-label-selectable;">
     <code>gtk-label-selectable</code></ulink>.  Selectable labels allow the user to copy the label contents
     to the clipboard.  Only labels that contain useful-to-copy information - such as error messages - should
     be made selectable.
    </para>
   </section>

   <section id="Text_Layout">
    <sectioninfo>
     <itermset>
      <indexterm zone="Text_Layout"><primary>GtkJustification</primary></indexterm>
      <indexterm zone="Text_Layout"><primary>justification, gtk-justification</primary></indexterm>
      <indexterm zone="Text_Layout"><primary>label-justify, gtk-label-justify</primary></indexterm>
      <indexterm zone="Text_Layout"><primary>label-pattern, gtk-label-pattern</primary></indexterm>
      <indexterm zone="Text_Layout"><primary>label-line-wrap, gtk-label-line-wrap</primary></indexterm>
     </itermset>
    </sectioninfo>
    <title>Text Layout</title>
    <para>
     A label can contain any number of paragraphs, but will have performance problems if it contains more
     than a small number.  Paragraphs are separated by newlines or other paragraph separators understood by
     Pango.
    </para>
    <para>
     The label widget is capable of line wrapping the text automatically.  This can be activated using the
     function <ulink url="&gtk-label-line-wrap;"><code>gtk-label-line-wrap</code></ulink>.  The first 
     argument is the label and the second argument take <code>T</code> or <code>NIL</code> to switch on or 
     to switch off the line wrapping.
    </para>
    <para>
     <ulink url="&gtk-label-justify;"><code>gtk-label-justify</code></ulink> sets how the lines in a label
     align with one another.  The first argument is the label and the second argument one of the following
     values of the enumeration type <ulink url="&gtk-justification;"><code>gtk-justification</code></ulink>. 
     The possible values are shown in table <link linkend="table-gtk-justification">Justification</link>. 
     If you want to set how the label as a whole aligns in its available space, see the function
     <ulink url="&gtk-misc-set-alignment;"><code>gtk-misc-set-alignment</code></ulink>.
    </para>
    <table id="table-gtk-justification" frame="all">
     <title>Values of the GtkJustification enumeration</title>
     <tgroup cols='2' align='left' colsep='0' rowsep='0'>
      <thead>
       <row>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry valign="top"><code>:left</code></entry>
        <entry valign="top">
         The text is placed at the left edge of the label.
        </entry>
       </row>
       <row>
        <entry valign="top"><code>:right</code></entry>
        <entry valign="top">
         The text is placed at the right edge of the label.
        </entry>
       </row>
       <row>
        <entry valign="top"><code>:center</code></entry>
        <entry valign="top">
         The text is placed in the center of the label.
        </entry>
       </row>
       <row>
        <entry valign="top"><code>:fill</code></entry>
        <entry valign="top">
         The text is placed is distributed across the label.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <para>
     The <ulink url="&gtk_label_width-chars;"><code>width-chars</code></ulink> and
     <ulink url="&gtk_label_max-width-chars;"><code>max-width-chars</code></ulink> properties can be used to
     control the size allocation of ellipsized or wrapped labels.  For ellipsizing labels, if either is
     specified (and less than the actual text size), it is used as the minimum width, and the actual text
     size is used as the natural width of the label.  For wrapping labels,
     <ulink url="&gtk_label_width-chars;"><code>width-chars</code></ulink> is used as the minimum width, if
     specified, and <ulink url="&gtk_label_max-width-chars;"><code>max-width-chars</code></ulink> is used as
     the natural width.  Even if <ulink url="&gtk_label_max-width-chars;">
     <code>max-width-chars</code></ulink> specified, wrapping labels will be rewrapped to use all of the
     available width.
    </para>
    <para>
     If you want your label underlined, then you can set a pattern on the label with the function
     <ulink url="&gtk-label-pattern;"><code>gtk-label-pattern</code></ulink>.  The pattern argument indicates
     how the underlining should look.  It consists of a string of underscore and space characters.  An 
     underscore indicates that the corresponding character in the label should be underlined.  For example, 
     the string "__ __" would underline the first two characters and eight and ninth characters.
    </para>
   </section>

   <section id="Links">
    <sectioninfo>
     <itermset>
      <indexterm zone="Links"><primary>label-current-uri, gtk-label-current-uri</primary></indexterm>
     </itermset>
    </sectioninfo>
    <title>Links</title>
    <para>
     GTK+ supports markup for clickable hyperlinks in addition to regular Pango markup.  The markup for links
     is borrowed from HTML, using the a with href and title attributes.  GTK+ renders links similar to the
     way they appear in web browsers, with colored, underlined text.  The title attribute is displayed as a
     tooltip on the link.  An example looks like this:
    </para>
    <programlisting>
(gtk-label-set-markup label
  "Go to the &#x3C;a href=\"http://gtk.org/\"> GTK+ Website&#x3C;/a> for more ...")))
    </programlisting>
    <para>
     It is possible to implement custom handling for links and their tooltips with the
     <code>activate-link</code> signal and the <ulink url="&gtk-label-current-uri;">
     <code>gtk-label-current-uri</code></ulink> function.
    </para>
   </section>

   <section id="GtkLabel as GtkBuildable">
    <title>GtkLabel as GtkBuildable</title>
    <para>
     The &gtk-label; implementation of the
     <ulink url="&gtk-buildable;"><code>gtk-buildable</code></ulink> interface supports a custom
     <code>&#x3C;attributes></code> element, which supports any number of <code>&#x3C;attribute></code> 
     elements.  The <code>&#x3C;attribute></code> element has attributes named <code>name</code>,
     <code>value</code>, <code>start</code> and <code>end</code> and allows you to specify
     <code>PangoAttribute</code> values for this label.
    </para>
    <example id="example-label-uri">
     <title>A UI definition fragment specifying Pango attributes</title>
     <programlisting>
&#x3C;object class="GtkLabel">
  &#x3C;attributes>
    &#x3C;attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
    &#x3C;attribute name="background" value="red" start="5" end="10"/>"
  &#x3C;/attributes>
&#x3C;/object>
     </programlisting>
    </example>
    <para>
     The <code>start</code> and <code>end</code> attributes specify the range of characters to which the 
     Pango attribute applies.  If <code>start</code> and <code>end</code> are not specified, the attribute
     is applied to the whole text.  Note that specifying ranges does not make much sense with translatable   
     attributes.  Use markup embedded in the translatable content instead.
    </para>
   </section>

   <section id="Examples">
    <title>Examples</title>
    <para>
     The figures <link linkend="figure-labels">Labels</link> and <link linkend="figure-more-labels">
     More Labels</link> illustrate the functions for <code>GtkLabel</code>.  The code for these examples is
     shown in examples <link linkend="example-labels">Labels</link> and <link linkend="example-more-labels">
     More Labels</link>.
    </para>
    <example id="example-labels">
     <title>Labels</title>
     <programlisting>
(defun make-heading (text)
  (make-instance 'gtk-label
                 :xalign 0
                 :use-markup t
                 :label (format nil "&#x3C;b>~A&#x3C;/b>" text)))

(defun example-labels ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "GTK+ 3.4 Example Labels"
                                 :default-width 250
                                 :border-width 12))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :spacing 6))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :spacing 6))
          (hbox (make-instance 'gtk-box
                               :orientation :horizontal
                               :spacing 12)))
      ;; Connect a handler for the signal "destroy" to window.
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Create a Normal Label
      (gtk-box-pack-start vbox1
                          (make-heading "Normal Label:")
                          :expand nil)
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :label "This is a Normal Label")
                          :expand nil)
      ;; Create a Multi-line Label
      (gtk-box-pack-start vbox1
                          (make-heading "Multi-line Label:")
                          :expand nil)
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :label
                                         (format nil
                                               "This is a Multi-line label~%~
                                                Second line~%~
                                                Third line"))
                          :expand nil)
      ;; Create a Left Justified Label
      (gtk-box-pack-start vbox1
                          (make-heading "Left Justified Label:")
                          :expand nil)
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :justify :left
                                         :label
                                         (format nil
                                                 "This is a Left Justified~%~
                                                  Multi-line label~%~
                                                  Third line"))
                          :expand nil)
      ;; Create a Right Justified Label
      (gtk-box-pack-start vbox1
                          (make-heading "Right Justified Label:")
                          :expand nil)
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :justify :right
                                         :label
                                         (format nil
                                                "This is a Right Justified~%~
                                                 Multi-line label~%~
                                                 Third line"))
                          :expand nil)
      ;; Create a Line wrapped label
      (gtk-box-pack-start vbox2
                          (make-heading "Line Wrapped Label:")
                          :expand nil)
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :wrap t
                                         :label
                                         (format nil
                                          "This is an example of a ~
                                           line-wrapped label.  It should ~
                                           not be taking up the entire ~
                                           width allocated to it, but ~
                                           automatically wraps the words to ~
                                           fit.  The time has come, for all ~
                                           good men, to come to the aid of ~
                                           their party.  The sixth sheik's ~
                                           six sheep's sick.  It supports ~
                                           multiple paragraphs correctly, ~
                                           and correctly adds many extra ~
                                           spaces."))
                          :expand nil)
      ;; Create a Filled and wrapped label
      (gtk-box-pack-start vbox2
                          (make-heading "Filled and Wrapped Label:")
                          :expand nil)
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :wrap t
                                         :justify :fill
                                         :label
                                         (format nil
                                          "This is an example of a ~
                                           line-wrapped, filled label.  It ~
                                           should be taking up the entire ~
                                           width allocated to it.  Here is ~
                                           a sentence to prove my point.  ~
                                           Here is another sentence.  Here ~
                                           comes the sun, do de do de do.  ~
                                           This  is a new paragraph.  This ~
                                           is  another newer, longer, ~
                                           better  paragraph.  It is coming ~
                                           to an end, unfortunately."))
                          :expand nil)
      ;; Create an underlined label
      (gtk-box-pack-start vbox2
                          (make-heading "Underlined Label:")
                          :expand nil)
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :justify :left
                                         :use-underline t
                                         :pattern
          "_________________________ _ _________ _ ______     __ _______ ___"
                                         :label
                                         (format nil
                                          "This label is underlined!~%~
                                           This one is underlined in quite ~
                                           a  funky fashion"))
                          :expand nil)
      ;; Put the boxes into the window and show the window
      (gtk-box-pack-start hbox vbox1 :expand nil)
      (gtk-box-pack-start hbox (gtk-separator-new :vertical))
      (gtk-box-pack-start hbox vbox2 :expand nil)
      (gtk-container-add window hbox)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
    <figure id="figure-more-labels">
     <title>More Labels</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/more-labels302x312.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-more-labels">
     <title>More Labels</title>
     <programlisting>
(defun example-more-labels ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "GTK+ 3.4 Example More Labels"
                                 :default-width 300
                                 :border-width 6))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 6))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 6))
          (hbox (make-instance 'gtk-box
                               :orientation :horizontal
                               :homogeneous nil
                               :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-box-pack-start hbox
                          (make-instance 'gtk-label
                                         :label "Angle 90"
                                         :angle 90))
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :label "Angel 45"
                                         :angle 45))
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :label "Angel 315"
                                         :angle 315))
      (gtk-box-pack-start hbox vbox1)
      (gtk-box-pack-start hbox
                          (make-instance 'gtk-label
                                         :label "Angel 270"
                                         :angle 270))
      (gtk-box-pack-start vbox2 hbox)
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-hseparator))
      (gtk-box-pack-start vbox2
                          (gtk-label-new "Normal Label"))
      (gtk-box-pack-start vbox2
                          (gtk-label-new-with-mnemonic "With _Mnemonic"))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :label "This Label is Selectable"
                                         :selectable t))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :label
                                         "&#x3C;small>Small text&#x3C;/small>"
                                          :use-markup t))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :label
                                         "&#x3C;b>Bold text&#x3C;/b>"
                                          :use-markup t))
      (gtk-box-pack-start vbox2
                          (make-instance 'gtk-label
                                         :use-markup t
                                         :label
                                         (format nil
                                         "Go to the ~
                                         &#x3C;a href=\"http://gtk.org/\">~
                                         GTK+ Website&#x3C;/a> for more ...")))
      (gtk-container-add window vbox2)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Images">
   <title>Images</title>
   <figure id="figure-images">
    <title>Images</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/images.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &gtk-image; widget displays an image.  Various kinds of
    object can be displayed as an image; most typically, you would load a <ulink url="&gdk-pixbuf;">
    <code>gdk-pixbuf</code></ulink> object ("pixel buffer") from a file, and then display that.  There is a
    convenience function to do this, &gtk-image-new-from-file;, used as follows:
   </para>
   <programlisting>
(let ((image (gtk-image-new-from-file "myfile.png")))
  ... )
   </programlisting>
   <para>
    If the file is not loaded successfully, the image will contain a "broken image" icon similar to that
    used in many web browsers.  If you want to handle errors in loading the file yourself, for example by
    displaying an error message, then load the image with the function
    <ulink url="&gdk-pixbuf-new-from-file;"><code>gdk-pixbuf-new-from-file</code></ulink>, then create the
    &gtk-image; with the function
    &gtk-image-new-from-pixbuf;.
   </para>
   <para>
    The image file may contain an animation, if so the &gtk-image; will display an animation of type
    <ulink url="&gdk-pixbuf-animation;">
    <code>gdk-pixbuf-animation</code></ulink> instead of a static image.
   </para>
   <para>
    &gtk-image; is a subclass of <ulink url="&gtk-misc;">
    <code>gtk-misc</code></ulink>, which implies that you can align it (center, left, right) and add padding
    to it, using <ulink url="&gtk-misc;"><code>gtk-misc</code></ulink> methods.
   </para>
   <para>
    &gtk-image; is a "no window" widget (has no
    <ulink url="&gdk-window;"><code>gdk-window</code></ulink> of its own), so by default does not receive
    events.  If you want to receive events on the image, such as button clicks, place the image inside a
    <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink>, then connect to the event signals on
    the event box.
   </para>
   <example id="example-button-press-events">
    <title>Handling button press events on a GtkImage</title>
    <programlisting>
(let ((event-box (make-instance 'gtk-event-box))
      (image (gtk-image-new-from-file "myfile.png")))
  (g-signal-connect event-box "button-press-event"
     (lambda (event-box event)
       (format t "Event Box ~A clicked at (~A, ~A)~%"
                 event-box
                 (gdk-event-button-x event)
                 (gdk-event-button-y event))
       ...

       ;; Returning TRUE means we handled the event, so the signal
       ;; emission should be stopped (do not call any further
       ;; callbacks that may be connected). Return NIL
       ;; to continue invoking callbacks.
       t))
  ... )
    </programlisting>
   </example>
   <para>
    When handling events on the event box, keep in mind that coordinates in the image may be different from
    event box coordinates due to the alignment and padding settings on the image (see
    <ulink url="&gtk-misc;"><code>gtk-misc</code></ulink>).  The simplest way to solve this is to set the
    alignment to 0.0 (left/top), and set the padding to zero.  Then the origin of the image will be the same
    as the origin of the event box.
   </para>
   <para>
    The example <link linkend="example-images">Images</link> shows various images.  The code includes an
    example of parsing an image data file in small chunks with the <ulink url="&gdk-pixbuf-loader;">
    <code>gdk-pixbuf-loader</code></ulink> class.  The image is reloaded when clicking the image.  This is
    an example for using a <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink> to receive and
    process the "button-press" signal on an image.  The output of this example is shown in figure
    <link linkend="figure-images">Images</link>.
   </para>
   <example id="example-images">
    <title>Images</title>
    <programlisting>
(let ((load-timeout nil)
      (pixbuf-loader nil)
      (image-stream nil))

(defun progressive-timeout (image)
  (if image-stream
      (let* ((buffer (make-array 512 :element-type '(unsigned-byte 8)))
             (len (read-sequence buffer image-stream)))
        (if (= 0 len)
            ;; We have reached the end of the file.
            (progn
              (close image-stream)
              (setf image-stream nil)
              (gdk-pixbuf-loader-close pixbuf-loader)
              (setf pixbuf-loader nil)
              (return-from progressive-timeout +g-source-remove+))
            ;; Load the buffer into GdkPixbufLoader
            (gdk-pixbuf-loader-write pixbuf-loader buffer 512)))
      (progn
        ;; Create the image stream and the GdkPixbufLoader
        (setf image-stream
              (open "alphatest.png" :element-type '(unsigned-byte 8)))
        (when pixbuf-loader
          (gdk-pixbuf-loader-close pixbuf-loader)
          (setf pixbuf-loader nil))
        (setf pixbuf-loader (gdk-pixbuf-loader-new))
        (g-signal-connect pixbuf-loader "area-prepared"
           (lambda (loader)
             (let ((pixbuf (gdk-pixbuf-loader-pixbuf loader)))
               (gdk-pixbuf-fill pixbuf #xaaaaaaff)
               (gtk-image-set-from-pixbuf image pixbuf))))
        (g-signal-connect pixbuf-loader "area-updated"
           (lambda (loader x y width height)
             (declare (ignore loader x y width height))
             ;; We know the pixbuf inside the GtkImage has changed, but the
             ;; image itself does not know this; so queue a redraw. If we
             ;; wanted to be really efficient, we could use a drawing area
             ;; or something instead of a GtkImage, so we could control the
             ;; exact position of the pixbuf on the display, then we could
             ;; queue a draw for only the updated area of the image.
             (gtk-widget-queue-draw image)))))
  ;; Continue the GSource
  +g-source-continue+)

(defun demo-image ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Images"
                                  :border-width 12
                                  :default-width 300))
           (vgrid (make-instance 'gtk-grid
                                 :orientation :vertical
                                 :border-width 8)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          ;; Destroy the load-timeout source
                          (when load-timeout
                            (g-source-remove load-timeout)
                            (setf load-timeout nil))
                          ;; Close the GdkPixbufLoader object
                          (when pixbuf-loader
                            (gdk-pixbuf-loader-close pixbuf-loader)
                            (setf pixbuf-loader nil))
                          ;; Close open input stream
                          (when image-stream
                            (close image-stream)
                            (setf image-stream nil))
                          (leave-gtk-main)))

      ;; Image loaded from a file
      (let* ((label (make-instance 'gtk-label
                                   :margin-bottom 3
                                   :use-markup t
                                   :label
                                   "&#x3C;b>Image loaded from a file&#x3C;/b>"))
             (frame (make-instance 'gtk-frame
                                   :shadow-type :in))
             (pixbuf (gdk-pixbuf-new-from-file "gtk-logo-old.png"))
             (image (gtk-image-new-from-pixbuf pixbuf)))
        (gtk-container-add vgrid label)
        (gtk-container-add frame image)
        (gtk-container-add vgrid frame))

      ;; Animation loaded from a file
      (let* ((label (make-instance 'gtk-label
                                   :margin-top 9
                                   :margin-bottom 6
                                   :use-markup t
                                   :label
                                   "&#x3C;b>Animation loaded from a file&#x3C;/b>"))
             (frame (make-instance 'gtk-frame
                                   :shadow-type :in))
             (image (gtk-image-new-from-file "floppybuddy.gif")))
        (gtk-container-add vgrid label)
        (gtk-container-add frame image)
        (gtk-container-add vgrid frame))

      ;; Symbolic icon
      (let* ((label (make-instance 'gtk-label
                                   :margin-top 9
                                   :margin-bottom 6
                                   :use-markup t
                                   :label
                                   "&#x3C;b>Symbolic themed icon&#x3C;/b>"))
             (frame (make-instance 'gtk-frame
                                   :shadow-type :in))
             (gicon (g-themed-icon-new-with-default-fallbacks
                        "battery-caution-charging-symbolic"))
             (image (gtk-image-new-from-gicon gicon :dialog)))
        (gtk-container-add vgrid label)
        (gtk-container-add frame image)
        (gtk-container-add vgrid frame))

      ;; Progressive
      (let* ((label (make-instance 'gtk-label
                                   :margin-top 9
                                   :margin-bottom 6
                                   :use-markup t
                                   :label
                                   "&#x3C;b>Progressive image loading&#x3C;/b>"))
             (frame (make-instance 'gtk-frame
                                   :shadow-type :in))
             (event-box (make-instance 'gtk-event-box))
             ;; Create an empty image for now; the progressive loader
             ;; will create the pixbuf and fill it in.
             (image (gtk-image-new-from-pixbuf nil)))

        ;; start_progressive_loading
        ;; This is obviously totally contrived (we slow down loading
        ;; on purpose to show how incremental loading works).
        ;; The real purpose of incremental loading is the case where
        ;; you are reading data from a slow source such as the network.
        ;; The timeout simply simulates a slow data source by inserting
        ;; pauses in the reading process.
        (setf load-timeout
              (gdk-threads-add-timeout 100
                                       (lambda ()
                                         (progressive-timeout image))))

        ;; Restart loading the image from the file
        (g-signal-connect event-box "button-press-event"
           (lambda (event-box event)
             (format t "Event Box ~A clicked at (~A, ~A)~%"
                       event-box
                       (gdk-event-button-x event)
                       (gdk-event-button-y event))
             (setf load-timeout
                   (gdk-threads-add-timeout 100
                       (lambda ()
                         (progressive-timeout image))))))
        (gtk-container-add vgrid label)
        (gtk-container-add event-box image)
        (gtk-container-add frame event-box)
        (gtk-container-add vgrid frame))

      ;; Sensitivity control
      (let ((button (make-instance 'gtk-toggle-button
                                   :margin-top 12
                                   :label "Insensitive")))
        (g-signal-connect button "toggled"
           (lambda (widget)
             (let ((childs (gtk-container-children vgrid)))
               (dolist (child childs)
                 (unless (g-type-is-a (g-object-type child)
                                      "GtkToggleButton")
                   (if (gtk-toggle-button-active button)
                       (progn
                         (setf (gtk-widget-sensitive child) nil)
                         (setf (gtk-button-label button) "Sensitive"))
                       (progn
                         (setf (gtk-widget-sensitive child) t)
                         (setf (gtk-button-label button) "Insensitve"))))))))
        (gtk-container-add vgrid button))

      (gtk-container-add window vgrid)
      (gtk-widget-show-all window)))))
    </programlisting>
   </example>
  </section>

  <section id="Progress_Bars">
   <sectioninfo>
    <itermset>
     <indexterm zone="Progress_Bars"><primary>GtkProgressBar</primary></indexterm>
     <indexterm zone="Progress_Bars"><primary>progress-bar, gtk-progress-bar</primary></indexterm>
     <indexterm zone="Progress_Bars"><primary>progress-bar-new, gtk-progress-bar-new</primary></indexterm>
     <indexterm zone="Progress_Bars"><primary>progress-bar-bar-fraction, gtk-progress-bar-fraction</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Progress Bars</title>
   <figure id="figure-progress-bar">
    <title>Progress Bar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/progress-bar302x196.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Progress bars are implemented as the class <ulink url="&gtk-progress-bar;">
    <code>gtk-progress-bar</code></ulink> and are used to show the status of an operation.  They are pretty
    easy to use, as you will see with the code below.  But first lets start out with the function
    <ulink url="&gtk-progress-bar-new;"><code>gtk-progress-bar-new</code></ulink> to create a new progress
    bar.  Now that the progress bar has been created we can use it and set the fraction with the function
    <ulink url="&gtk-progress-bar-fraction;"><code>gtk-progress-bar-fraction</code></ulink>, which has two
    arguments.  The first argument is the progress bar you wish to operate on, and the second argument is
    the amount "completed", meaning the amount the progress bar has been filled from 0 - 100%.  This is
    passed to the function as a real number ranging from 0 to 1.
   </para>
   <para>
    A progress bar may be set to one of a number of orientations using the function
    &gtk-orientable-orientation;.  The second
    argument is the orientation and may take one of the values of <code>:horizontal</code> or
    <code>:vertical</code> of the &gtk-orientation;
    enumeration.  Progress bars normally grow from top to bottom or left to right. With the function
    <ulink url="&gtk-progress-bar-inverted;"><code>gtk-progress-bar-inverted</code></ulink> can be set to
    grow in the opposite direction.
   </para>
   <para>
    As well as indicating the amount of progress that has occurred, the progress bar may be set to just
    indicate that there is some activity.  This can be useful in situations where progress cannot be
    measured against a value range.  The function <ulink url="&gtk-progress-bar-pulse;">
    <code>gtk-progress-bar-pulse</code></ulink> indicates that some progress has been made.  The step size
    of the activity indicator is set using the function <ulink url="&gtk-progress-bar-pulse-step;">
    <code>gtk-progress-bar-pulse-step</code></ulink>.
   </para>
   <para>
    The progress bar can also display a configurable text string within its trough, using the function
    <ulink url="&gtk-progress-bar-text;"><code>gtk-progress-bar-text</code></ulink>.  You can turn off the
    display of the string by calling <ulink url="&gtk-progress-bar-text;">
    <code>gtk-progress-bar-text</code></ulink> again with <code>NIL</code> as second argument.  The current
    text setting of a progress bar can be retrieved with the function
    <ulink url="&gtk-progress-bar-text;"><code>gtk-progress-bar-text</code></ulink>.
   </para>
   <para>
    Progress Bars are usually used with timeouts or other such functions (see section on Timeouts, I/O and
    Idle Functions) to give the illusion of multitasking.  All will employ the
    <ulink url="&gtk-progress-bar-fraction;"><code>gtk-progress-bar-fraction</code></ulink> or
    <ulink url="&gtk-progress-bar-pulse;"><code>gtk-progress-bar-pulse</code></ulink> functions in the same
    manner.
   </para>
   <para>
    The example <link linkend="example-progress-bar">Progress Bar</link> shows an example of the progress
    bar, updated using timeouts.  This code also shows you how to reset the Progress Bar.  The output
    of this example is in the figure <link linkend="figure-progress-bar">Progress bar</link>.
   </para>
   <example id="example-progress-bar">
    <title>Progress Bar</title>
    <programlisting>
(defstruct pbar-data
  pbar
  timer
  mode)

(defun progress-bar-timeout (pdata)
  (if (pbar-data-mode pdata)
      (gtk-progress-bar-pulse (pbar-data-pbar pdata))
      (let ((val (+ (gtk-progress-bar-fraction (pbar-data-pbar pdata))
                    0.01)))
        (when (> val 1.0) (setq val 0.0))
        (setf (gtk-progress-bar-fraction (pbar-data-pbar pdata)) val)))
  t)

(defun example-progress-bar ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "GTK+ 3.4 Example Progress Bar"
                                 :default-width 300))
          (pdata (make-pbar-data :pbar (make-instance 'gtk-progress-bar)))
          (vbox (make-instance 'gtk-box
                               :orientation :vertical
                               :border-width 12
                               :spacing 12))
          (align (gtk-alignment-new 0.1 0.9 1.0 0.0))
          (table (gtk-table-new 2 3 t)))
      (setf (pbar-data-timer pdata)
            (g-timeout-add 100
                           (lambda ()
                             (progress-bar-timeout pdata))))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (g-source-remove (pbar-data-timer pdata))
                          (setf (pbar-data-timer pdata) 0)
                          (leave-gtk-main)))
      (gtk-box-pack-start vbox align)
      (gtk-container-add align (pbar-data-pbar pdata))
      (gtk-box-pack-start vbox table)
      (let ((check (gtk-check-button-new-with-mnemonic "_Show text")))
        (g-signal-connect check "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (let ((text (gtk-progress-bar-text (pbar-data-pbar pdata))))
               (if (or (null text) (zerop (length text)))
                   (setf (gtk-progress-bar-text (pbar-data-pbar pdata))
                         "Some text")
                   (setf (gtk-progress-bar-text (pbar-data-pbar pdata)) ""))
               (setf (gtk-progress-bar-show-text (pbar-data-pbar pdata))
                     (gtk-toggle-button-active check)))))
        (gtk-table-attach table check 0 1 0 1))
      (let ((check (gtk-check-button-new-with-label "Activity mode")))
        (g-signal-connect check "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (setf (pbar-data-mode pdata)
                   (not (pbar-data-mode pdata)))
             (if (pbar-data-mode pdata)
                 (gtk-progress-bar-pulse (pbar-data-pbar pdata))
                 (setf (gtk-progress-bar-fraction (pbar-data-pbar pdata))
                       0.0))))
        (gtk-table-attach table check 0 1 1 2))
      (let ((check (gtk-check-button-new-with-label "Inverted")))
        (g-signal-connect check "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (setf (gtk-progress-bar-set-inverted (pbar-data-pbar pdata))
                   (gtk-toggle-button-active check))))
        (gtk-table-attach table check 0 1 2 3))
      (let ((button (gtk-button-new-with-label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Statusbars">
   <sectioninfo>
    <itermset>
     <indexterm zone="Statusbars"><primary>GtkStatusbar</primary></indexterm>
     <indexterm zone="Statusbars"><primary>statusbar, gtk-statusbar</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Statusbars</title>
   <figure id="figure-statusbar">
    <title>Statusbar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/statusbar302x142.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Statusbars are simple widgets used to display a text message.  They keep a stack of the messages pushed
    onto them, so that popping the current message will re-display the previous text message.
   </para>
   <para>
    In order to allow different parts of an application to use the same statusbar to display messages, the
    statusbar widget issues context Identifiers which are used to identify different "users".  The message
    on top of the stack is the one displayed, no matter what context it is in.  Messages are stacked in
    last-in-first-out order, not context identifier order.
   </para>
   <para>
    A statusbar is created with a call to <ulink url="&gtk-statusbar-new;">
    <code>gtk-statusbar-new</code></ulink>.  A new context Identifier is requested using a call to the
    function <ulink url="&gtk-statusbar-context-id;"><code>gtk-statusbar-context-id</code></ulink> with a
    short textual description of the context as the second argument.
   </para>
   <para>
    There are three functions that can operate on statusbars: <ulink url="&gtk-statusbar-push;">
    <code>gtk-statusbar-push</code></ulink>, <ulink url="&gtk-statusbar-pop;">
    <code>gtk-statusbar-pop</code></ulink>, and <ulink url="&gtk-statusbar-remove;">
    <code>gtk-statusbar-remove</code></ulink>.  The first function, <ulink url="&gtk-statusbar-push;">
    <code>gtk-statusbar-push</code></ulink>, is used to add a new message to the statusbar.  It returns a
    message identifier, which can be passed later to the function <ulink url="&gtk-statusbar-remove;">
    <code>gtk-statusbar-remove</code></ulink> to remove the message with the given message and context
    identifiers from the stack of the statusbar.  The function <ulink url="&gtk-statusbar-pop;">
    <code>gtk-statusbar-pop</code></ulink> removes the message highest in the stack with the given context
    identifier.
   </para>
   <para>
    The example <link linkend="example-statusbar">Statusbar</link> creates a statusbar and two buttons, one
    for pushing items onto the statusbar, and one for popping the last item back off.
   </para>
   <example id="example-statusbar">
    <title>Statusbar</title>
    <programlisting>
(defun example-statusbar ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Status Bar"
                                  :default-width 300
                                  :border-width 12))
           (vbox (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 3))
           (statusbar (make-instance 'gtk-statusbar))
           (id (gtk-statusbar-context-id statusbar "Example Status Bar"))
           (count 0))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-box-pack-start vbox statusbar)
      (let ((button (gtk-button-new-with-label "Push Item")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (setq count (+ 1 count))
             (gtk-statusbar-push statusbar id (format nil "Item &#x7e;A" count))))
        (gtk-box-pack-start vbox button :expand t :fill t :padding 3))
      (let ((button (gtk-button-new-with-label "Pop Item")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-statusbar-pop statusbar id)))
        (gtk-box-pack-start vbox button :expand t :fill t :padding 3))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Info_Bars">
   <sectioninfo>
    <itermset>
     <indexterm zone="Info_Bars"><primary>GtkInfoBars</primary></indexterm>
     <indexterm zone="Info_Bars"><primary>info-bar, gtk-info-bar</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Info Bars</title>
   <figure id="figure-info-bar">
    <title>Info Bar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/info-bar385x165.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> is a widget that can be used to show
    messages to the user without showing a dialog.  It is often temporarily shown at the top or bottom of
    a document.  In contrast to <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>, which has a
    horizontal action area at the bottom, <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink>
    has a vertical action area at the side.
   </para>
   <para>
    The API of <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> is very similar to
    <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>, allowing you to add buttons to the action
    area with <ulink url="&gtk-info-bar-add-button;"><code>gtk-info-bar-add-button</code></ulink> or
    <ulink url="&gtk-info-bar-new-with-buttons;"><code>gtk-info-bar-new-with-buttons</code></ulink>.  The
    sensitivity of action widgets can be controlled with <ulink url="&gtk-info-bar-set-response-sensitive;">
    <code>gtk-info-bar-set-response-sensitive</code></ulink>.  To add widgets to the main content area of a
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink>, use the function
    <ulink url="&gtk-info-bar-content-area;"><code>gtk-info-bar-content-area</code></ulink> and add your
    widgets to the container.
   </para>
   <para>
    Similar to <ulink url="&gtk-message-dialog;"><code>gtk-message-dialog</code></ulink>, the contents of a
    <ulink url="&gtk-info-bar;"><code>gtk-info-bar</code></ulink> can by classified as error message,
    warning, informational message, etc, by using <ulink url="&gtk-info-bar-message-type;">
    <code>gtk-info-bar-message-type</code></ulink>.  GTK+ uses the message type to determine the background
    color of the message area.
   </para>
   <example id="example-info-bar">
    <title>Info Bar</title>
    <programlisting>
(defun example-info-bar ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Info bar"
                                  :border-width 12
                                  :default-width 250))
           (grid (make-instance 'gtk-grid))
           (info-bar (make-instance 'gtk-info-bar
                                    :no-show-all t))
           (message (make-instance 'gtk-label
                                   :label ""))
           (content (gtk-info-bar-content-area info-bar)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-widget-show message)
      ;; Add a label to the content area of the info bar
      (gtk-container-add content message)
      ;; Add a button OK to the action area
      (gtk-info-bar-add-button info-bar "gtk-ok" 1)
      ;; Add two more buttons to the action area
      (gtk-info-bar-add-buttons info-bar "gtk-cancel" 2
                                         "gtk-no" 3)
      ;; Connect a handler for the "response" signal of the info bar
      (g-signal-connect info-bar "response"
         (lambda (widget response-id)
           (declare (ignore widget))
           (format t "response-id is ~A~%" response-id)
           (gtk-widget-hide info-bar)))
      (gtk-grid-attach grid info-bar 0 2 1 1)
      ;; Show the info bar
      (setf (gtk-label-text message) "An Info Message in the content area.")
      (setf (gtk-info-bar-message-type info-bar) :info)
      (gtk-widget-show info-bar)
      ;; Add the container grid to the window and show all
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Adjustments">
  <sectioninfo>
   <itermset>
    <indexterm zone="Adjustments"><primary>GtkAdjustment</primary></indexterm>
    <indexterm zone="Adjustments"><primary>adjustment, gtk-adjustment</primary></indexterm>
   </itermset>
  </sectioninfo>
  <title>Adjustments</title>

  <section id="Introduction_to_Adjustments">
   <title>Introduction to Adjustments</title>
   <para>
    GTK+ has various widgets that can be visually adjusted by the user using the mouse or the keyboard, such
    as the range widgets, described in <link linkend="Range_Widgets">Range Widgets</link>.  There are also a
    few widgets that display some adjustable portion of a larger area of data, such as the viewport widget
    <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink>.
   </para>
   <para>
    Obviously, an application needs to be able to react to changes the user makes in range widgets.  One way
    to do this would be to have each widget emit its own type of signal when its adjustment changes, and
    either pass the new value to the signal handler, or require it to look inside the data structure of the
    widget in order to ascertain the value.  But you may also want to connect the adjustments of several
    widgets together, so that adjusting one adjusts the others.  The most obvious example of this is
    connecting a scrollbar to a panning viewport or a scrolling text area.  If each widget has its own way of
    setting or getting the adjustment value, then the programmer may have to write their own signal handlers
    to translate between the "output" of one widget's signal and the "input" of another's adjustment setting
    function.
   </para>
   <para>
    GTK+ solves this problem using the object <ulink url="&gtk-adjustment;">
    <code>gtk-adjustment</code></ulink>, which is not a widget but a way for widgets to store and pass
    adjustment information in an abstract and flexible form.  The most obvious use of
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> is to store the configuration
    parameters and values of range widgets, such as scrollbars and scale controls.  However, since
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> is derived from
    <ulink url="&g-object;"><code>g-object</code></ulink>, adjustments have some special powers beyond those
    of normal data structures.  Most importantly, they can emit signals, just like widgets, and these signals
    can be used not only to allow a program to react to user input on adjustable widgets, but also to
    propagate adjustment values transparently between adjustable widgets.
   </para>
   <para>
    You will see how adjustments fit in when you see the other widgets that incorporate them: Progress Bars,
    Viewports, Scrolled Windows, and others.
   </para>
  </section>

  <section id="Creating_an_Adjustment">
   <sectioninfo>
    <itermset>
     <indexterm zone="Creating_an_Adjustment"><primary>adjustment-new, gtk-adjustment-new</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Creating an Adjustment</title>
   <para>
    Many of the widgets which use adjustment objects do so automatically, but some cases will be shown in
    later examples where you may need to create an adjustment yourself.  An adjustment can be created with
    the function <ulink url="&gtk-adjustment-new;"><code>gtk-adjustment-new</code></ulink> which has the
    arguments <code>value</code>, <code>lower</code>, <code>upper</code>, <code>step-increment</code>,
    <code>page-increment</code>, and <code>page-size</code>.
   </para>
   <para>
    The argument <code>value</code> is the initial value you want to give to the adjustment, usually
    corresponding to the topmost or leftmost position of an adjustable widget.  The argument
    <code>lower</code> specifies the lowest value which the adjustment can hold.  The argument
    <code>step-increment</code> specifies the "smaller" of the two increments by which the user can change
    the value, while <code>page-increment</code> is the "larger" one.  The argument <code>page-size</code>
    usually corresponds somehow to the visible area of a panning widget.  The argument <code>upper</code> is
    used to represent the bottom most or right most coordinate in a panning widget's child.  Therefore it is
    not always the largest number that <code>value</code> can take, since <code>page-size</code> of such
    widgets is usually non-zero.
   </para>
  </section>

  <section id="Using_Adjustments_the_Easy_Way">
   <sectioninfo>
    <itermset>
     <indexterm zone="Using_Adjustments_the_Easy_Way"><primary>viewport-new, gtk-viewport-new</primary></indexterm>
     <indexterm zone="Using_Adjustments_the_Easy_Way"><primary>scrollable-get-vadjustment, gtk-scrollable-get-vadjustment</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Using Adjustments the Easy Way</title>
   <para>
    The adjustable widgets can be roughly divided into those which use and require specific units for these
    values and those which treat them as arbitrary numbers.  The group which treats the values as arbitrary
    numbers includes the range widgets (scrollbars and scales, the progress bar widget, and the spin button
    widget).  These widgets are all the widgets which are typically "adjusted" directly by the user with the
    mouse or keyboard.  They will treat the lower and upper values of an adjustment as a range within which
    the user can manipulate the value of the adjustment.  By default, they will only modify the value of an
    adjustment.
   </para>
   <para>
    The other group includes the text widget, the viewport widget, the compound list widget, and the scrolled
    window widget.  All of these widgets use pixel values for their adjustments.  These are also all widgets
    which are typically "adjusted" indirectly using scrollbars.  While all widgets which use adjustments
    can either create their own adjustments or use ones you supply, you will generally want to let this
    particular category of widgets create its own adjustments.  Usually, they will eventually override all
    the values except the value itself in whatever adjustments you give them, but the results are, in
    general, undefined (meaning, you'll have to read the source code to find out, and it may be different
    from widget to widget).
   </para>
   <para>
    Now, you are probably thinking, since text widgets and viewports insist on setting everything except the
    value of their adjustments, while scrollbars will only touch the value of the adjustment, if you share an
    adjustment object between a scrollbar and a text widget, manipulating the scrollbar will automagically
    adjust the viewport widget? Of course it will! Just like this:
   </para>
   <programlisting>
(let (;; A viewport creates its own adjustments
      (viewport (gtk-viewport-new))
      ;; use the adjustment from the viewport for the scrollbar
      (vscrollbar (make-instance 'gtk-scrollbar
                                 :orientation :vertical
                                 :vadjustment
                                 (gtk-scrollable-get-vadjustment viewport))))
  [...] )
   </programlisting>
  </section>

  <section id="Adjustment_Internals">
   <sectioninfo>
    <itermset>
     <indexterm zone="Adjustment_Internals"><primary>adjustment-value, gtk-adjustment-value</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Adjustment Internals</title>
   <para>
    Ok, you say, that's nice, but what if I want to create my own handlers to respond when the user adjusts a
    range widget or a spin button, and how do I get at the value of the adjustment in these handlers? To
    answer these questions and more, let's start by taking a look at the Lisp class representing
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> itself:
   </para>
   <programlisting>
(define-g-object-class "GtkAdjustment" gtk-adjustment
  (:superclass gtk-object
   :export t
   :interfaces nil
   :type-initializer "gtk_adjustment_get_type")
  ((lower
    gtk-adjustment-lower
    "lower" "gdouble" t t)
   (page-increment
    gtk-adjustment-page-increment
    "page-increment" "gdouble" t t)
   (page-size
    gtk-adjustment-page-size
    "page-size" "gdouble" t t)
   (step-increment
    gtk-adjustment-step-increment
    "step-increment" "gdouble" t t)
   (upper
    gtk-adjustment-upper
    "upper" "gdouble" t t)
   (value
    gtk-adjustment-value
    "value" "gdouble" t t)))
   </programlisting>
   <para>
    The slots of the class are <code>lower</code>, <code>page-increment</code>, <code>page-size</code>,
    <code>step-increment</code>, <code>upper</code>, and <code>value</code>.  The slots represent the
    properties of the C class <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink>.  The slots
    can be accessed with the corresponding Lisp accessor functions.  Alternativly, the C accessor functions
    like <code>gtk_adjustment_set_value()</code> and <code>gtk_adjustment_set_value()</code> are availabe in
    the Lisp binding through e.g. <ulink url="&gtk-adjustment-value;">
    <code>gtk-adjustment-value</code></ulink> for the property <code>value</code>.
   </para>
   <para>
    As mentioned earlier, an adjustment object is a subclass of <ulink url="&g-object;">
    <code>g-object</code></ulink> just like all the various widgets, and thus it is able to emit signals.
    This is, of course, why updates happen automagically when you share an adjustment object between a
    scrollbar and another adjustable widget; all adjustable widgets connect signal handlers to their
    adjustment's "value-changed" signal, as can your program.
   </para>
   <para>
    The various widgets that use the adjustment object will emit the signal "value-changed" on an adjustment
    whenever they change its value.  This happens both when user input causes the slider to move on a range
    widget, as well as when the program explicitly changes the value with
    <ulink url="&gtk-adjustment-value;"><code>gtk-adjustment-value</code></ulink>.  So, for example, if you
    have a scale widget, and you want to change the rotation of a picture whenever its value changes, you
    would create a callback like this:
   </para>
   <programlisting>
(defun cb-rotate-picture (adj picture)
  (set-picture-rotation picture (gtk-adjustment-get-value adj))
  ... )
   </programlisting>
   <para>
    and connect it to the scale widget's adjustment like this:
   </para>
   <programlisting>
(g-signal-connect adj "value-changed"
                  (lambda (widget)
                    (cb-rotate-picture widget picture)))
   </programlisting>
   <para>
    What about when a widget reconfigures the upper or lower fields of its adjustment, such as when a user
    adds more text to a text widget? In this case, it emits the signal "changed".  Range widgets typically
    connect a handler to this signal, which changes their appearance to reflect the change - for example,
    the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference
    between the lower and upper values of its adjustment.
   </para>
   <para>
    You probably won't ever need to attach a handler to the signal "changed", unless you are writing a new
    type of range widget.  However, if you change any of the values in an adjustment directly, you should
    emit this signal on it to reconfigure whatever widgets are using it, like this
    <code>(g-signal-emit adj "changed")</code>.
   </para>
  </section>
 </chapter>

 <chapter id="Range_Widgets">
  <title>Range Widgets</title>
  <sectioninfo>
   <itermset>
    <indexterm zone="Range_Widgets"><primary>GtkRange</primary></indexterm>
   </itermset>
  </sectioninfo>
  <section id="Introduction_to_Range_Widgets">
   <title>Introduction to Range Widgets</title>
   <para>
    The category of range widgets includes the ubiquitous scrollbar widget and the less common scale widget.
    Though these two types of widgets are generally used for different purposes, they are quite similar in
    function and implementation.  All range widgets share" a set of common graphic elements, each of which
    has its own X window and receives events.  They all contain a "trough" and a "slider" (what is sometimes
    called a "thumbwheel" in other GUI environments).  Dragging the slider with the pointer moves it back and
    forth within the trough, while clicking in the trough advances the slider towards the location of the
    click, either completely, or by a designated amount, depending on which mouse button is used.
   </para>
   <para>
    As mentioned in <link linkend="Adjustments">Adjustments</link>, all range widgets are associated with an
    adjustment object, from which they calculate the length of the slider and its position within the trough.
    When the user manipulates the slider, the range widget will change the value of the adjustment.
   </para>
  </section>

  <section id="Scrollbar_Widgets">
   <sectioninfo>
    <itermset>
     <indexterm zone="Scrollbar_Widgets"><primary>GtkScrollbar</primary></indexterm>
     <indexterm zone="Scrollbar_Widgets"><primary>scrollbar, gtk-scrollbar</primary></indexterm>
     <indexterm zone="Scrollbar_Widgets"><primary>scrollbar-new, gtk-scrollbar-new</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Scrollbar Widgets</title>
   <para>
    These are your standard, run-of-the-mill scrollbars.  These should be used only for scrolling some other
    widget, such as a list, a text box, or a viewport (and it is generally easier to use the scrolled window
    widget in most cases).  For other purposes, you should use scale widgets, as they are friendlier and more
    featureful.
   </para>
   <para>
    The <ulink url="&gtk-scrollbar;"><code>gtk-scrollbar</code></ulink> widget is a horizontal or vertical
    scrollbar, depending on the value of the &gtk_orientable_orientation;
    property.  A scrollbar can be created with the function
    <ulink url="&gtk-scrollbar-new;"><code>gtk-scrollbar-new</code></ulink>, which takes two arguments.  The
    first argument gives the direction <code>:horizontal</code> or <code>:vertical</code> and the second a
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink>.  The second argument can be
    <code>NIL</code>.  In this case a <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> is
    created.
   </para>
   <para>
    The position of the thumb in a scrollbar is controlled by the scroll adjustments.  See
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> for the fields in an adjustment - for
    <ulink url="&gtk-scrollbar;"><code>gtk-scrollbar</code></ulink>, the property
    <ulink url="&gtk_adjustment_value;"><code>value</code></ulink> of <ulink url="&gtk-adjustment;">
    <code>gtk-adjustment</code></ulink> represents the position of the scrollbar, which must be between the
    <ulink url="&gtk_adjustment_lower;"><code>lower</code></ulink> and (<ulink url="&gtk_adjustment_upper;">
    <code>upper</code></ulink> - <ulink url="&gtk_adjustment_page-size;"><code>page-size</code></ulink>)
    properties.  The property <ulink url="&gtk_adjustment_page-size;"><code>page-size</code></ulink>
    represents the size of the visible scrollable area.  The properties
    <ulink url="&gtk_adjustment_step-increment;"><code>step-increment</code></ulink> and
    <ulink url="&gtk_adjustment_page-increment;"><code>page-increment</code></ulink> are used when the user
    asks to step down (using the small stepper arrows) or page down (using for example the PageDown key).
   </para>
   <note>
    <para>
     The <code>GtkHScrollbar</code> widget for a horizontal scrollbar and the <code>GtkVScrollbar</code>
     widget for a vertical scrollbar are deprecated since GTK+ 3.2 and not exported in the Lisp
     implementation.
    </para>
   </note>
  </section>

  <section id="Scale_Widgets">
   <sectioninfo>
    <itermset>
     <indexterm zone="Scale_Widgets"><primary>GtkScale</primary></indexterm>
     <indexterm zone="Scale_Widgets"><primary>scale, gtk-scale</primary></indexterm>
     <indexterm zone="Scale_Widgets"><primary>scale-new, gtk-scale-new</primary></indexterm>
     <indexterm zone="Scale_Widgets"><primary>scale-new-with-range, gtk-scale-new-with-range</primary></indexterm>
    </itermset>
   </sectioninfo>
   <title>Scale Widgets</title>
   <para>
    Scale widgets are used to allow the user to visually select and manipulate a value within a specific
    range.  You might want to use a scale widget, for example, to adjust the magnification level on a zoomed
    preview of a picture, or to control the brightness of a color, or to specify the number of minutes of
    inactivity before a screensaver takes over the screen.
   </para>
   <para>
    As with scrollbars, the <ulink url="&gtk-scale;"><code>gtk-scale</code></ulink> widget is a horizontal or
    vertical scale, depending on the value of the &gtk_orientable_orientation;
    property.  A scale can be created with the function
    <ulink url="&gtk-scale-new;"><code>gtk-scale-new</code></ulink>, which takes two arguments.  The first
    argument gives the direction <code>:horizontal</code> or <code>:vertical</code> and the second a
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink>.
   </para>
   <para>
    The adjustment argument can either be an adjustment which has already been created with
    <ulink url="&gtk-adjustment-new;"><code>gtk-adjustment-new</code></ulink>, or <code>NIL</code>, in which
    case, an anonymous adjustment is created with all of its values set to 0.0 (which is not very useful in
    this case).  In order to avoid confusing yourself, you probably want to create your adjustment with a
    <ulink url="&gtk_adjustment_page-size;"><code>page-size</code></ulink> of 0.0 so that its upper value
    actually corresponds to the highest value the user can select.  The function
    <ulink url="&gtk-scale-new-with-range;"><code>gtk-scale-new-with-range</code></ulink> variant take care
    of creating a suitable adjustment.  The function takes four arguments.  The first argument is again the
    orientation of the scale and the next arguments represent the values for creating an
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> with intial values for the properties
    <ulink url="&gtk_adjustment_lower;"><code>lower</code></ulink>, <ulink url="&gtk_adjustment_upper;">
    <code>upper</code></ulink>, and <ulink url="&gtk_adjustment_step-increment;">
    <code>step-increment</code></ulink>.  If you are already thoroughly confused, read the section
    <link linkend="Adjustments">Adjustments</link> again for an explanation of what exactly adjustments do
    and how to create and manipulate them.
   </para>

   <section id="Functions_and_Signals">
   <sectioninfo>
    <itermset>
     <indexterm zone="Functions_and_Signals"><primary>GtkPositionType</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>positon-type, gtk-position-type</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-draw-value, gtk-scale-draw-value</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-set-digits, gtk-scale-set-digits</primary></indexterm>
     <indexterm zone="Functions_and_Signals"><primary>scale-value-pos, gtk-scale-value-pos</primary></indexterm>
    </itermset>
   </sectioninfo>
    <title>Functions and Signals</title>
    <para>
     Scale widgets can display their current value as a number beside the trough.  The default behaviour is
     to show the value, but you can change this with this with the generic function
     <ulink url="&gtk-scale-draw-value;"><code>gtk-scale-draw-value</code></ulink>, which takes as the first
     argument a widget of type <ulink url="&gtk-scale;"><code>gtk-scale</code></ulink> and as the second
     argument <code>draw-value</code>, which is either <code>T</code> or <code>NIL</code>, with predictable
     consequences for either one.
    </para>
    <para>
     The value displayed by a scale widget is rounded to one decimal point by default, as is the value field
     in its adjustment.  You can change this with the function <ulink url="&gtk-scale-digits;">
     <code>gtk-scale-digits</code></ulink>.  The first argument is a widget of type <ulink url="&gtk-scale;">
     <code>gtk-scale</code></ulink> and the second argument <code>digits</code>, where <code>digits</code> is
     the number of decimal places you want.  You can set digits to anything you like, but no more than 13
     decimal places will actually be drawn on screen.
    </para>
    <para>
     Finally, the value can be drawn in different positions relative to the trough with the generic function
     <ulink url="&gtk-scale-value-pos;"><code>gtk-scale-value-pos</code></ulink>.  The first argument is
     again a scale widget.  The second argument <code>pos</code> is of the enumeration type
     <ulink url="&gtk-position-type;"><code>gtk-position-type</code></ulink>.
    </para>
    <para>
     If you position the value on the "side" of the trough (e.g., on the top or bottom of a horizontal scale
     widget), then it will follow the slider up and down the trough.
    </para>
   </section>
  </section>

  <section id="Common_Range_Functions">
   <title>Common Range Functions</title>
   <para>
    The range widget class is fairly complicated internally, but, like all the base class widgets, most of
    its complexity is only interesting if you want to hack on it.  Also, almost all of the functions and
    signals it defines are only really used in writing derived widgets.  There are, however, a few useful
    functions that will work on all range widgets.
   </para>

   <section id="Getting_and_Setting_Adjustments">
    <sectioninfo>
     <itermset>
      <indexterm zone="Getting_and_Setting_Adjustments">
       <primary>range-adjustment, gtk-range-adjustment</primary>
      </indexterm>
      <indexterm zone="Getting_and_Setting_Adjustments">
       <primary>range-adjustment-changed, gtk-range-adjustment-changed</primary>
      </indexterm>     
     </itermset>
    </sectioninfo>
    <title>Getting and Setting Adjustments</title>
    <para>
     Getting and setting the adjustment for a range widget "on the fly" is done with the function
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink>.  The function
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink> returns the adjustment to
     which the range is connected.
    </para>
    <para>
     <ulink url="&gtk-range-adjustment;"><code>gtk-range-adjustment</code></ulink> does absolutely nothing
     if you pass it the adjustment that range is already using, regardless of whether you changed any of its
     fields or not.  If you pass it a new adjustment, it will unreference the old one if it exists (possibly
     destroying it), connect the appropriate signals to the new one, and emit the "changed" signal, which
     will recalculate the size or position of the slider and redraw if necessary.  As mentioned in the
     section on adjustments, if you wish to reuse the same adjustment, when you modify its values directly,
     you should emit the "changed" signal on it.
    </para>
   </section>

   <section id="Key_and_Mouse_bindings">
    <title>Key and Mouse bindings</title>
    <para>
     All of the GTK+ range widgets react to mouse clicks in more or less the same way.  Clicking button-1 in
     the trough will cause its adjustment's <code>page-increment</code> to be added or subtracted from its
     value, and the slider to be moved accordingly.  Clicking mouse button-2 in the trough will jump the
     slider to the point at which the button was clicked.  Clicking button-3 in the trough of a range or any
     button on a scrollbar's arrows will cause its adjustment's value to change by
     <code>step-increment</code> at a time.
    </para>
    <para>
     Scrollbars are not focusable, thus have no key bindings.  The key bindings for the other range widgets
     (which are, of course, only active when the widget has focus) are do not differentiate between
     horizontal and vertical range widgets.
    </para>
    <para>
     All range widgets can be operated with the left, right, up and down arrow keys, as well as with the Page
     Up and Page Down keys.  The arrows move the slider up and down by <code>step-increment</code>, while
     Page Up and Page Down move it by <code>page-increment</code>.
    </para>
    <para>
     The user can also move the slider all the way to one end or the other of the trough using the keyboard.
     This is done with the Home and End keys.
    </para>
   </section>
  </section>

  <section id="Example_Range_Widgets">
   <title>Example Range Widgets</title>
   <figure id="figure-range-widgets">
    <title>Range Widgets</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/range-widgets269x420.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The example <link linkend="example-range-widgets">Range Widgets</link> is a somewhat modified version of
    the "range controls" test from <filename>testgtk.c</filename>.  It basically puts up a window with three
    range widgets all connected to the same adjustment, and a couple of controls for adjusting some of the
    parameters mentioned above and in the section on adjustments, so you can see how they affect the way
    these widgets work for the user.
   </para>
   <para>
    You will notice that the program does not call &g-signal-connect;
    for the "delete-event", but only for the "destroy" signal. This
    will still perform the desired function, because an unhandled "delete-event" will result in a "destroy"
    signal being given to the window.
   </para>
   <example id="example-range-widgets">
     <title>Range Widgets</title>
     <programlisting>
(defun example-range-widgets ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Range Widgets"))
           (box1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0))
           (box2 (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
           (box3 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12))
           (adj1 (make-instance 'gtk-adjustment
                                :value 0.0
                                :lower 0.0
                                :upper 101.0
                                :step-increment 0.1
                                :page-increment 1.0
                                :page-size 1.0))
           (vscale (make-instance 'gtk-scale
                                  :orientation :vertical
                                  :digits 1
                                  :value-pos :top
                                  :draw-value t
                                  :adjustment adj1))
           (hscale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 1
                                   :value-pos :top
                                   :draw-value t
                                   :width-request 200
                                   :height-request -1
                                   :adjustment adj1))
           (scrollbar (make-instance 'gtk-scrollbar
                                     :orientation :horizontal
                                     :adjustment adj1)))
      ;; Connect a handler for the signal "destroy" to the main window.
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Packing of the global widgets hscale, vscale, and scrollbar
      (gtk-container-add window box1)
      (gtk-box-pack-start box1 box2)
      (gtk-box-pack-start box2 vscale)
      (gtk-box-pack-start box2 box3)
      (gtk-box-pack-start box3 hscale)
      (gtk-box-pack-start box3 scrollbar)
      ;; A check button to control whether the value is displayed or not.
      (let ((box (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (button (make-instance 'gtk-check-button
                                   :label "Display value on scale widget"
                                   :active t)))
        (g-signal-connect button "toggled"
           (lambda (widget)
             (setf (gtk-scale-draw-value hscale)
                   (gtk-toggle-button-active widget))
             (setf (gtk-scale-draw-value vscale)
                   (gtk-toggle-button-active widget))))
        (gtk-box-pack-start box button)
        (gtk-box-pack-start box1 box))
      ;; A ComboBox to change the position of the value.
      (let ((box (make-instance 'gtk-box
                                :orientation :horizontal
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (combo (make-instance 'gtk-combo-box-text)))
        (gtk-combo-box-text-append-text combo "TOP")
        (gtk-combo-box-text-append-text combo "BOTTOM")
        (gtk-combo-box-text-append-text combo "LEFT")
        (gtk-combo-box-text-append-text combo "RIGHT")
        (setf (gtk-combo-box-active combo) 0)
        (g-signal-connect combo "changed"
           (lambda (widget)
             (let ((pos (gtk-combo-box-text-get-active-text widget)))
               (format t "type      : ~A~%"
                         (g-type-from-instance (pointer widget)))
               (format t "active is : ~A~%"
                         (gtk-combo-box-active widget))
               (setq pos (if pos (intern pos :keyword) :top))
               (setf (gtk-scale-value-pos hscale) pos)
               (setf (gtk-scale-value-pos vscale) pos))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scale value position")
                            :expand nil :fill nil :padding 0)
        (gtk-box-pack-start box combo)
        (gtk-box-pack-start box1 box))
      ;; Create a scale to change the digits of hscale and vscale.
      (let* ((box (make-instance 'gtk-box
                                 :orientation :horizontal
                                 :homogeneous nil
                                 :spacing 12
                                 :border-width 12))
             (adj (make-instance 'gtk-adjustment
                                 :value 1.0
                                 :lower 0.0
                                 :upper 5.0
                                 :step-increment 1.0
                                 :page-increment 1.0
                                 :page-size 0.0))
             (scale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 0
                                   :adjustment adj)))
        (g-signal-connect adj "value-changed"
           (lambda (adjustment)
             (setf (gtk-scale-digits hscale)
                   (truncate (gtk-adjustment-value adjustment)))
             (setf (gtk-scale-digits vscale)
                   (truncate (gtk-adjustment-value adjustment)))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scale Digits:")
                            :expand nil :fill nil)
        (gtk-box-pack-start box scale)
        (gtk-box-pack-start box1 box))
      ;; Another hscale for adjusting the page size of the scrollbar
      (let* ((box (make-instance 'gtk-box
                                 :orientation :horizontal
                                 :homogeneous nil
                                 :spacing 12
                                 :border-width 12))
             (adj (make-instance 'gtk-adjustment
                                 :value 1.0
                                 :lower 1.0
                                 :upper 101.0
                                 :step-increment 1.0
                                 :page-increment 1.0
                                 :page-size 0.0))
             (scale (make-instance 'gtk-scale
                                   :orientation :horizontal
                                   :digits 0
                                   :adjustment adj)))
        (g-signal-connect adj "value-changed"
           (lambda (adjustment)
             (setf (gtk-adjustment-page-size adj1)
                   (gtk-adjustment-page-size adjustment))
             (setf (gtk-adjustment-page-increment adj1)
                   (gtk-adjustment-page-increment adjustment))))
        (gtk-box-pack-start box
                            (make-instance 'gtk-label
                                           :label "Scrollbar Page Size:")
                            :expand nil :fill nil)
        (gtk-box-pack-start box scale)
        (gtk-box-pack-start box1 box))
      ;; Add a separator
      (gtk-box-pack-start box1
                          (make-instance 'gtk-separator
                                         :orientation :horizontal)
                          :expand nil :fill t)
      ;; Create the quit button.
      (let ((box (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12
                                :border-width 12))
            (button (make-instance 'gtk-button :label "Quit")))
        (g-signal-connect button "clicked"
                          (lambda (button)
                            (declare (ignore button))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start box button)
        (gtk-box-pack-start box1 box :expand nil))
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Layout_Widgets">
  <title>Layout Widgets</title>
  <section id="Alignment_Widget">
   <sectioninfo>
    <itermset>
     <indexterm zone="Alignment_Widget">
      <primary>GtkAlignment</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment, gtk-alignment</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-new, gtk-alignment-new</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-set, gtk-alignment-set</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-get-padding, gtk-alignment-get-padding</primary>
     </indexterm>
     <indexterm zone="Alignment_Widget">
      <primary>alignment-set-padding, gtk-alignment-set-padding</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Alignment Widget</title>
   <figure id="figure-alignment-widget">
    <title>Alignment Widget</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/alignment302x329.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The alignment container <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> allows to place
    a widget within its window at a position and size relative to the size of the
    <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container itself.  For example, it can
    be very useful for centering a widget within the window.
   </para>
   <para>
    The <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container has the four properties
    <code>xalign</code>, <code>yalign</code>, <code>xscale</code>, and <code>yscale</code>.  The properties
    are floating point numbers.  The align settings are used to place the child widget within the available
    area.  The values range from <code>0.0</code> (top or left) to <code>1.0</code> (bottom or right).  Of
    course, if the scale settings are both set to <code>1.0</code>, the alignment settings have no effect.
    The scale settings are used to specify how much the child widget should expand to fill the space
    allocated to the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>.  The values can range
    from <code>0.0</code> (meaning the child does not expand at all) to <code>1.0</code> (meaning the child
    expands to fill all of the available space).
   </para>
   <para>
    The properties are set when creating the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>
    container with the function <ulink url="&gtk-alignment-new;"><code>gtk-alignment-new</code></ulink>.  For
    an existing <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container the properties can
    be set with the function <ulink url="&gtk-alignment-set;"><code>gtk-alignment-set</code></ulink>. A child
    widget can be added to the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container
    using the function &gtk-container-add;.
   </para>
   <para>
    In addition, the <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink> container has the
    properties <code>top-padding</code>, <code>bottom-padding</code>, <code>left-padding</code>, and
    <code>right-padding</code>.  These properties control how many space is added to the sides of the widget.
    The functions <ulink url="&gtk-alignment-set-padding;"><code>gtk-alignment-set-padding</code></ulink>
    and <ulink url="&gtk-alignment-get-padding;"><code>gtk-alignment-get-padding</code></ulink> are used to
    set or to retrieve the values of the padding properties.
   </para>
   <note>
    <para>
     Note that the desired effect can in most cases be achieved by using the "halign", "valign" and "margin"
     properties on the child widget, so <ulink url="&gtk-alignment;"><code>gtk-alignment</code></ulink>
     should not be used in new code.
    </para>
   </note>
   <example id="example-alignment-widget">
    <title>Alignment Widget</title>
    <programlisting>
(defun example-alignment ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Alignment"
                                 :border-width 12
                                 :width-request 300
                                 :height-request 300))
          (grid (make-instance 'gtk-grid
                                :column-spacing 12
                                :column-homogeneous t
                                :row-spacing 12
                                :row-homogeneous t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 0, yalign: 0"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 0.00
                                      :yalign 0.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 0 1 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 0, yalign: 1"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 0.00
                                      :yalign 1.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 1 1 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 1, yalign: 0"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 1.00
                                      :yalign 0.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 0 2 1 1))
      (let ((frame (make-instance 'gtk-frame
                                  :label "xalign: 1, yalign: 1"))
            (button (make-instance 'gtk-button
                                   :label "Button"))
            (alignment (make-instance 'gtk-alignment
                                      :xalign 1.00
                                      :yalign 1.00
                                      :xscale 0.50
                                      :yscale 0.25)))
        (gtk-alignment-set-padding alignment 6 6 6 6)
        (gtk-container-add alignment button)
        (gtk-container-add frame alignment)
        (gtk-grid-attach grid frame 1 2 1 1))
      (gtk-container-add window grid)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Fixed_Container">
   <sectioninfo>
    <itermset>
     <indexterm zone="Fixed_Container">
      <primary>GtkFixed</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>fixed, gtk-fixed</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>fixed-new, gtk-fixed-new</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>fixed-put, gtk-fixed-put</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>fixed-move, gtk-fixed-move</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>GdkRectanble</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>rectangle, gdk-rectangle</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>rectangle-height, gdk-rectangle-height</primary>
     </indexterm>
     <indexterm zone="Fixed_Container">
      <primary>rectangle-width, gdk-rectangle-width</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Fixed Container</title>
   <figure id="figure-fixed">
    <title>Fixed Container</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/fixed302x254.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink> widget is a container widget which allows to
    place child widgets at a fixed position within the container, relative to the upper left hand corner.
    The position of the child widgets can be changed dynamically.  Only a few functions are associated with
    the <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink> widget like <ulink url="&gtk-fixed-new;">
    <code>gtk-fixed-new</code></ulink>, <ulink url="&gtk-fixed-put;"><code>gtk-fixed-put</code></ulink>, and
    <ulink url="&gtk-fixed-move;"><code>gtk-fixed-move</code></ulink>.
   </para>
   <para>
    The function <ulink url="&gtk-fixed-new;"><code>gtk-fixed-new</code></ulink> creates a new
    <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink> widget.  The function
    <ulink url="&gtk-fixed-put;"><code>gtk-fixed-put</code></ulink> places a widget in the container fixed at
    the position specified by the arguments <code>x</code> and <code>y</code>.  The function
    <ulink url="&gtk-fixed-move;"><code>gtk-fixed-move</code></ulink> allows the specified widget to be moved
    to a new position.
   </para>
   <para>
    For most applications, you should not use this container.  It keeps you from having to learn about the
    other GTK+ containers, but it results in broken applications.  With <ulink url="&gtk-fixed;">
    <code>gtk-fixed</code></ulink>, the following things will result in truncated text, overlapping widgets,
    and other display bugs:
   </para>
   <itemizedlist>
    <listitem>
      <para>Themes, which may change widget sizes.</para>
    </listitem>
    <listitem>
     <para>
      Fonts other than the one you used to write the application will of course change the size of widgets
      containing text; keep in mind that users may use a larger font because of difficulty reading the
      default, or they may be using Windows or the framebuffer port of GTK+, where different fonts are
      available.
     </para>
    </listitem>
    <listitem>
     <para>
      Translation of text into other languages changes its size.  Also, display of non-English text will use
      a different font in many cases.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    In addition, the fixed widget can not properly be mirrored in right-to-left languages such as Hebrew and
    Arabic. i.e. normally GTK+ will flip the interface to put labels to the right of the thing they label,
    but it can't do that with <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink>.  So your application
    will not be usable in right-to-left languages.
   </para>
   <para>
    Finally, fixed positioning makes it kind of annoying to add/remove GUI elements, since you have to
    reposition all the other elements.  This is a long-term maintenance problem for your application.
   </para>
   <para>
    If you know none of these things are an issue for your application, and prefer the simplicity of
    <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink>, by all means use the widget. But you
    should be aware of the tradeoffs.
   </para>
   <para>
    The following example illustrates how to use a fixed container. In this example three buttons are put
    into the fixed widget at random positions. A click on a button moves the button to a new random position.
    To retrieve the size of the fixed widget the function <ulink url="&gtk-widget-allocation;">
    <code>gtk-widget-allocation</code></ulink> is used, which returns a rectangle of type
    <ulink url="&gdk-rectangle;"><code>gdk-rectangle</code></ulink>. The width and the height of the fixed
    widget are then get with the functions <ulink url="&gdk-rectangle-width;">
    <code>gdk-rectangle-width</code></ulink> and <ulink url="&gdk-rectangle-height;">
    <code>gdk-rectangle-height</code></ulink>.
   </para>
   <example id="example-fixed">
    <title>Fixed Container</title>
    <programlisting>
(defun move-button (button fixed)
  (let* ((allocation (gtk-widget-allocation fixed))
         (width (- (gdk-rectangle-width allocation) 20))
         (height (- (gdk-rectangle-height allocation) 10)))
    (gtk-fixed-move fixed button (random width) (random height))))

(defun example-fixed ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Fixed Container"
                                 :default-width 300
                                 :default-height 200
                                 :border-width 12))
          (fixed (make-instance 'gtk-fixed)))
      (g-signal-connect window "destroy"
                        (lambda (window)
                          (declare (ignore window))
                          (leave-gtk-main)))
      (gtk-container-add window fixed)
      (dotimes (i 3)
        (let ((button (gtk-button-new-with-label "Press me")))
          (g-signal-connect button "clicked"
                            (lambda (widget)
                              (move-button widget fixed)))
          (gtk-fixed-put fixed button (random 250) (random 150))))
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Layout_Container">
   <sectioninfo>
    <itermset>
     <indexterm zone="Layout_Container">
      <primary>GtkLayout</primary>
     </indexterm>
     <indexterm zone="Layout_Container">
      <primary>layout, gtk-layout</primary>
     </indexterm>
     <indexterm zone="Layout_Container">
      <primary>layout-new, gtk-layout-new</primary>
     </indexterm>
     <indexterm zone="Layout_Container">
      <primary>layout-move, gtk-layout-move</primary>
     </indexterm>
     <indexterm zone="Layout_Container">
      <primary>layout-put, gtk-layout-put</primary>
     </indexterm>
     <indexterm zone="Layout_Container">
      <primary>layout-size, gtk-layout-size</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Layout Container</title>
   <para>
    The layout container <ulink url="&gtk-layout;"><code>gtk-layout</code></ulink> is similar to the fixed
    container <ulink url="&gtk-fixed;"><code>gtk-fixed</code></ulink> except that it implements an infinite
    (where infinity is less than 2^32) scrolling area.  The X window system has a limitation where windows
    can be at most 32767 pixels wide or tall.  The layout container gets around this limitation by doing some
    exotic stuff using window and bit gravities, so that you can have smooth scrolling even when you have
    many child widgets in your scrolling area.
   </para>
   <para>
    A layout container is created using <ulink url="&gtk-layout-new;"><code>gtk-layout-new</code></ulink>
    which accepts the optional arguments <code>hadjustment</code> and <code>vadjustment</code> to specify
    adjustment objects that the layout widget will use for its scrolling.
   </para>
   <para>
    Widgets can be added and moved in the Layout container using the functions <ulink url="&gtk-layout-put;">
    <code>gtk-layout-put</code></ulink> and <ulink url="&gtk-layout-move;">
    <code>gtk-layout-move</code></ulink>.  The size of the layout container can be set using the function
    <ulink url="&gtk-layout-size;"><code>gtk-layout-size</code></ulink>.
   </para>
   <para>
    <ulink url="&gtk-layout;"><code>gtk-layout</code></ulink> implements the interface
    <ulink url="&gtk-scrollable;"><code>gtk-scrollable</code></ulink>.  Therefore, for manipulating the
    horizontal and vertical adjustment widgets the functions <ulink url="&gtk-scrollable-hadjustment;">
    <code>gtk-scrollable-hadjustment</code></ulink> and <ulink url="&gtk-scrollable-vadjustment;">
    <code>gtk-scrollable-vadjustment</code></ulink> are available.
   </para>
  </section>

  <section id="Frames">
   <sectioninfo>
    <itermset>
     <indexterm zone="Frames">
      <primary>GtkFrame</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>frame, gtk-frame</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>frame-new, gtk-frame-new</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>frame-label, gtk-frame-label</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>frame-set-label-align, gtk-frame-set-label-align</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>GtkShadowType</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>shadow-type, gtk-shadow-type</primary>
     </indexterm>
     <indexterm zone="Frames">
      <primary>frame-shadow-type, gtk-frame-shadow-type</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Frames</title>
   <figure id="figure-frame">
    <title>Frame Widget</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/frame252x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Frames can be used to enclose one or a group of widgets with a box which can optionally be labelled.
    The position of the label and the style of the box can be altered to suit.
   </para>
   <para>
    A frame can be created with <code>(make-instance 'gtk-frame)</code> or the function
    <ulink url="&gtk-frame-new;"><code>gtk-frame-new</code></ulink>.  The label is by default placed in the
    upper left hand corner of the frame. A value of <code>NIL</code> for the label argument will result in
    no label being displayed.  The text of the label can be changed using the function
    <ulink url="&gtk-frame-label;"><code>gtk-frame-label</code></ulink>.
   </para>
   <para>
    The position of the label can be changed using the function <ulink url="&gtk-frame-set-label-align;">
    <code>gtk-frame-set-label-align</code></ulink> which has the arguments <code>xalign</code> and
    <code>yalign</code> which take values between 0.0 and 1.0. <code>xalign</code> indicates the position of
    the label along the top horizontal of the frame.  <code>yalign</code> indicates the vertival position of
    the label.  With a value of 0.5 of <code>yalign</code> the label is positioned in the middle of the line
    of the frame.  The default value of <code>xalign</code> is 0.0 which places the label at the left hand
    end of the frame.
   </para>
   <para>
    The function <ulink url="&gtk-frame-shadow-type;"><code>gtk-frame-shadow-type</code></ulink> alters the
    style of the box that is used to outline the frame.  The second argument is a keyword of the enumeration
    type <ulink url="&gtk-shadow-type;"><code>gtk-shadow-type</code></ulink>.
   </para>
   <para>
    The figure <link linkend="figure-frame">Frame</link> illustrates the use of the frame widget.  The code
    of this example is shown in <link linkend="example-frame">Frame</link>.
   </para>
   <example id="example-frame">
    <title>Frame Widget</title>
    <programlisting>
(defun example-frame ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Frame"
                                 :default-width 250
                                 :default-height 200
                                 :border-width 12))
          (frame (make-instance 'gtk-frame
                                :label "Gtk Frame Widget"
                                :label-xalign 1.0
                                :label-yalign 0.5
                                :shadow-type :etched-in)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window frame)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Aspect_Frames">
   <sectioninfo>
    <itermset>
     <indexterm zone="Aspect_Frames">
      <primary>GtkAspectFrame</primary>
     </indexterm>
     <indexterm zone="Aspect_Frames">
      <primary>aspect-frame, gtk-aspect-frame</primary>
     </indexterm>
     <indexterm zone="Aspect_Frames">
      <primary>aspect-frame-new, gtk-aspect-frame-new</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Aspect Frames</title>
   <figure id="figure-aspect-frame">
    <title>Aspect Frame Container</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/aspect-frame302x279.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-aspect-frame;"><code>gtk-aspect-frame</code></ulink> aspect frame container is like
    a frame container, except that it also enforces the aspect ratio (that is, the ratio of the width to the
    height) of the child widget to have a certain value, adding extra space if necessary.  This is useful,
    for instance, if you want to preview a larger image.  The size of the preview should vary when the user
    resizes the window, but the aspect ratio needs to always match the original image.
   </para>
   <para>
    To create a new aspect frame use <code>(make-instance 'gtk-aspect-frame)</code> or the function
    <ulink url="&gtk-aspect-frame-new;"><code>gtk-aspect-frame-new</code></ulink>.  The arguments
    <code>xalign</code> and <code>yalign</code> specify alignment as with alignment containers.  If the
    property <code>obey-child</code> is <emphasis>true</emphasis>, the aspect ratio of a child widget will
    match the aspect ratio of the ideal size it requests.  Otherwise, it is given by <code>ratio</code>.
   </para>
   <para>
    The options of an existing aspect frame can be changed with the function
    <ulink url="&gtk-aspect-frame-set;"><code>gtk-aspect-frame-set</code></ulink>.
   </para>
   <para>
    As an example, the following program uses an aspect frame widget to present a drawing area whose aspect
    ratio will always be 2:1, no matter how the user resizes the top-level window.
   </para>
   <example id="example-aspect-frame">
    <title>Aspect Frame Container</title>
    <programlisting>
(defun example-aspect-frame ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Aspect Frame"
                                 :default-width 300
                                 :default-height 250
                                 :border-width 12))
          (frame (make-instance 'gtk-aspect-frame
                                :label "2 x 1"
                                :xalign 0.5
                                :yalign 0.5
                                :ratio 2
                                :obey-child nil))
          (area (make-instance 'gtk-drawing-area
                               :width-request 200
                               :hight-request 200)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window frame)
      (gtk-container-add frame area)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Paned_Window_Widgets">
   <sectioninfo>
    <itermset>
     <indexterm zone="Paned_Window_Widgets">
      <primary>GtkPaned</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned, gtk-paned</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-new, gtk-paned-new</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-pack1, gtk-paned-pack1</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-pack2, gtk-paned-pack2</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-add1, gtk-paned-add1</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-add2, gtk-paned-add2</primary>
     </indexterm>
     <indexterm zone="Paned_Window_Widgets">
      <primary>paned-set-position, gtk-paned-set-position</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Paned Window Widgets</title>
   <figure id="figure-paned-window">
    <title>Paned Window Widgets</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/paned-window302x279.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-paned;"><code>gtk-paned</code></ulink> has two panes, arranged either horizontally or
    vertically.  The division between the two panes is adjustable by the user by dragging a handle.
   </para>
   <para>
    A paned window can be created with the function <ulink url="&gtk-paned-new;">
    <code>gtk-paned-new</code></ulink>, which takes as an argument a value of type
    &gtk-orientation;.  With the value
    <code>:horizontal</code> a horizontal paned window is created, and with the value <code>:vertical</code>
    a vertical paned window.
   </para>
   <para>
    Child widgets are added to the panes of the widget with the functions <ulink url="&gtk-paned-pack1;">
    <code>gtk-paned-pack1</code></ulink> and <ulink url="&gtk-paned-pack2;">
    <code>gtk-paned-pack2</code></ulink> or the functions <ulink url="&gtk-paned-add1;">
    <code>gtk-paned-add1</code></ulink> and <ulink url="&gtk-paned-add2;">
    <code>gtk-paned-add2</code></ulink>.  The division between the two children is set by default from the
    size requests of the children, but it can be adjusted by the user.
   </para>
   <para>
    A paned widget draws a separator between the two child widgets and a small handle that the user can drag
    to adjust the division.  It does not draw any relief around the children or around the separator.  (The
    space in which the separator is called the gutter.)  Often, it is useful to put each child inside a
    <ulink url="&gtk-frame;"><code>gtk-frame</code></ulink> with the shadow type set to <code>:in</code> so
    that the gutter appears as a ridge.  No separator is drawn if one of the children is missing.
   </para>
   <para>
    Each child has two options that can be set, <code>resize</code> and <code>shrink</code>.  If
    <code>resize</code> is <code>T</code>, then when the <code>GtkPaned</code> is resized, that child will
    expand or shrink along with the paned widget. If <code>shrink</code> is <code>T</code>, then that child
    can be made smaller than its requisition by the user.  Setting <code>shrink</code> to <code>NIL</code>
    allows the application to set a minimum size.  If <code>resize</code> is <code>NIL</code> for both
    children, then this is treated as if resize is <code>T</code> for both children.
   </para>
   <para>
    The application can set the position of the slider as if it were set by the user, by calling
    <ulink url="&gtk-paned-position;"><code>gtk-paned-position</code></ulink>.
   </para>
   <para>
    The figure <link linkend="figure-paned-window">Paned Window</link> shows a simple example.  The
    corresponding code is shown in example <link linkend="example-paned-window">Paned Window</link>.
   </para>
<!-- TODO: The example is very simple. It is not taken from the GTK+ 2.0 Tutorial. -->
   <example id="example-paned-window">
    <title>Paned Window Widgets</title>
    <programlisting>
(defun example-paned-window ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Paned Window"
                                 :border-width 12))
          (paned (make-instance 'gtk-paned
                                :orientation :vertical))
          (frame1 (make-instance 'gtk-frame :label "Window 1"))
          (frame2 (make-instance 'gtk-frame :label "Window 2")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (setf (gtk-widget-size-request window) '(300 250))
      (gtk-container-add window paned)
      (gtk-paned-add1 paned frame1)
      (gtk-paned-add2 paned frame2)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Viewports">
   <sectioninfo>
    <itermset>
     <indexterm zone="Viewports">
      <primary>GtkViewport</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>viewport, gtk-viewport</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>viewport-new, gtk-viewport-new</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>scrolled-window-add-with-viewpot, gtk-scrolled-window-add-with-viewport</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>scrollable-hadjustment, gtk-scrollable-hadjustment</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>scrollable-vadjustment, gtk-scrollable-vadjustment</primary>
     </indexterm>
     <indexterm zone="Viewports">
      <primary>viewport-shadow-type, gtk-viewport-shadow-type</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Viewports</title>
   <para>
    The <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink> widget acts as an adaptor class,
    implementing scrollability for child widgets that lack their own scrolling capabilities.  Use
    <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink> to scroll child widgets such as
    &gtk-grid;, &gtk-box;, and so on.
   </para>
   <para>
    If a widget has native scrolling abilities, such as <ulink url="&gtk-text-view;">
    <code>gtk-text-view</code></ulink>, <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink>
    or <ulink url="&gtk-icon-view;"><code>gtk-icon-view</code></ulink>, it can be added to a
    <ulink url="&gtk-scrolled-window;"><code>gtk-scrolled-window</code></ulink> with the function
    &gtk-container-add;. If a widget does not, you must first add the widget to a <ulink url="&gtk-viewport;">
    <code>gtk-viewport</code></ulink>, then add the viewport to the scrolled window. The convenience function
    <ulink url="&gtk-scrolled-window-add-with-viewport;">
    <code>gtk-scrolled-window-add-with-viewport</code></ulink> does exactly this, so you can ignore the
    presence of the viewport.
   </para>
   <para>
    The <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink> will start scrolling content only if
    allocated less than the child widget's minimum size in a given orientation.
   </para>
   <para>
    A viewport is created with the function <ulink url="&gtk-viewport-new;">
    <code>gtk-viewport-new</code></ulink>.  The function takes two arguments to specify the horizontal and
    vertical adjustments that the widget is to use when you create the widget.  It will create its own if you
    pass <code>NIL</code> as the value of the arguments.
   </para>
   <para>
    <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink> implement the interface
    <ulink url="&gtk-scrollable;"><code>gtk-scrollable</code></ulink>.  Therefore, the you can get and set
    the adjustments after the widget has been created using the one of the four functions
    <ulink url="&gtk-scrollable-hadjustment;"><code>gtk-scrollable-hadjustment</code></ulink>,
    and <ulink url="&gtk-scrollable-vadjustment;"><code>gtk-scrollable-vadjustment</code></ulink>.
   </para>
   <para>
    The only other viewport function is <ulink url="&gtk-viewport-shadow-type;">
    <code>gtk-viewport-shadow-type</code></ulink> used to alter its appearance.  The second argument is of
    type <ulink url="&gtk-shadow-type;"><code>gtk-shadow-type</code></ulink>.
   </para>
  </section>

  <section id="Scrolled_Windows">
   <title>Scrolled Windows</title>
   <figure id="figure-scrolled-window">
    <title>Scrolled Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/scrolled-window352x329.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-scrolled-window;"><code>gtk-scrolled-window</code></ulink> is a &gtk-bin; subclass:
    it is a container that accepts a single child widget.
    <ulink url="&gtk-scrolled-window;"><code>gtk-scrolled-window</code></ulink> adds scrollbars to the child
    widget and optionally draws a beveled frame around the child widget.
   </para>
   <para>
    The scrolled window can work in two ways.  Some widgets have native scrolling support; these widgets
    implement the <ulink url="&gtk-scrollable;"><code>gtk-scrollable</code></ulink> interface. Widgets with
    native scroll support include <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink>,
    <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink>, and <ulink url="&gtk-layout;">
    <code>gtk-layout</code></ulink>.
   </para>
   <para>
    For widgets that lack native scrolling support, the <ulink url="&gtk-viewport;">
    <code>gtk-viewport</code></ulink> widget acts as an adaptor class, implementing scrollability for child
    widgets that lack their own scrolling capabilities.  Use <ulink url="&gtk-viewport;">
    <code>gtk-viewport</code></ulink> to scroll child widgets such as &gtk-grid; &gtk-box;, and so on.
   </para>
   <para>
    If a widget has native scrolling abilities, it can be added to the <ulink url="&gtk-scrolled-window;">
    <code>gtk-scrolled-window</code></ulink> with the function &gtk-container-add;. If a widget does not, you
    must first add the widget to a <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink>, then add
    the <ulink url="&gtk-viewport;"><code>gtk-viewport</code></ulink> to the scrolled window. The convenience
    function <ulink url="&gtk-scrolled-window-add-with-viewport;">
    <code>gtk-scrolled-window-add-with-viewport</code></ulink> does exactly this, so you can ignore the
    presence of the viewport.
   </para>
   <para>
    The position of the scrollbars is controlled by the scroll adjustments.  See
    <ulink url="&gtk-adjustment;"><code>gtk-adjustment</code></ulink> for the fields in an adjustment - for
    <ulink url="&gtk-scrollbar;"><code>gtk-scrollbar</code></ulink>, used by
    <ulink url="&gtk-scrolled-window;"><code>gtk-scrolled-window</code></ulink>, the "value" field represents
    the position of the scrollbar, which must be between the "lower" field and "upper - page-size".  The
    "page-size" field represents the size of the visible scrollable area.  The "step-increment" and
    "page-increment" fields are used when the user asks to step down (using the small stepper arrows) or page
    down (using for example the PageDown key).
   </para>
   <para>
    If a <ulink url="&gtk-scrolled-window;"><code>gtk-scrolled-window</code></ulink> does not behave quite as
    you would like, or does not have exactly the right layout, it is very possible to set up your own
    scrolling with <ulink url="&gtk-scrollbar;"><code>gtk-scrollbar</code></ulink> and for example a
    &gtk-grid;.
   </para>
   <para>
    The function <ulink url="&gtk-scrolled-window-new;"><code>gtk-scrolled-window-new</code></ulink> is used
    to create a new scrolled window, where the first argument is the adjustment for the horizontal direction,
    and the second, the adjustment for the vertical direction.  These are almost always set to
    <code>NIL</code>.
   </para>
   <para>
    The function <ulink url="&gtk-scrolled-window-policy;"><code>gtk-scrolled-window-policy</code></ulink>
    sets the policy to be used with respect to the scrollbars. The first argument is the scrolled window you
    wish to change. The second argument is a list with the policy for the horizontal scrollbar, and the
    policy for the vertical scrollbar.
   </para>
   <para>
    The policy is of the enumeration type <ulink url="&gtk-policy-type;"><code>gtk-policy-type</code></ulink>
    and may be one of <code>:automatic</code> or <code>:always</code>. <code>:automatic</code> will
    automatically decide whether you need scrollbars, whereas <code>:always</code> will always leave the
    scrollbars there. All possible values of <ulink url="&gtk-policy-type;">
    <code>gtk-policy-type</code></ulink> are listed in the table <link linkend="table-gtk-policy-type">
    GtkPolicyType</link>.
   </para>
   <table id="table-gtk-policy-type" frame='all'>
    <title>The values of the enumeration of type GtkPolicyType</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:always</code></entry>
       <entry valign="top">The scrollbar is always visible.</entry>
      </row>
      <row>
       <entry valign="top"><code>:automatic</code></entry>
       <entry valign="top">
        The scrollbar will appear and disappear as necessary. For example, when all of a GtkCList can not
        be seen.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:never</code></entry>
       <entry valign="top">The scrollbar will never appear.</entry>
      </row>
      <row>
       <entry valign="top"><code>:external</code></entry>
       <entry valign="top">
        Do not show a scrollbar, but do not force the size to follow the content. This can be used e.g. to
        make multiple scrolled windows share a scrollbar. Since 3.16
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Example <link linkend="example-scrolled-window">Scrolled Window</link> is a simple example that packs a
    table with 100 toggle buttons into a scrolled window.  Try playing with resizing the window.  You will
    notice how the scrollbars react.  You may also wish to use the <ulink url="&gtk-widget-size-request;">
    <code>gtk-widget-size-request</code></ulink> call to set the default size of the window or other widgets.
   </para>
   <example id="example-scrolled-window">
    <title>Scrolled Window</title>
    <programlisting>
(defun example-scrolled-window ()
  (within-main-loop
    (let ((window (make-instance 'gtk-dialog
                                 :type :toplevel
                                 :title "Example Scrolled Window"
                                 :border-width 0
                                 :width-request 350
                                 :height-request 300))
          (scrolled (make-instance 'gtk-scrolled-window
                                   :border-width 12
                                   :hscrollbar-policy :automatic
                                   :vscrollbar-policy :always))
          (table (make-instance 'gtk-table
                                :n-rows 10
                                :n-columns 10
                                :row-spacing 10
                                :column-spacing 10
                                :homogeneous nil)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-box-pack-start (gtk-dialog-get-content-area window) scrolled)
      (gtk-scrolled-window-add-with-viewport scrolled table)
      (dotimes (i 10)
        (dotimes (j 10)
          (gtk-table-attach table
                            (make-instance 'gtk-button
                                           :label
                                           (format nil "(&#x7e;d, &#x7e;d)" i j))
                            i (+ i 1) j (+ j 1))))
      (let ((button (make-instance 'gtk-button
                                   :label "Close"
                                   :can-default t)))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start (gtk-dialog-get-action-area window) button)
        (gtk-widget-grab-default button))
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Button_Boxes">
   <title>Button Boxes</title>
   <figure id="figure-button-box">
    <title>Button Boxes</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/button-box576x603.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    A button box should be used to provide a consistent layout of buttons throughout your application.  The
    layout/spacing can be altered by the programmer, or if desired, by the user to alter the 'feel' of a
    program to a small degree.
   </para>
   <para>
    <ulink url="&gtk-button-box-layout;"><code>gtk-button-box-layout</code></ulink> retrieve and alter the
    method used to spread the buttons in a button box across the container, respectively.
   </para>
   <para>
    The main purpose of <ulink url="&gtk-button-box;"><code>gtk-button-box</code></ulink> is to make sure the
    children have all the same size.  <ulink url="&gtk-button-box;"><code>gtk-button-box</code></ulink> gives
    all children the same size, but it does allow 'outliers' to keep their own larger size.  To force all
    children to be strictly the same size without exceptions, you can set the "homogeneous" property to
    <code>T</code>.
   </para>
   <para>
    To excempt individual children from homogeneous sizing regardless of their 'outlier' status, you can set
    the "non-homogeneous" child property.
   </para>
   <para>
    You can create a new button box with the function <ulink url="&gtk-button-box-new;">
    <code>gtk-button-box-new</code></ulink>, which creates a horizontal or vertical box depending on the
    argument <code>orientation</code> which takes the values <code>:horizontal</code> or
    <code>:vertical</code>, respectively.
   </para>
   <para>
    Buttons are added to a Button Box using the usual function &gtk-container-add;.
   </para>
   <para>
    <link linkend="example-button-box">Button Box</link> is an example that illustrates all the different 
    layout settings for button boxes.
   </para>
   <example id="example-button-box">
    <title>Button Boxes</title>
    <programlisting>
(defun create-bbox (orientation title spacing layout)
  (let ((frame (make-instance 'gtk-frame
                              :label title))
        (bbox (make-instance 'gtk-button-box
                             :orientation orientation
                             :border-width 6
                             :layout-style layout
                             :spacing spacing)))
    (gtk-container-add bbox
                       (make-instance 'gtk-button
                                      :label "OK"
                                      :always-show-image t
                                      :image
                                      (make-instance 'gtk-image
                                                     :icon-name "gtk-ok")))
  (gtk-container-add bbox
                     (make-instance 'gtk-button
                                    :label "Cancel"
                                    :always-show-image t
                                    :image
                                    (make-instance 'gtk-image
                                                   :icon-name "gtk-cancel")))
  (gtk-container-add bbox
                     (make-instance 'gtk-button
                                    :label "Help"
                                    :always-show-image t
                                    :image
                                    (make-instance 'gtk-image
                                                   :icon-name "gtk-help")))
  (gtk-container-add frame bbox)
  frame))

(defun example-button-box ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Button Box"
                                 :border-width 12))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 12))
          (hbox (make-instance 'gtk-box
                               :orientation :horizontal
                               :homogeneous nil
                               :spacing 12)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Create Horizontal Button Boxes
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :ypad 6
                                         :xalign 0
                                         :use-markup t
                                         :label
                                         "&#x3c;b>Horizontal Button Boxes&#x3c;/b>")
                          :expand nil
                          :fill nil)
      ;; Create the first Horizontal Box
      (gtk-box-pack-start vbox2
                          (create-bbox :horizontal
                                       "Spread (spacing 12)"
                                       12
                                       :spread))
      ;; Create the second Horizontal Box
      (gtk-box-pack-start vbox2
                          (create-bbox :horizontal
                                       "Edge (spacing 12)"
                                       12
                                       :edge))
      ;; Create the third Horizontal Box
      (gtk-box-pack-start vbox2
                          (create-bbox :horizontal
                                       "Start (spacing 6)"
                                       6
                                       :start))
      ;; Create the fourth Horizontal Box
      (gtk-box-pack-start vbox2
                          (create-bbox :horizontal
                                       "End (spacing 6)"
                                       6
                                       :end))
      (gtk-box-pack-start vbox1 vbox2)
      ;; Create Vertical Button Boxes
      (gtk-box-pack-start vbox1
                          (make-instance 'gtk-label
                                         :ypad 12
                                         :xalign 0
                                         :use-markup t
                                         :label
                                         "&#x3c;b>Vertical Button Boxes&#x3c;/b>")
                          :expand nil
                          :fill nil)
      ;; Create the first Vertical Box
      (gtk-box-pack-start hbox
                          (create-bbox :vertical
                                       "Spread (spacing 12)"
                                       12
                                       :spread))
      ;; Create the second Vertical Box
      (gtk-box-pack-start hbox
                          (create-bbox :vertical
                                       "Edge (spacing 12)"
                                       12
                                       :edge))
      ;; Create the third Vertical Box
      (gtk-box-pack-start hbox
                          (create-bbox :vertical
                                       "Start (spacing 6)"
                                       6
                                       :start))
      ;; Create the fourth Vertical Box
      (gtk-box-pack-start hbox
                          (create-bbox :vertical
                                       "End (spacing 6)"
                                       6
                                       :end))
      (gtk-box-pack-start vbox1 hbox)
      (gtk-container-add window vbox1)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Toolbar">
   <title>Toolbar</title>
   <para>
    A toolbar is created with a call to <ulink url="&gtk-toolbar-new;"><code>gtk-toolbar-new</code></ulink>.
   </para>
   <para>
    A toolbar can contain instances of a subclass of <ulink url="&gtk-tool-item;">
    <code>gtk-tool-item</code></ulink>.  To add a <ulink url="&gtk-tool-item;">
    <code>gtk-tool-item</code></ulink> to the a toolbar, use <ulink url="&gtk-toolbar-insert;">
    <code>gtk-toolbar-insert</code></ulink>.  To remove an item from the toolbar use the function
    &gtk-container-add;. To add a button to the toolbar, add an instance of
    <ulink url="&gtk-tool-button;"><code>gtk-tool-button</code></ulink>.
   </para>
   <para>
    Toolbar items can be visually grouped by adding instances of <ulink url="&gtk-separator-tool-item;">
    <code>gtk-separator-tool-item</code></ulink> to the toolbar. If the <ulink url="&gtk-toolbar;">
    <code>gtk-toolbar</code></ulink> child property "expand" is <emphasis>true</emphasis> and the property
    <code>"draw"</code> is set to <code>nil</code>, the effect is to force all following items to the end of
    the toolbar.
   </para>
   <para>
    Creating a context menu for the toolbar can be done by connecting to the "popup-context-menu" signal.
   </para>
  </section>

  <section id="Notebook">
   <title>Notebook</title>
   <figure id="figure-notebook">
    <title>Notebook</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/notebook347x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-notebook;"><code>gtk-notebook</code></ulink> widget is a
    &gtk-container; whose children are pages that can be
    switched between using tab labels along one edge.
   </para>
   <para>
    There are many configuration options for <ulink url="&gtk-notebook;"><code>gtk-notebook</code></ulink>.
    Among other things, you can choose on which edge the tabs appear (see
    <ulink url="&gtk-notebook-tab-pos;"><code>gtk-notebook-tab-pos</code></ulink>), whether, if there are
    too many tabs to fit the notebook should be made bigger or scrolling arrows added (see
    <ulink url="&gtk-notebook-scrollable;"><code>gtk-notebook-scrollable</code></ulink>), and whether there
    will be a popup menu allowing the users to switch pages (see <ulink url="&gtk-notebook-popup-enable;">
    <code>gtk-notebook-popup-enable</code></ulink>, <ulink url="&gtk-notebook-popup-disable;">
    <code>gtk-notebook-popup-disable</code></ulink>).
   </para>
   <example id="example-notebook">
    <title>Notebook</title>
    <programlisting>
(defun example-notebook ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Notebook"
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 200))
          (expander (make-instance 'gtk-expander
                                   :expanded t
                                   :label "Notebook"))
          (notebook (make-instance 'gtk-notebook
                                   :enable-popup t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (dotimes (i 5)
        (let ((page (make-instance 'gtk-label
                                   :label
                                   (format nil
                                           "Text for page ~A" i)))
              (tab-label (make-instance 'gtk-label
                                        :label (format nil "Tab &#x7e;A" i)))
              (tab-button (make-instance 'gtk-button
                                         :image
                                         (make-instance 'gtk-image
                                                        :stock
                                                        "gtk-close"
                                                        :icon-size 1)
                                         :relief :none)))
          (g-signal-connect tab-button "clicked"
             (let ((page page))
               (lambda (button)
                 (declare (ignore button))
                 (format t "Removing page ~A~%" page)
                 (gtk-notebook-remove-page notebook page))))
          (let ((tab-hbox (make-instance 'gtk-box
                                         :orientation :horizontal)))
            (gtk-box-pack-start tab-hbox tab-label)
            (gtk-box-pack-start tab-hbox tab-button)
            (gtk-widget-show-all tab-hbox)
            (gtk-notebook-add-page notebook page tab-hbox))))
      (gtk-container-add expander notebook)
      (gtk-container-add window expander)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Multiline_Text_Editor">
  <title>Multiline Text Editor</title>

  <section id="Text_Widget_Overview">
   <sectioninfo>
    <itermset>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextBuffer</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-buffer, gtk-text-buffer</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextView</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-view, gtk-text-view</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextTag</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-tag, gtk-text-tag</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextTagTable</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-tag-table, gtk-text-tag-table</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextIter</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-iter, gtk-text-iter</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>GtkTextMark</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-mark, gtk-text-mark</primary>
     </indexterm>
     <indexterm zone="Text_Widget_Overview">
      <primary>text-buffer-place-cursor, gtk-text-buffer-place-cursor</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Text Widget Overview</title>
   <para>
    GTK+ has an extremely powerful framework for multiline text editing.  The primary objects involved in the
    process are <ulink url="&gtk-text-buffer;"><code>gtk-text-buffer</code></ulink>, which represents the
    text being edited, and <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink>, a widget which
    can display a <ulink url="&gtk-text-buffer;"><code>gtk-text-buffer</code></ulink>.  Each buffer can be
    displayed by any number of views.
   </para>
   <para>
    One of the important things to remember about text in GTK+ is that it's in the UTF-8 encoding.  This
    means that one character can be encoded as multiple bytes.  Character counts are usually referred to as
    offsets, while byte counts are called indexes.  If you confuse these two, things will work fine with
    ASCII, but as soon as your buffer contains multibyte characters, bad things will happen.
   </para>
   <para>
    Text in a buffer can be marked with tags.  A tag is an attribute that can be applied to some range of
    text.  For example, a tag might be called "bold" and make the text inside the tag bold.  However, the tag
    concept is more general than that; tags don't have to affect appearance.  They can instead affect the
    behavior of mouse and key presses, "lock" a range of text so the user can't edit it, or countless other
    things.  A tag is represented by a <ulink url="&gtk-text-tag;"><code>gtk-text-tag</code></ulink> object.
    One <ulink url="&gtk-text-tag;"><code>gtk-text-tag</code></ulink> can be applied to any number of text
    ranges in any number of buffers.
   </para>
   <para>
    Each tag is stored in a <ulink url="&gtk-text-tag-table;"><code>gtk-text-tag-table</code></ulink>.  A tag
    table defines a set of tags that can be used together.  Each buffer has one tag table associated with
    it; only tags from that tag table can be used with the buffer.  A single tag table can be shared between
    multiple buffers, however.
   </para>
   <para>
    Tags can have names, which is convenient sometimes (for example, you can name your tag that makes things
    bold "bold"), but they can also be anonymous (which is convenient if you're creating tags on-the-fly).
   </para>
   <para>
    Most text manipulation is accomplished with iterators, represented by a <ulink url="&gtk-text-iter;">
    <code>gtk-text-iter</code></ulink>.  An iterator represents a position between two characters in the text
    buffer.  <ulink url="&gtk-text-iter;"><code>gtk-text-iter</code></ulink> is a struct designed to be
    allocated on the stack; it is guaranteed to be copiable by value and never contain any heap-allocated
    data.  Iterators are not valid indefinitely; whenever the buffer is modified in a way that affects the
    number of characters in the buffer, all outstanding iterators become invalid.  (Note that deleting 5
    characters and then reinserting 5 still invalidates iterators, though you end up with the same number of
    characters you pass through a state with a different number).
   </para>
   <para>
    Because of this, iterators can't be used to preserve positions across buffer modifications.  To preserve
    a position, the <ulink url="&gtk-text-mark;"><code>gtk-text-mark</code></ulink> object is ideal.  You can
    think of a mark as an invisible cursor or insertion point; it floats in the buffer, saving a position.
    If the text surrounding the mark is deleted, the mark remains in the position the text once occupied; if
    text is inserted at the mark, the mark ends up either to the left or to the right of the new text,
    depending on its gravity.  The standard text cursor in left-to-right languages is a mark with right
    gravity, because it stays to the right of inserted text.
   </para>
   <para>
    Like tags, marks can be either named or anonymous.  There are two marks built-in to
    <ulink url="&gtk-text-buffer;"><code>gtk-text-buffer</code></ulink>; these are named "insert" and
    "selection_bound" and refer to the insertion point and the boundary of the selection which is not the
    insertion point, respectively.  If no text is selected, these two marks will be in the same position.
    You can manipulate what is selected and where the cursor appears by moving these marks around.  If you
    want to place the cursor in response to a user action, be sure to use
    <ulink url="&gtk-text-buffer-place-cursor;"><code>gtk-text-buffer-place-cursor</code></ulink>, which
    moves both at once without causing a temporary selection (moving one then the other temporarily selects
    the range in between the old and new positions).
   </para>
   <para>
    Text buffers always contain at least one line, but may be empty (that is, buffers can contain zero
    characters).  The last line in the text buffer never ends in a line separator (such as newline); the
    other lines in the buffer always end in a line separator.  Line separators count as characters when
    computing character counts and character offsets.  Note that some Unicode line separators are represented
    with multiple bytes in UTF-8, and the two-character sequence "\r\n" is also considered a line separator.
   </para>
  </section>

  <section id="Simple_Multiline_Text_Widget">
   <sectioninfo>
    <itermset>
     <indexterm zone="Simple_Multiline_Text_Widget">
      <primary>text-buffer-new, gtk-text-buffer-new</primary>
     </indexterm>
     <indexterm zone="Simple_Multiline_Text_Widget">
      <primary>text-view-new-with-buffer, gtk-text-view-new-with-buffer</primary>
     </indexterm>
     <indexterm zone="Simple_Multiline_Text_Widget">
      <primary>text-view-buffer, gtk-text-view-buffer</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Simple Multiline Text Widget</title>
   <figure id="figure-simple-text-view">
    <title>Most Simple Text View</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/simple-text-view302x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The simplest usage of <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink> might look like in
    <link linkend="example-simple-text-view">Simple Text View</link>.  The output is shown in
    <link linkend="figure-simple-text-view">Simple Text View</link>.
   </para>
   <example id="example-simple-text-view">
    <title>Most Simple Text View</title>
    <programlisting>
(defun example-simple-text-view ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Simple Text View"
                                  :default-width 300))
           (view (make-instance 'gtk-text-view))
           (buffer (gtk-text-view-buffer view)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (setf (gtk-text-buffer-text buffer) "Hello, this is some text.")
      (gtk-container-add window view)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    In many cases it is also convenient to first create the buffer with <ulink url="&gtk-text-buffer-new;">
    <code>gtk-text-buffer-new</code></ulink>, then create a widget for that buffer with
    <ulink url="&gtk-text-view-new-with-buffer;"><code>gtk-text-view-new-with-buffer</code></ulink>.  Or you
    can change the buffer the widget displays after the widget is created with
    <ulink url="&gtk-text-view-buffer;"><code>gtk-text-view-buffer</code></ulink>.
   </para>
  </section>

  <section id="Formatted_Text_in_Text_Widget">
   <sectioninfo>
    <itermset>
     <indexterm zone="Formatted_Text_in_Text_Widget">
      <primary>widget-override-font, gtk-widget-override-font</primary>
     </indexterm>
     <indexterm zone="Formatted_Text_in_Text_Widget">
      <primary>text-view-tabs, gtk-text-view-tabs</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Formatted Text in Text Widget</title>
   <figure id="figure-text-view-attributes">
    <title>Changing Text Attributes of a Text View</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-attributes352x229.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    There are two ways to affect text attributes in <ulink url="&gtk-text-view;">
    <code>gtk-text-view</code></ulink>.  You can change the default attributes for a given
    <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink>, and you can apply tags that change the
    attributes for a region of text.  For text features that come from the theme - such as font and
    foreground color - use standard &gtk-widget; functions such
    as <ulink url="&gtk-widget-override-font;"><code>gtk-widget-override-font</code></ulink>.  For other
    attributes there are dedicated methods on <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink>
    such as <ulink url="&gtk-text-view-tabs;"><code>gtk-text-view-tabs</code></ulink>.
   </para>
   <example id="example-text-view-attributes">
    <title>Changing Text Attributes of a Text View</title>
    <programlisting>
(defun example-text-view-attributes ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Text View Attributes"
                                  :default-width 350))
           (view (make-instance 'gtk-text-view))
           (buffer (gtk-text-view-buffer view)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (setf (gtk-text-buffer-text buffer) "Hello, this is some text.")
      ;; Change default font throughout the widget
      (gtk-widget-override-font
                             view
                             (pango-font-description-from-string "Serif 20"))
      ;; Change default color throughout the widget
      (gtk-widget-override-color view
                                 :normal
                                 (gdk-rgba-parse "red"))
      ;; Change left margin throughout the widget
      (setf (gtk-text-view-left-margin view) 30)
      ;; Use a tag to change the color for just one part of the widget
      (let ((tag (make-instance 'gtk-text-tag
                                :name "blue_foreground"
                                :foreground "blue"))
            (start (gtk-text-buffer-get-iter-at-offset buffer 7))
            (end (gtk-text-buffer-get-iter-at-offset buffer 12)))
        ;; Add the tag to the tag table of the buffer
        (gtk-text-tag-table-add (gtk-text-buffer-tag-table buffer) tag)
        ;; Apply the tag to a region of the text in the buffer
        (gtk-text-buffer-apply-tag buffer tag start end))
      ;; Add the view to the window and show all
      (gtk-container-add window view)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>

   <section id="More_about_Tags">
    <title>More about Tags</title>
    <para>
     Tag objects are associated with a buffer and are created using the function
     <ulink url="&gtk-text-buffer-create-tag;"><code>gtk-text-buffer-create-tag</code></ulink>.  Tags can be
     optionally associated with a name <code>tag-name</code>.  Thus, the tag could be referred using the
     returned pointer or using the <code>tag-name</code>.  For anonymous tags, <code>nil</code> is passed
     to <code>tag-name</code>.  The group of properties represented by this tag is listed as name/value pairs
     after the <code>tag-name</code>.  The list of property/value pairs is terminated with a
     <code>NULL</code> pointer.  "style", "weight", "editable", "justification" are some common property
     names.  The following table lists their meaning and assignable values.
    </para>
    <para>
     See the GTK+ manual <ulink url="http://crategus.com/books/cl-cffi-gtk">
     www.crategus.com/books/cl-cffi-gtk</ulink>, for a complete list of properties and their corresponding
     values.
    </para>
    <para>
     The created tag can then be applied to a range of text using the functions
     <ulink url="&gtk-text-buffer-apply-tag;"><code>gtk-text-buffer-apply-tag</code></ulink> and
     <ulink url="&gtk-text-buffer-apply-tag-by-name;"><code>gtk-text-buffer-apply-tag-by-name</code></ulink>.
     The first function specifies the tag to be applied by a tag object and the second function specifies the
     tag by it's name.  The range of text over with the tag is to applies is specified by the start and end
     iters.  Below is an extension of the previous example, that has a tool-bar to apply different tags
     to selected regions of text.
    </para>
    <figure id="figure-text-tags">
     <title>Searching text in a text view</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-tags.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-text-tags">
     <title>Applying tags</title>
     <programlisting>
(defun on-button-clicked (buffer tag)
  (multiple-value-bind (start end)
      (gtk-text-buffer-get-selection-bounds buffer)
    (gtk-text-buffer-apply-tag-by-name buffer tag start end)))

(defun example-text-view-tags ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :title "Multiline Text Input"
                                  :type :toplevel
                                  :default-width 300
                                  :default-height 200))
           (vbox (make-instance 'gtk-grid
                                :orientation :vertical))
           (bbox (make-instance 'gtk-grid
                                :orientation :horizontal))
           (text-view (make-instance 'gtk-text-view
                                     :hexpand t
                                     :vexpand t))
           (buffer (gtk-text-view-buffer text-view)))
      (g-signal-connect window "destroy"
                               (lambda (widget)
                                 (declare (ignore widget))
                                 (leave-gtk-main)))
      (gtk-container-add vbox bbox)
      (gtk-container-add vbox text-view)
      (setf (gtk-text-buffer-text buffer) "Hello World Text View")
      ;; Create tags associated with the buffer.
      (gtk-text-tag-table-add (gtk-text-buffer-tag-table buffer)
                              (make-instance 'gtk-text-tag
                                             :name "bold"
                                             :weight 700)) ; :bold
      (gtk-text-tag-table-add (gtk-text-buffer-tag-table buffer)
                              (make-instance 'gtk-text-tag
                                             :name "italic"
                                             :style :italic))
      (gtk-text-tag-table-add (gtk-text-buffer-tag-table buffer)
                              (make-instance 'gtk-text-tag
                                             :name "font"
                                             :font "fixed"))
      ;; Create button for bold.
      (let ((button (make-instance 'gtk-button :label "Bold")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (on-button-clicked buffer "bold")))
        (gtk-container-add bbox button))
      ;; Create button for italic.
      (let ((button (make-instance 'gtk-button :label "Italic")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (on-button-clicked buffer "italic")))
        (gtk-container-add bbox button))
      ;; Create button for fixed font.
      (let ((button (make-instance 'gtk-button :label "Font Fixed")))
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             (on-button-clicked buffer "font")))
        (gtk-container-add bbox button))
      ;; Create the close button.
      (let ((button (make-instance 'gtk-button :label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-container-add vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

<!-- TODO: gtk-text-buffer-insert-with-tags is not implemented -->

   <section id="More_Functions_for_Applying_and_Removing_tags">
    <title>More Functions for Applying and Removing tags</title>
    <para>
     In the previous section, the function <ulink url="&gtk-text-buffer-insert;">
     <code>gtk-text-buffer-insert</code></ulink> was introduced.  A variant
     <ulink url="&gtk-text-buffer-insert-with-tags;"><code>gtk-text-buffer-insert-with-tags</code></ulink>
     of this function can be used to insert text with tags applied.
    </para>
    <para>
     The tags argument list is terminated by a <code>NULL</code> pointer. The <code>_by_name</code> suffixed
     variants are also available, in which the tags to be applied are specified by the tag names.  Tags
     applied to a range of text can be removed by using the function
     <ulink url="&gtk-text-buffer-remove-tag;"><code>gtk-text-buffer-remove-tag</code></ulink>.
    </para>
    <para>
     This function also has the <code>_by_name</code> prefixed variant.  All tags on a range of text can be
     removed in one go using the function <ulink url="&gtk-text-buffer-remove-all-tags;">
     <code>gtk-text-buffer-remove-all-tags</code></ulink>.
    </para>
   </section>

   <section id="Formatting_the_Entire_Widget">
    <title>Formatting the Entire Widget</title>
    <para>
     The above functions apply attributes to portions of text in a buffer.  If attributes have to be applied
     for the entire <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink> widget, the
     <code>(setf gtk-text-view-*)</code> functions can be used.  For example, the function
     <ulink url="&gtk-text-view-editable;"><code>gtk-text-view-editable</code></ulink> makes
     <code>text-view</code> editable/non-editable.
    </para>
    <para>
     See the GTK+ API documentation <ulink url="http://crategus.com/books/cl-cffi-gtk">
     www.crategus.com/books/cl-cffi-gtk</ulink> for a complete list of available functions.  The attributes
     set by these functions, on the entire widget, can be overridden by applying tags to portions of text in
     the buffer.
    </para>
   </section>
  </section>

  <section id="Cut_Copy_and_Paste">
   <title>Cut, Copy and Paste</title>
   <para>
   </para>
  </section>

  <section id="Searching">
   <sectioninfo>
    <itermset>
     <indexterm zone="Searching">
      <primary>text-iter-forward-search, gtk-text-iter-forward-search</primary>
     </indexterm>
     <indexterm zone="Searching">
      <primary>text-iter-backward-search, gtk-text-iter-backward-search</primary>
     </indexterm>
     <indexterm zone="Searching">
      <primary>text-iter-search, gtk-text-iter-search</primary>
     </indexterm>
     <indexterm zone="Searching">
      <primary>text-buffer-selection-bounds, gtk-text-buffer-selections-bounds</primary>
     </indexterm>
     <indexterm zone="Searching">
      <primary>text-buffer-select-range, gtk-text-buffer-select-range</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Searching</title>
   <para>
    The functions <ulink url="&gtk-text-iter-forward-search;">
    <code>gtk-text-iter-forward-search</code></ulink> and <ulink url="&gtk-text-iter-backward-search;">
    <code>gtk-text-iter-backward-search</code></ulink> with the arguments <code>iter</code>,
    <code>str</code>, <code>flags</code>, <code>limit</code> can be used to search for a given text within a
    buffer.  Both functions return as the first value a boolean to indicate wether the search was sucessful.
    If this is the case the second and third values contain the iterators <code>match-start</code> and
    <code>match-end</code>.
   </para>
   <para>
    The function <ulink url="&gtk-text-iter-forward-search;">
    <code>gtk-text-iter-forward-search</code></ulink> searches for <code>str</code> starting from
    <code>iter</code> in the forward direction.  The start and end iterators of the first matched string are
    return as the values <code>match-start</code> and <code>match-end</code>.  The search is limited to the
    iterator <code>limit</code>, if specified.  The function returns <code>nil</code>, if no match is found.
    The function <ulink url="&gtk-text-iter-backward-search;">
    <code>gtk-text-iter-backward-search</code></ulink> is same as
    <ulink url="&gtk-text-iter-forward-search;"><code>gtk-text-iter-forward-search</code></ulink> but, as its
    name suggests, it searches in the backward direction.
   </para>
   <para>
    In the Lips binding to GTK+ we have in addition the function <ulink url="&gtk-text-iter-search;">
    <code>gtk-text-iter-search</code></ulink> which combines the functions for forward and backward search
    and handles the arguments <code>flags</code> and <code>limit</code> as keyword arguments.  In addition
    the keyword argument <code>direction</code> with a default value of <code>:forward</code> indicates the
    direction of the search.  Set the value of <code>direction</code> to <code>:backward</code> for backward
    search.
   </para>
   <para>
    The function <ulink url="&gtk-text-buffer-selection-bounds;">
    <code>gtk-text-buffer-selection-bounds</code></ulink> was introduced earlier, to obtain the iterators
    around the current selection.  To set the current selection programmatically the function
    <ulink url="&gtk-text-buffer-select-range;"><code>gtk-text-buffer-select-range</code></ulink> with the
    arguments <code>buffer</code>, <code>start</code>, <code>end</code> can be used.  The function sets the
    selection bounds of <code>buffer</code> to <code>start</code> and <code>end</code>.  The following
    example which demonstrates searching, uses this function to highlight matched text.
   </para>
   <figure id="figure-text-view-search">
    <title>Searching text in a text view</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-search.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-text-view-search">
    <title>Searching text in a text view</title>
    <programlisting>
(defvar *some-text*
        "One of the important things to remember about text in GTK+ is that
it is in the UTF-8 encoding. This means that one character can be encoded as
multiple bytes. Character counts are usually referred to as offsets, while
byte counts are called indexes. If you confuse these two, things will work
fine with ASCII, but as soon as your buffer contains multibyte characters,
bad things will happen.")

(defun example-text-view-search ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Text View Search"
                                 :type :toplevel
                                 :default-width 300
                                 :default-height 200))
          (entry (make-instance 'gtk-entry))
          (button (make-instance 'gtk-button
                                 :label "Search"))
          (scrolled (make-instance 'gtk-scrolled-window))
          (text-view (make-instance 'gtk-text-view
                                    :wrap-mode :word
                                    :hexpand t
                                    :vexpand t))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical))
          (hbox (make-instance 'gtk-grid
                               :orientation :horizontal)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Signal handler for the search button
      (g-signal-connect button "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (let* ((text (gtk-entry-text entry))
                  (buffer (gtk-text-view-buffer text-view))
                  (iter (gtk-text-buffer-start-iter buffer)))
             (multiple-value-bind (found start end)
                 (gtk-text-iter-search iter text)
               (when found
                 (gtk-text-buffer-select-range buffer start end))))))
      (setf (gtk-text-buffer-text (gtk-text-view-buffer text-view))
            *some-text*)
      (gtk-container-add scrolled text-view)
      (gtk-container-add hbox entry)
      (gtk-container-add hbox button)
      (gtk-container-add vbox hbox)
      (gtk-container-add vbox scrolled)
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>

   <section id="Continuing_the_search_with_Marks">
    <sectioninfo>
     <itermset>
      <indexterm zone="Continuing_the_search_with_Marks">
       <primary>text-buffer-create-mark, gtk-text-buffer-create-mark</primary>
      </indexterm>
      <indexterm zone="Continuing_the_search_with_Marks">
       <primary>text-buffer-mark, gtk-text-buffer-mark</primary>
      </indexterm>
      <indexterm zone="Continuing_the_search_with_Marks">
       <primary>text-buffer-iter-at-mark, gtk-text-buffer-iter-at-mark</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Continuing the search with Marks</title>
    <para>
     If you had executed the above program you would have noted that, if there were more than one occurrence
     of the text in the buffer, pressing search will only highlight the first occurrence of the text.  To
     provide a feature similarly to Find Next; the program has to remember the location where the previous
     search stopped.  So that you can start searching from that location.  And this should happen even if the
     buffer were modified between the two searches.  We could store the <code>match-end</code> iter passed on
     the function <ulink url="&gtk-text-iter-search;"><code>gtk-text-iter-search</code></ulink> and use it as
     the starting point for the next search.  But the problem is that if the buffer were modified in between,
     the iter would get invalidated. This takes us to marks.
    </para>
    <para>
     A mark preserves a position in the buffer between modifications.  This is possible because their
     behavior is defined when text is inserted or deleted.  When text containing a mark is deleted, the mark
     remains in the position originally occupied by the deleted text.  When text is inserted at a mark, a
     mark with left gravity will be moved to the beginning of the newly-inserted text, and a mark with right
     gravity will be moved to the end.
    </para>
    <para>
     The gravity of the mark is specified while creation.  The function
     <ulink url="&gtk-text-buffer-create-mark;"><code>gtk-text-buffer-create-mark</code></ulink> with the
     arguments <code>buffer</code>, <code>mark-name</code>, <code>where</code> and <code>left-grafity</code>
     can be used to create a mark associated with a buffer.
    </para>
    <para>
     The iter <code>where</code> specifies a position in the buffer which has to be marked.
     <code>left-gravity</code> determines how the mark moves when text is inserted at the mark.  The argument
     <code>mark-name</code> is a string that can be used to identify the mark.  If <code>mark-name</code> is
     specified, the mark can be retrieved using the function <ulink url="&gtk-text-buffer-mark;">
     <code>gtk-text-buffer-mark</code></ulink>.
    </para>
    <para>
     With named tags, you do not have to carry around a pointer to the marker, which can be easily retrieved
     using the function <ulink url="&gtk-text-buffer-mark;"><code>gtk-text-buffer-mark</code></ulink>.  A
     mark by itself cannot be used for buffer operations, it has to converted into an iter just before buffer
     operations are to be performed.  The function <ulink url="&gtk-text-buffer-iter-at-mark;">
     <code>gtk-text-buffer-iter-at-mark</code></ulink> with the arguments <code>buffer</code> and
     <code>mark</code> returns the iter at the position of <code>mark</code>.
    </para>
   </section>

   <section id="Scrolling_Problem">
    <sectioninfo>
     <itermset>
      <indexterm zone="Scrolling_Problem">
       <primary>text-view-scroll-mark-onscreen, gtk-text-view-scroll-mark-onscreen</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>The Scrolling Problem</title>
    <para>
     Before we show an example, we have to solve the problem that the text view should scroll to the matched
     text.  It can be irritating when the matched text is not in the visible portion of the buffer.  The
     function <ulink url="&gtk-text-view-scroll-mark-onscreen;">
     <code>gtk-text-view-scroll-mark-onscreen</code></ulink> with the arguments <code>text-view</code> and
     <code>mark</code> scrolls to a position in the buffer.  The argument <code>mark</code> specifies the
     position to scroll to.  Note that this is a method of the <ulink url="&gtk-text-view;">
     <code>gtk-text-view</code></ulink> widget rather than a <ulink url="&gtk-text-buffer;">
     <code>gtk-text-buffer</code></ulink> object.  Since it does not change the contents of the buffer, it
     only changes the way a buffer is viewed.
    </para>
    <para>
     The following example shows the usage of marks to continue the search.
    </para>
   <figure id="figure-text-view-find-next">
    <title>Searching text in a text view</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-find-next.jpg" format="jpg"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
    <example id="example-text-view-find-next">
     <title>Searching text in a text view</title>
     <programlisting>
(defun find-text (text-view text iter)
  (let ((buffer (gtk-text-view-buffer text-view)))
    (multiple-value-bind (found start end)
        (gtk-text-iter-search iter text)
      (when found
        (gtk-text-buffer-select-range buffer start end)
        (let ((last-pos (gtk-text-buffer-create-mark buffer "last-pos" end)))
          (gtk-text-view-scroll-mark-onscreen text-view last-pos))))))

(defun example-text-view-find-next ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Multiline Text Search"
                                 :type :toplevel
                                 :default-width 450
                                 :default-height 200))
          (entry (make-instance 'gtk-entry))
          (button-search (make-instance 'gtk-button
                                        :label "Search"))
          (button-next (make-instance 'gtk-button
                                      :label "Next"))
          (scrolled (make-instance 'gtk-scrolled-window))
          (text-view (make-instance 'gtk-text-view
                                    :hexpand t
                                    :vexpand t))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical))
          (hbox (make-instance 'gtk-grid
                               :orientation :horizontal)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect button-search "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (let* ((text (gtk-entry-text entry))
                  (buffer (gtk-text-view-buffer text-view))
                  (iter (gtk-text-buffer-start-iter buffer)))
             (find-text text-view text iter))))
      (g-signal-connect button-next "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (let* ((text (gtk-entry-text entry))
                  (buffer (gtk-text-view-buffer text-view))
                  (last-pos (gtk-text-buffer-get-mark buffer "last-pos")))
             (when last-pos
               (find-text text-view
                          text
                          (gtk-text-buffer-get-iter-at-mark buffer
                                                            last-pos))))))
      (setf (gtk-text-buffer-text (gtk-text-view-buffer text-view))
            *some-text*)
      (gtk-container-add scrolled text-view)
      (gtk-container-add hbox entry)
      (gtk-container-add hbox button-search)
      (gtk-container-add hbox button-next)
      (gtk-container-add vbox hbox)
      (gtk-container-add vbox scrolled)
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="More_on_Marks">
    <sectioninfo>
     <itermset>
      <indexterm zone="More_on_Marks">
       <primary>text-buffer-delete-mark, gtk-text-buffer-delete-mark</primary>
      </indexterm>
      <indexterm zone="More_on_Marks">
       <primary>text-buffer-delete-mark-by-name, gtk-text-buffer-delete-mark-by-name</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>More on Marks</title>
    <para>
     When a mark is no longer required, it can be deleted using the functions
     <ulink url="&gtk-text-buffer-delete-mark;"><code>gtk-text-buffer-delete-mark</code></ulink>
     or <ulink url="&gtk-text-buffer-delete-mark-by-name;">
     <code>gtk-text-buffer-delete-mark-by-name</code></ulink>.  There are two marks built-in to
     <ulink url="&gtk-text-buffer;"><code>gtk-text-buffer</code></ulink> - "insert" and "selection-bound".
     The "insert" mark refers to the cursor position, also called the insertion point.  A selection is
     bounded by two marks.  One is the "insert" mark and the other is "selection-bound" mark.  When no text
     is selected the two marks are in the same position.
    </para>
   </section>
  </section>

  <section id="Examing_and_Modify_Text">
   <sectioninfo>
    <itermset>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-line-offset, gtk-text-iter-line-offset</primary>
     </indexterm>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-forward-to-line-end, gtk-text-iter-forward-to-line-end</primary>
     </indexterm>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-find-char, gtk-text-iter-find-char</primary>
     </indexterm>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-backward-find-char, gtk-text-iter-backward-find-char</primary>
     </indexterm>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-forward-char, gtk-text-iter-forward-char</primary>
     </indexterm>
     <indexterm zone="Examing_and_Modify_Text">
      <primary>text-iter-char, gtk-text-iter-char</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Examing and Modify Text</title>
   <para>
    Examining and modifying text is another common operation performed on text buffers.  Examples are
    converting a selected portion of text into a comment while editing a program, determining and inserting
    the correct end tag while editing HTML, inserting a pair of HTML tags around the current word, etc.  The
    <ulink url="&gtk-text-iter;"><code>gtk-text-iter</code></ulink> object provides functions to do such
    processing.
   </para>
   <para>
    In this section we will develop two programs to demonstrate these functions.  The first program will
    insert start/end li tags (not to be confused with text attribute tags) around the current line, when a
    button is clicked.  The second program will insert an end tag for an unclosed start tag.
   </para>
   <para>
    To insert tags around the current line, we first obtain an iter at the current cursor position.  Then we
    move the iter to the beginning of the line, insert the start tag, move the iter to the end of the line,
    and insert the end tag.  An iter can be moved to a specified offset in the same line using the function 
    <ulink url="&gtk-text-iter-line-offset;"><code>gtk-text-iter-line-offset</code></ulink> with the
    arguments <code>iter</code> and <code>char-on-line</code>.  The function moves <code>iter</code> within
    the line, to the character offset specified by <code>char-on-line</code>.  If <code>char-on-line</code>
    is equal to the no. of characters in the line, the iter is moved to the start of the next line.  A
    character offset of zero, will move the iter to the beginning of the line.  The <code>iter</code> can be
    moved to the end of the line using the function <ulink url="&gtk-text-iter-forward-to-line-end;">
    <code>gtk-text-iter-forward-to-line-end</code></ulink>.  Now that we know the functions required to
    implement the first program, here is the code.
   </para>
   <figure id="figure-text-view-editing-1">
    <title>Multiline Text Editing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-editing-1.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-text-view-editing-1">
    <title>Modify text in a text view</title>
    <programlisting>
(defun example-text-editing-text-1 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Multiline Text Editing"
                                 :type :toplevel
                                 :default-width 300
                                 :default-height 200))
          (text-view (make-instance 'gtk-text-view
                                    :hexpand t
                                    :vexpand t))
          (button (make-instance 'gtk-button
                                 :label "Make List Item"))
          (vbox (make-instance 'gtk-grid
                                :orientation :vertical)))
    (g-signal-connect window "destroy"
                      (lambda (widget)
                        (declare (ignore widget))
                        (leave-gtk-main)))
    (g-signal-connect button "clicked"
       (lambda (widget)
         (declare (ignore widget))
         (let* ((buffer (gtk-text-view-buffer text-view))
                (cursor (gtk-text-buffer-get-mark buffer "insert"))
                (iter (gtk-text-buffer-get-iter-at-mark buffer cursor)))
           (setf (gtk-text-iter-line-offset iter) 0)
           (gtk-text-buffer-insert buffer "&#x3c;li>" :position iter)
           (gtk-text-iter-forward-to-line-end iter)
           (gtk-text-buffer-insert buffer "&#x3c;/li>" :position iter))))
   (setf (gtk-text-buffer-text (gtk-text-view-buffer text-view))
         (format nil "Item 1~%Item 2~%Item 3~%"))
   (gtk-container-add vbox text-view)
   (gtk-container-add vbox button)
   (gtk-container-add window vbox)
   (gtk-widget-show-all window))))
    </programlisting>
   </example>
   <para>
    For the second program, we will have to first get the iter at the current cursor position.  We then
    search backwards from the cursor position, through the buffer till we hit on an unclosed tag.  We then
    insert the corresponding end tag at the current cursor position.  Note that the procedure given does not
    take care of many special cases, and might not be the best way to determine an unclosed tag.  But it
    serves our purpose of explaining text manipulation functions.  Developing a perfect algorithm to
    determine an unclosed tag, is out of the scope of this tutorial.  We can identify tags using the left
    angle bracket.  So searching for start/end tags involves search for the left angle bracket.  This can be
    done using the function <ulink url="&gtk-text-iter-backward-find-char;">
    <code>gtk-text-iter-backward-find-char</code></ulink> or the function
    <ulink url="&gtk-text-iter-backward-find-char;"><code>gtk-text-iter-backward-find-char</code></ulink>
    with a value <code>:backward</code> for the keyword argument <code>direction</code>.
   </para>
   <para>
    The function proceeds backwards from <code>iter</code>, and calls <code>pred</code> for each character in
    the buffer, with the character as argument, till <code>pred</code> returns <emphasis>true</emphasis>. If
    a match is found, the function moves <code>iter</code> to the matching position and returns
    <emphasis>{true</emphasis>.  If a match is not found, the function moves <code>iter</code> to the
    beginning of the buffer or <code>limit</code> (if not <code>nil</code>) and returns <code>nil</code>.
    For our purpose we write a predicate that returns <emphasis>true</emphasis> when the character is a left
    angle bracket.  When we hit on a left angle bracket we check whether the corresponding tag is a start tag
    or an end tag.  This is done by examining the character immediately after the left angle bracket.  If it
    is a '/' it is an end tag.  To extract the character after the angle bracket we move the left angle
    bracket <code>iter</code> by one character.  And then extract the character at that position.  To move an
    <code>iter</code> forward by one character, the function <ulink url="&gtk-text-iter-forward-char;">
    <code>gtk-text-iter-forward-char</code></ulink> can be used.
   </para>
   <para>
    To extract the character at an <code>iter</code> the function <ulink url="&gtk-text-iter-char;">
    <code>gtk-text-iter-char</code></ulink> can be used.  After determining the tag type we do the following,
   </para>
   <itemizedlist>
    <listitem>
     If the tag is an end tag, we push the tag name into a stack and then proceed to find more tags.
    </listitem>
    <listitem>
     If it is a start tag, we pop out it's matching tag from the stack.  While poping out, if there were no
     more items in the stack, we have hit on an unmatched start tag!  We then insert the corresponding end
     tag at the current cursor position.
    </listitem>
   </itemizedlist>
   <para>
    We have not mentioned how we extract the tag name.  The tag name is extracted using two iters (start and
    end iter).  The start iter is obtained by starting from the left angle bracket iter and searching for an
    alphanumeric character, in the forward direction.  The end iter is obtained by starting from the start
    iter and searching for a non-alphanumeric character, in the forward direction.  The search can be done
    using the forward variant of the the function <ulink url="&gtk-text-iter-backward-find-char;">
    <code>gtk-text-iter-backward-find-char</code></ulink>.  The code for the second example follows.
   </para>
   <figure id="figure-text-view-editing-2">
    <title>Multiline Text Editing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-editing-2.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-text-view-editing-2">
    <title>Modify text in a text view</title>
    <programlisting>
(defun get-this-tag (iter buffer)
  (let* ((start-tag (gtk-text-iter-copy iter))
         end-tag)
    (and (gtk-text-iter-find-char start-tag #'alpha-char-p)
         (setq end-tag (gtk-text-iter-copy start-tag))
         (gtk-text-iter-find-char end-tag
                                  (lambda (ch) (not (alphanumericp ch))))
         (gtk-text-buffer-get-text buffer start-tag end-tag nil))))

(defun closing-tag-p (iter)
  (let ((slash (gtk-text-iter-copy iter)))
    (gtk-text-iter-forward-char slash)
    (eql (gtk-text-iter-char slash) #\/)))

(defun example-text-view-editing-2 ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Multiline Editing Text"
                                 :type :toplevel
                                 :default-width 300
                                 :defalut-height 200))
          (text-view (make-instance 'gtk-text-view
                                    :hexpand t
                                    :vexpand t))
          (button (make-instance 'gtk-button
                                 :label "Insert Close Tag"))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect button "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (let* ((buffer (gtk-text-view-buffer text-view))
                  (cursor (gtk-text-buffer-get-mark buffer "insert"))
                  (iter (gtk-text-buffer-get-iter-at-mark buffer cursor)))

             (do ((stack '()))
                 ((not (gtk-text-iter-find-char iter
                                               (lambda (ch) (eq ch #\&#x3c;))
                                               :direction :backward)))
               (let ((tag (get-this-tag iter buffer)))
                 (if (closing-tag-p iter)
                     (push tag stack)
                     (let ((tag-in-stack (pop stack)))
                       (when (not tag-in-stack)
                         (gtk-text-buffer-insert buffer
                                                 (format nil "&#x3c;/&#x7e;a>" tag))
                         (return)))))))))
      (setf (gtk-text-buffer-text (gtk-text-view-buffer text-view))
            (format nil
                    "&#x3c;html>&#x7e;%&#x7e;
                     &#x3c;head>&#x3c;title>Title&#x3c;/title>&#x3c;/head>&#x7e;%&#x7e;
                     &#x3c;body>~%&#x7e;
                     &#x3c;h1>Heading&#x3c;/h1>&#x7e;%"))
      (gtk-container-add vbox text-view)
      (gtk-container-add vbox button)
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Images_and_Widgets">
   <title>Images and Widgets</title>

   <section id="Inserting_Images">
    <title>Inserting Images</title>
    <para>
     A text buffer can hold images and anchor location for widgets. An image can be inserted into a buffer
     using the function <ulink url="&gtk-text-buffer-insert-pixbuf;">
     <code>gtk-text-buffer-insert-pixbuf</code></ulink> with the arguments <code>buffer</code>,
     <code>iter</code>, and <code>pixbuf</code>. An image represented by <code>pixbuf</code> is inserted
     at <code>iter</code>. The <code>pixbuf</code> can be created from an image file using the function
     <ulink url="&gdk-pixbuf-new-from-file;"><code>gdk-pixbuf-new-from-file</code></ulink>. See the API
     documentation for <ulink url="&gdk-pixbuf;"><code>gdk-pixbuf</code></ulink> for more details.
    </para>
    <para>
     The example program given below takes an image filename and inserts the corresponding image into a
     buffer.
    </para>
    <figure id="figure-text-view-insert-image">
     <title>Multiline Text Editing</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-insert-image.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-text-view-insert-image">
     <title>Insert an Image</title>
     <programlisting>
(defun example-text-view-insert-image ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Multiline Text Widget"
                                 :default-width 300
                                 :default-height 200))
          (text-view (make-instance 'gtk-text-view
                                    :hexpand t
                                    :vexpand t))
          (button (make-instance 'gtk-button
                                 :label "Insert Image"))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical)))
    (g-signal-connect window "destroy"
                      (lambda (widget)
                        (declare (ignore widget))
                        (leave-gtk-main)))
    ;; Signal handler to insert an image at the current cursor position.
    (g-signal-connect button "clicked"
       (lambda (widget)
         (declare (ignore widget))
         (let* ((pixbuf (gdk-pixbuf-new-from-file "save.png"))
                (buffer (gtk-text-view-buffer text-view))
                (cursor (gtk-text-buffer-get-insert buffer))
                (iter (gtk-text-buffer-get-iter-at-mark buffer cursor)))
           (gtk-text-buffer-insert-pixbuf buffer iter pixbuf))))
    (gtk-container-add vbox text-view)
    (gtk-container-add vbox button)
    (gtk-container-add window vbox)
    (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="Retrieving_Images">
    <title>Retrieving Images</title>
    <para>
     Images in a buffer are represented by the character <code>0xFFFC</code> (Unicode object replacement
     character).  When text containing images is retrieved from a buffer using the function
     <ulink url="&gtk-text-buffer-get-text;"><code>gtk-text-buffer-get-text</code></ulink> the
     <code>0xFFFC</code> characters representing images are dropped off in the returned text.  If these
     characters representing images are required, use the slice variant -
     <ulink url="&gtk-text-buffer-get-slice;"><code>gtk-text-buffer-get-slice</code></ulink>.  The image at a
     given position can be retrieved using the function <ulink url="&gtk-text-iter-pixbuf;">
     <code>gtk-text-iter-pixbuf</code></ulink>.
    </para>
   </section>

   <section id="Inserting Widgets">
    <title>Inserting Widgets</title>
    <para>
     Inserting a widget, unlike inserting an image, is a two step process.  The additional complexity is due
     to the functionality split between <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink> and
     <ulink url="&gtk-text-buffer;"><code>gtk-text-buffer</code></ulink>.  The first step is to create and
     insert a <ulink url="&gtk-text-child-anchor;"><code>gtk-text-child-anchor</code></ulink>.  A widget is
     held in a buffer using a <ulink url="&gtk-text-child-anchor;">
     <code>gtk-text-child-anchor</code></ulink>.  A child anchor according to the GTK manual is a spot in the
     buffer where child widgets can be anchored.  A child anchor can be created and inserted into a buffer
     using the function <ulink url="&gtk-text-buffer-create-child-anchor;">
     <code>gtk-text-buffer-create-child-anchor</code></ulink> with the arguments <code>buffer</code> and
     <code>iter</code>.  Where <code>iter</code> specifies the position in the buffer, where the widget is to
     be inserted.  The next step is to add a child widget to the text view, at the anchor location with the
     function <ulink url="&gtk-text-view-add-child-at-anchor;">
     <code>gtk-text-view-add-child-at-anchor</code></ulink>.
    </para>
    <para>
     An anchor can hold only one widget, it could be a container widget, which in turn can contain many
     widgets, unless you are doing tricky things like displaying the same buffer using different
     <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink> objects.  The following program inserts
     a button widget into a text buffer, whenever the user clicks on the Insert button.
    </para>
    <figure id="figure-text-view-insert-widget">
     <title>Multiline Text Editing</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/text-view-insert-widget.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-text-view-insert-widget">
     <title>Insert a widget</title> 
     <programlisting>
(defun example-text-view-insert-widget ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Multiline Text Widget"
                                 :default-width 300
                                 :default-height 200))
          (text-view (make-instance 'gtk-text-view
                                    :hexpand t
                                    :vexpand t))
          (button (make-instance 'gtk-button
                                 :label "Insert Widget"))
          (vbox (make-instance 'gtk-grid
                               :orientation :vertical)))
    (g-signal-connect window "destroy"
                      (lambda (widget)
                        (declare (ignore widget))
                        (leave-gtk-main)))
    ;; Signal handler to insert a widget at the current cursor position.
    (g-signal-connect button "clicked"
       (lambda (widget)
         (declare (ignore widget))
         (let* ((buffer (gtk-text-view-buffer text-view))
                (cursor (gtk-text-buffer-get-insert buffer))
                (iter (gtk-text-buffer-get-iter-at-mark buffer cursor))
                (anchor (gtk-text-buffer-create-child-anchor buffer iter))
                (button (gtk-button-new-with-label "New Button")))
           (gtk-text-view-add-child-at-anchor text-view button anchor)
           (gtk-widget-show button))))
    (gtk-container-add vbox text-view)
    (gtk-container-add vbox button)
    (gtk-container-add window vbox)
    (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="Retrieving_Widgets">
    <title>Retrieving Widgets</title>
    <para>
     Child anchors are also represented in the buffer using the object replacement character
     <code>0xFFFC</code>.  Retrieving a widget is also a two step process.  First, the child anchor has to be
     retrieved.  This can be done using the function <ulink url="&gtk-text-iter-child-anchor;">
     <code>gtk-text-iter-child-anchor</code></ulink>.  Next, the widget(s) associated with the child anchor
     has to be retrieved.  This can be done using the function <ulink url="&gtk-text-child-anchor-widgets;">
     <code>gtk-text-child-anchor-widgets</code></ulink>.  The function returns a list of widgets.  As
     mentioned earlier, if you are not doing tricky things like multiple views for the same buffer, you will
     find only one widget in this list.
    </para>
   </section>
  </section>

  <section id="Buffer_and_Window_Coordinates">
   <title>Buffer and Window Coordinates</title>
   <para>
    Sometimes it is necessary to know the position of the text cursor on the screen, or the word in a buffer
    under the mouse cursor.  For example, when you want to display the prototype of a function as a tooltip,
    when the user types open parenthesis.  To do this, you will have to understand buffer coordinates and
    window coordinates.
   </para>
   <para>
    Both the buffer and window coordinates are pixel level coordinates.  The difference is that the window
    coordinates takes into account only the portion of the buffer displayed on the screen.  The concept would
    be better explained using a diagram.  The large white box (with grid lines) in the following diagram
    depicts the text buffer.  And the smaller inner grey box is the visible portion of the text buffer,
    displayed by the text view widget.
   </para>
   <figure id="figure-buffercoord">
    <title>Multiline Text Editing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/buffercoord.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The buffer coordinates of the red dot (represented as (x, y)) is (4, 3).  But the window coordinates of
    the red dot is (2, 1).  This is because the window coordinates are calculated relative the visible
    portion of the text buffer.  Similarly, the buffer coordinates of the blue dot is (3, 5) and the window
    coordinates is (1, 3).
   </para>
   <para>
    In this section, you will learn how to display tooltips under the text cursor.  The procedure is as
    follows,
   </para>
   <itemizedlist>
    <listitem>The buffer coordinates of the text cursor is obtained.</listitem>
    <listitem>The buffer coordinates is converted to window coordinates (x1, y1).</listitem>
    <listitem>The position (x2, y2) of the text view widget on the screen is obtained.</listitem>
    <listitem>A window with the tooltip is displayed at (x1+x2, y1+y2).</listitem>
   </itemizedlist>
   <para>
    The buffer coordinates of a particular character in a buffer can be obtained using the function
    <ulink url="&gtk-text-view-iter-at-location;"><code>gtk-text-view-iter-at-location</code></ulink> with
    the argument <code>iter</code>.  The function gets the rectangle that contains the character at
    <code>iter</code> and returns it.  The <code>x</code> and <code>y</code> members of <code>location</code>
    gives us the buffer coordinates.
   </para>
   <para>
    The buffer coordinates can be converted into window coordinates using the function
    <ulink url="&gtk-text-view-buffer-to-window-coords;">
    <code>gtk-text-view-buffer-to-window-coords</code></ulink>.  The function converts buffer coordinates
    <code>(buffer-x, buffer-y)</code>, to window coordinates <code>(window-x, window-y)</code>.
   </para>
   <para>
    Now that we know the position of the character within the text view widget, we will have to find the
    position of the text view widget on the screen.
   </para>
   <para>
    Each GTK widget has a corresponding <ulink url="&gdk-window;"><code>gdk-window</code></ulink> associated
    with it.  Once we know the <ulink url="&gdk-window;"><code>gdk-window</code></ulink> associated with a
    widget, we can obtain it's X-Y coordinates using <ulink url="&gdk-window-origin;">
    <code>gdk-window-origin</code></ulink>.  The <ulink url="&gdk-window;">
    <code>gdk-window</code></ulink> of the text view widget can be obtained using the function
    <ulink url="&gtk-text-view-window;"><code>gtk-text-view-window</code></ulink>.  Here again you will have
    to pass <code>:widget</code> for the argument <code>win</code>.
   </para>
   <para>
    We now know the functions required to display a tooltip under the text cursor.  Before we proceed to the
    example, you will have to know which signal has to be trapped to do display the tooltip. Since we want
    the tooltip to be displayed when the user inserts open parenthesis, "insert-text" emitted by the buffer
    object can be used.  As the signal's name suggests it is called whenever the user inserts text into the
    buffer.  The callback prototype is <code>lambda (buffer pos text length)</code>.
   </para>
   <para>
    The function is called with <code>position</code> after the inserted text <code>pos</code>, the inserted
    text <code>text</code> and the length of the inserted text <code>length</code>.
   </para>
   <para>
    Below is an example program that displays a tooltip for the printf family of functions.
   </para>
   <figure id="figure-text-view-tooltip">
    <title>Multiline Text Editing</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-view-tooltip.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-text-view-tooltip">
    <title>Show tooltips in a Text View</title>
    <programlisting> 
(let ((tooltip nil))
  (defun get-tip (word)
    (cdr (assoc word
                '(("printf" . "(const char *format, ...)")
                  ("fprintf" . "(FILE *stream, const char *format, ...)")
                  ("sprintf" . "(char *str, const char *format, ...)")
                  ("fputc" . "(int c, FILE *stream)")
                  ("fputs" . "(const char *s, FILE *stream)")
                  ("putc" . "(int c, FILE *stream)")
                  ("putchar" . "(int c)")
                  ("puts" . "(const char *s)"))
                :test #'equal)))

  (defun tip-window-new (tip-text)
    (let ((win (make-instance 'gtk-window
                              :type :popup
                              :border-width 0))
          (event-box (make-instance 'gtk-event-box
                                    :border-width 1))
          (label (make-instance 'gtk-label
                                :label tip-text)))
      (gtk-widget-override-font
          label
          (pango-font-description-from-string "Courier"))
      (gtk-widget-override-background-color win
                                            :normal
                                            (gdk-rgba-parse "Black"))
      (gtk-widget-override-color win :normal (gdk-rgba-parse "Blue"))
      (gtk-container-add event-box label)
      (gtk-container-add win event-box)
      win))

  (defun insert-open-brace (window text-view location)
    (let ((start (gtk-text-iter-copy location)))
      (when (gtk-text-iter-backward-word-start start)
        (let* ((word (string-trim " "
                                  (gtk-text-iter-text start location)))
               (tip-text (get-tip word)))
          (when tip-text
            (let ((rect (gtk-text-view-get-iter-location text-view location))
                  (win (gtk-text-view-get-window text-view :widget)))
              (multiple-value-bind (win-x win-y)
                  (gtk-text-view-buffer-to-window-coords
                      text-view
                      :widget
                      (gdk-rectangle-x rect)
                      (gdk-rectangle-y rect))
                (multiple-value-bind (x y)
                    (gdk-window-origin win)
                  ;; Destroy any previous tool tip window
                  (when tooltip
                    (gtk-widget-destroy tooltip)
                    (setf tooltip nil))
                  ;; Create a new tool tip window
                  (setf tooltip (tip-window-new tip-text))
                  ;; Place it at the calculated position.
                  (gtk-window-move tooltip
                                   (+ win-x x)
                                   (+ win-y y (gdk-rectangle-height rect)))
                  (gtk-widget-show-all tooltip)))))))))

  (defun example-text-view-tooltip ()
    (within-main-loop
      (let* ((window (make-instance 'gtk-window
                                    :title "Multiline Text Search"
                                    :type :toplevel
                                    :default-width 450
                                    :default-height 200))
             (scrolled (make-instance 'gtk-scrolled-window))
             (text-view (make-instance 'gtk-text-view
                                       :hexpand t
                                       :vexpand t))
             (buffer (gtk-text-view-buffer text-view)))
        ;; Signal handler for the window
        (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (when tooltip
                            (gtk-widget-destroy tooltip)
                            (setf tooltip nil))
                          (leave-gtk-main)))
        ;; Signal handler for the buffer of the text view
        (g-signal-connect buffer "insert-text"
           (lambda (buffer location text len)
             (declare (ignore buffer len))
             (when (equal text "(")
               (insert-open-brace window text-view location))
             (when (equal text ")")
               (when tooltip
                 (gtk-widget-destroy tooltip)
                 (setf tooltip nil)))))
        ;; Change the default font
        (gtk-widget-override-font
            text-view
            (pango-font-description-from-string "Courier 12"))
        ;; Add the widgets to window and show all
        (gtk-container-add scrolled text-view)
        (gtk-container-add window scrolled)
        (gtk-widget-show-all window)))))
    </programlisting>
   </example>

   <section id="More_on_Buffer_and_Window_Coordinates">
    <title>More on Buffer and Window Coordinates</title>
    <para>
     In the previous section we obtained the screen coordinates for a position in the buffer.  What if we
     want to do the exact opposite, i.e. what if we want to find the position in the buffer corresponding to
     a particular X-Y coordinate.  The <ulink url="&gtk-text-view;"><code>gtk-text-view</code></ulink> has
     functions for these as well.
    </para>
    <para>
     Window coordinates can be converted to buffer coordinates using the function
     <ulink url="&gtk-text-view-window-to-buffer-coords;">
     <code>gtk-text-view-window-to-buffer-coords</code></ulink>.
    </para>
    <para>
     The iter at a buffer coordinate can be obtained using the function
     <ulink url="&gtk-text-view-iter-at-location;"><code>gtk-text-view-iter-at-location</code></ulink>.
    </para>
   </section>
  </section>

  <section id="Final_Notes">
   <title>Final Notes</title>
   <para>
   </para>
  </section>
 </chapter>

 <chapter id="Tree_and_List_Widgets">
  <title>Tree and List Widgets</title>

  <section id="Overview">
   <title>Overview</title>
   <sectioninfo>
    <itermset>
     <indexterm zone="Overview">
      <primary>GtkTreeModel</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>tree-model, gtk-tree-model</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>tree-view, gtk-tree-view</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>GtkTreeViewColumn</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>tree-view-column, gtk-tree-view-column</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>GtkCellRenderer</primary>
     </indexterm>
     <indexterm zone="Overview">
      <primary>cell-renerer, gtk-cell-renderer</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <para>
    To create a tree or list in GTK+, use the <ulink url="&gtk-tree-model;">
    <code>gtk-tree-model</code></ulink> interface in conjunction with the <ulink url="&gtk-tree-view;">
    <code>gtk-tree-view</code></ulink> widget.  This widget is designed around a Model/View/Controller
    design and consists of four major parts:
   </para>
   <itemizedlist>
    <listitem>
     The tree view widget <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink>.
    </listitem>
    <listitem>
     The view column <ulink url="&gtk-tree-view-column;"><code>gtk-tree-view-column</code></ulink>.
    </listitem>
    <listitem>
     The cell renderers <ulink url="&gtk-cell-renderer;"><code>gtk-cell-renderer</code></ulink> etc.
    </listitem>
    <listitem>
     The model interface <ulink url="&gtk-tree-model;"><code>gtk-tree-model</code></ulink>.
    </listitem>
   </itemizedlist>
   <para>
    The View is composed of the first three objects, while the last is the Model.  One of the prime benefits
    of the MVC design is that multiple views can be created of a single model.  For example, a model mapping
    the file system could be created for a file manager.  Many views could be created to display various
    parts of the file system, but only one copy need be kept in memory.
   </para>
   <para>
    The purpose of the cell renderers is to provide extensibility to the widget and to allow multiple ways of
    rendering the same type of data.  For example, consider how to render a boolean variable.  Should it
    render as a string of "True" or "False", "On" or "Off", or should it be rendered as a checkbox?
   </para>

   <section id="Creating_a_model">
    <sectioninfo>
     <itermset>
      <indexterm zone="Creating_a_model">
       <primary>GtkTreeStore</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>tree-store, gtk-tree-store</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>GtkListStore</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>list-store, gtk-list-store</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>GtkTreeIter</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>tree-iter, gtk-tree-iter</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>list-store-set, gtk-list-store-set</primary>
      </indexterm>
      <indexterm zone="Creating_a_model">
       <primary>tree-store-set, gtk-tree-store-set</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Creating a model</title>
    <para>
     GTK+ provides two simple models that can be used: the <ulink url="&gtk-list-store;">
     <code>gtk-list-store</code></ulink> and the <ulink url="&gtk-tree-store;">
     <code>gtk-tree-store</code></ulink>.  <ulink url="&gtk-list-store;"><code>gtk-list-store</code></ulink>
     is used to model list widgets, while the <ulink url="&gtk-tree-store;">
     <code>gtk-tree-store</code></ulink> models trees.  It is possible to develop a new type of model, but
     the existing models should be satisfactory for all but the most specialized of situations.  Creating
     the model is quite simple:
    </para>
    <programlisting>
(let ((model (make-instance 'gtk-list-store
                            :column-types '("gchararray" "guint"))))
  ... )
    </programlisting>
    <para>
     This creates a list store with two columns: a string column and a boolean column.  Adding data to the
     model is done using <ulink url="&gtk-tree-store-set;"><code>gtk-tree-store-set</code></ulink> or
     <ulink url="&gtk-list-store-set;"><code>gtk-list-store-set</code></ulink>, depending upon which sort of
     model was created.  To do this, a <ulink url="&gtk-tree-iter;"><code>gtk-tree-iter</code></ulink> must
     be acquired.  The iterator points to the location where data will be added.
    </para>
    <para>
     Once an iterator has been acquired, <ulink url="&gtk-tree-store-set;">
     <code>gtk-tree-store-set</code></ulink> is used to apply data to the part of the model that the iterator
     points to.  Consider the following example:
    </para>
    <programlisting>
(let ((model (make-instance 'gtk-list-store
                            :column-types '("gchararray" "guint"))))
  (let ((iter (gtk-list-store-append model)))
    (gtk-list-store-set model iter "Klaus-Dieter Mustermann" 51))
  ... )
    </programlisting>
    <para>
     This can be written more compact as:
    </para>
    <programlisting>
(let ((model (make-instance 'gtk-list-store
                            :column-types '("gchararray" "guint"))))
  (gtk-list-store-set model (gtk-list-store-append model)
                            "Klaus-Dieter Mustermann" 51)
  ... )
    </programlisting>
    <para>
     It can be used to set the data in any or all columns in a given row.
    </para>
   </section>

   <section id="Creating_the_view_component">
    <title>Creating the view component</title>
    <para>
     While there are several different models to choose from, there is only one view widget to deal with.
     It works with either the list or the tree store.  Setting up a <ulink url="&gtk-tree-view;">
     <code>gtk-tree-view</code></ulink> is not a difficult matter.  It needs a <ulink url="&gtk-tree-model;">
     <code>gtk-tree-model</code></ulink> to know where to retrieve its data from.
    </para>

    <programlisting>
(let ((model (create-and-fill-model))
      (view (make-instance 'gtk-tree-view
                           :model model)))
  ... )
    </programlisting>

    <section id="Columns_and_cell_renderers">
     <sectioninfo>
      <itermset>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>GtkCellRendererText</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>cell-renderer-text, gtk-cell-renderer-text</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>GtkCellRendererPixbuf</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>cell-renderer-pixbuf, gtk-cell-renderer-pixbuf</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>GtkCellRendererToggle</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>cell-renderer-toggle, gtk-cell-renderer-toggle</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>GtkTreeViewColumn</primary>
       </indexterm>
       <indexterm zone="Columns_and_cell_renderers">
        <primary>tree-view-column, gtk-tree-view-column</primary>
       </indexterm>
      </itermset>
     </sectioninfo>
     <title>Columns and cell renderers</title>
     <para>
      Once the <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink> widget has a model, it will
      need to know how to display the model.  It does this with columns and cell renderers.
     </para>
     <para>
      Cell renderers are used to draw the data in the tree model in a way.  There are a number of cell
      renderers that come with GTK+, including the <ulink url="&gtk-cell-renderer-text;">
      <code>gtk-cell-renderer-text</code></ulink>, <ulink url="&gtk-cell-renderer-pixbuf;">
      <code>gtk-cell-renderer-pixbuf</code></ulink> and the <ulink url="&gtk-cell-renderer-toggle;">
      <code>gtk-cell-renderer-toggle</code></ulink>.  It is relatively easy to write a custom renderer.
     </para>
     <para>
      A <ulink url="&gtk-tree-view-column;"><code>gtk-tree-view-column</code></ulink> is the object that
      <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink> uses to organize the vertical columns
      in the tree view.  It needs to know the name of the column to label for the user, what type of cell
      renderer to use, and which piece of data to retrieve from the model for a given row.
     </para>
     <programlisting>
;; Create renderers for the cells
(let* ((renderer (gtk-cell-renderer-text-new))
       (column (gtk-tree-view-column-new-with-attributes "Name"
                                                         renderer
                                                         "text" 0)))
  (gtk-tree-view-append-column view column)
  ... )
     </programlisting>
     <para>
      At this point, all the steps in creating a displayable tree have been covered.  The model is created,
      data is stored in it, a tree view is created and columns are added to it.
     </para>
    </section>

    <section id="Selection handling">
     <title>Selection handling</title>
     <para>
      Most applications will need to not only deal with displaying data, but also receiving input events from
      users.  To do this, simply get a reference to a selection object, connect to the "changed" signal and
      then to retrieve data for the row selected:
     </para>
     <programlisting>
(let ((view (create-view-and-model))
      ;; Get the selection of the view
      (select (gtk-tree-view-selection view)))
  ;; Setup the selection handler
  (setf (gtk-tree-selection-mode select) :single)
  (g-signal-connect select "changed"
     (lambda (selection)
       (let* ((model (gtk-tree-view-get-model view))
              (iter (gtk-tree-selection-get-selected selection))
              (name (gtk-tree-model-get-value model iter 0)))
         (format t "You selected the name ~A.~%" name))))
  ... )
     </programlisting>
    </section>
   </section>

   <section id="Simple_example">
    <title>Simple example</title>
    <figure id="figure-simple-tree-view">
     <title>Simple Tree View</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/simple-tree-view.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     Here is a simple example of using a <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink>
     widget in context of the other widgets.  It simply creates a simple model and view, and puts them
     together.
    </para>
    <example id="example-simple-tree-view">
     <title>A Simple Tree View</title>
     <programlisting>
(defun create-and-fill-model ()
  (let ((model (make-instance 'gtk-list-store
                              :column-types '("gchararray" "guint"))))
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Klaus-Dieter Mustermann" 51)
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Ulrike Langhals" 23)
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Marius Kalinowski" 91)
    model))

(defun create-view-and-model ()
  (let* ((model (create-and-fill-model))
         (view (make-instance 'gtk-tree-view
                              :model model)))
    ;; Create renderers for the cells
    (let* ((renderer (gtk-cell-renderer-text-new))
           (column (gtk-tree-view-column-new-with-attributes "Name"
                                                             renderer
                                                             "text" 0)))
      (gtk-tree-view-append-column view column))
    (let* ((renderer (gtk-cell-renderer-text-new))
           (column (gtk-tree-view-column-new-with-attributes "Age"
                                                             renderer
                                                             "text" 1)))
      (gtk-tree-view-append-column view column))
    view))

(defun example-simple-tree-view ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Simple Tree View"
                                 :type :toplevel
                                 :border-width 12
                                 :default-width 300
                                 :default-height 200))
          (view (create-view-and-model)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window view)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="GtkListStore_and_GtkTreeStore">
   <title>GtkListStore and GtkTreeStore</title>
   <para>
    Gtk+ comes with two built-in data stores (models): <ulink url="&gtk-list-store;">
    <code>gtk-list-store</code></ulink> and <ulink url="&gtk-tree-store;">
    <code>gtk-tree-store</code></ulink>.  As the names imply, <ulink url="&gtk-tree-store;">
    <code>gtk-tree-store</code></ulink> is used for simple lists of data items where items have no
    hierarchical parent-child relationships, and <ulink url="&gtk-tree-store;">
    <code>gtk-tree-store</code></ulink> is used for tree-like data structures, where items can have
    parent-child relationships.  A list of files in a directory would be an example of a simple list
    structure, whereas a directory tree is an example for a tree structure.  A list is basically just a
    special case of a tree with none of the items having any children, so one could use a tree store to
    maintain a simple list of items as well. The only reason <ulink url="&gtk-tree-store;">
    <code>gtk-tree-store</code></ulink> exists is in order to provide an easier interface that does not need
    to cater for child-parent relationships, and because a simple list model can be optimised for the special
    case where no children exist, which makes it faster and more efficient.  <ulink url="&gtk-tree-store;">
    <code>gtk-tree-store</code></ulink> and <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink>
    should cater for most types of data an application developer might want to display in a
    <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink>.
   </para>
   <para>
    Tree model implementations like <ulink url="&gtk-list-store;"><code>gtk-list-store</code></ulink> and
    <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink> will take care of the view side for you
    once you have configured the <ulink url="&gtk-tree-view;"><code>gtk-tree-view</code></ulink> to display
    what you want. If you change data in the store, the model will notify the tree view and your data display
    will be updated. If you add or remove rows, the model will also notify the store, and your row will
    appear in or disappear from the view as well.
   </para>

   <section id="How_Data_is_Organised_in_a_Store">
    <title>How Data is Organised in a Store</title>
    <para>
     A model (data store) has model columns and rows.  While a tree view will display each row in the model
     as a row in the view, the model's columns are not to be confused with a view's columns.  A model column
     represents a certain data field of an item that has a fixed data type.  You need to know what kind of
     data you want to store when you create a list store or a tree store, as you can not add new fields later
     on.
    </para>
    <para>
     For example, we might want to display a list of files. We would create a list store with two fields: a
     field that stores the filename (i.e. a string) and a field that stores the file size (i.e. an unsigned
     integer).  The filename would be stored in column 0 of the model, and the file size would be stored in
     column 1 of the model.  For each file we would add a row to the list store, and set the row's fields to
     the filename and the file size.
    </para>
    <para>
     The GLib type system (GType) is used to indicate what type of data is stored in a model column.  These
     are the most commonly used types:
    </para>
    <itemizedlist>
     <listitem><code>"gboolean"</code></listitem>
     <listitem><code>"gint"</code>, <code>"guint"</code></listitem>
     <listitem>
      <code>"glong"</code>, <code>"gulong"</code>, <code>"gint64"</code>, <code>"guint64"</code>
     </listitem>
     <listitem><code>"gfloat"</code>, <code>"gdouble"</code></listitem>
     <listitem><code>"gchararray"</code></listitem>
     <listitem><code>"gpointer"</code></listitem>
     <listitem><code>"GdkPixbuf"</code></listitem>
    </itemizedlist>
    <para>
     You do not need to understand the type system, it will usually suffice to know the above types, so you
     can tell a list store or tree store what kind of data you want to store.  Storing GObject-derived types
     is a special case that is dealt with further below.
    </para>
    <para>
     Here is an example of how to create a list store:
    </para>
    <programlisting>
(let ((store (make-instance 'gtk-list-store
                            :column-types '("gchararray" "guint"))))
  ... )
    </programlisting>
    <para>
     This creates a new list store with two columns.  Column 0 stores a string and column 1 stores an
     unsigned integer for each row.  At this point the model has no rows yet of course.  Before we start to
     add rows, let's have a look at the different ways used to refer to a particular row.
    </para>
   </section>

   <section id="Refering_to_Rows">
    <title>Refering to Rows</title>

    <section id="GtkTreePath">
     <title>GtkTreePath</title>
     <para>
      There are different ways to refer to a specific row.  The two you will have to deal with are
      <ulink url="&gtk-tree-iter;"><code>gtk-tree-iter</code></ulink> and <ulink url="&gtk-tree-path;">
      <code>gtk-tree-path</code></ulink>.
     </para>
     <para>
      A <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink> is a comparatively straight-forward
      way to describe the logical position of a row in the model.  As a <ulink url="&gtk-tree-view;">
      <code>gtk-tree-view</code></ulink> always displays all rows in a model, a tree path always describes
      the same row in both model and view.
     </para>
     <figure id="figure-tree-path">
      <title>Tree Path</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="figures/tree-path.png" format="png"></imagedata>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      The picture shows the tree path in string form next to the label.  Basically, it just counts the
      children from the imaginary root of the tree view.  An empty tree path string would specify that
      imaginary invisible root.  Now 'Songs' is the first child (from the root) and thus its tree path is
      just "0". 'Videos' is the second child from the root, and its tree path is "1".  'oggs' is the second
      child of the first item from the root, so its tree path is "0:1".  So you just count your way down from
      the root to the row in question, and you get your tree path.
     </para>
     <para>
      The implication of this way of refering to rows is as follows: if you insert or delete rows in the
      middle or if the rows are resorted, a tree path might suddenly refer to a completely different row than
      it refered to before the insertion/deletion/resorting.  This is important to keep in mind.  See the
      section on <code>GtkTreeRowReferences</code> below for a tree path that keeps updating itself to make
      sure it always refers to the same row when the model changes.
     </para>
     <para>
      You can get a new <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink> from a path in string
      form using the function <ulink url="&gtk-tree-path-new-from-string;">
      <code>gtk-tree-path-new-from-string</code></ulink>, and you can convert a given
      <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink> into its string notation with the
      function <ulink url="&gtk-tree-path-to-string;"><code>gtk-tree-path-to-string</code></ulink>.  Usually
      you will rarely have to handle the string notation, it is described here merely to demonstrate the
      concept of tree paths.
     </para>
     <para>
      Instead of the string notation, <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink> uses an
      integer array internally.  You can get the depth, i.e. the nesting level, of a tree path with the
      function <ulink url="&gtk-tree-path-depth;"><code>gtk-tree-path-depth</code></ulink>.  A depth of 0 is
      the imaginary invisible root node of the tree view and model.  A depth of 1 means that the tree path
      describes a top-level row.  As lists are just trees without child nodes, all rows in a list always have
      tree paths of depth 1.  The function <ulink url="&gtk-tree-path-indices;">
      <code>gtk-tree-path-indices</code></ulink> returns the internal integer array of a tree path.  You will
      rarely need to operate with those either.
     </para>
     <para>
      If you operate with tree paths, you are most likely to use a given tree path, and use functions like
      <ulink url="&gtk-tree-path-up;"><code>gtk-tree-path-up</code></ulink>,
      <ulink url="&gtk-tree-path-down;"><code>gtk-tree-path-down</code></ulink>,
      <ulink url="&gtk-tree-path-next;"><code>gtk-tree-path-next</code></ulink>,
      <ulink url="&gtk-tree-path-prev;"><code>gtk-tree-path-prev</code></ulink>,
      <ulink url="&gtk-tree-path-is-ancestor;"><code>gtk-tree-path-is-ancestor</code></ulink>, or
      <ulink url="&gtk-tree-path-is-descendant;"><code>gtk-tree-path-is-descendant</code></ulink>.  Note
      that this way you can construct and operate on tree paths that refer to rows that do not exist in model
      or view.  The only way to check whether a path is valid for a specific model, i.e. the row described
      by the path exists, is to convert the path into an iter using the function
      <ulink url="&gtk-tree-model-iter;"><code>gtk-tree-model-iter</code></ulink>.
     </para>
     <para>
      <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink> is an opaque structure, with its
      details hidden from the compiler.  If you need to make a copy of a tree path, use the function
      <ulink url="&gtk-tree-path-copy;"><code>gtk-tree-path-copy</code></ulink>.
     </para>
    </section>

    <section id="GtkTreeIter">
     <title>GtkTreeIter</title>
     <para>
      Another way to refer to a row in a list or tree is <ulink url="&gtk-tree-iter;">
      <code>gtk-tree-iter</code></ulink>.  A tree iter is just a structure that contains a couple of pointers
      that mean something to the model you are using.  Tree iters are used internally by models, and they
      often contain a direct pointer to the internal data of the row in question.  You should never look at
      the content of a tree iter and you must not modify it directly either.  All tree models, and therefore
      also <ulink url="&gtk-list-store;"><code>gtk-list-store</code></ulink> and
      <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink>, must support the
      <ulink url="&gtk-tree-model;"><code>gtk-tree-model</code></ulink> functions that operate on tree iters.
      Some of these functions are:
     </para>
     <table id="table-gtk-tree-model" frame='all'>
      <title>Functions for GtkTreeModel</title>
      <tgroup cols='2' align='left' colsep='0' rowsep='0'>
       <thead>
        <row>
         <entry>Function&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-first</code></entry>
         <entry valign="top">Sets the given iter to the first top-level item in the list or tree.</entry>
        </row>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-next</code></entry>
         <entry valign="top">
          Sets the given iter to the next item at the current level in a list or tree.
         </entry>
        </row>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-children</code></entry>
         <entry valign="top">
          Sets the first given iter to the first child of the row referenced by the second iter; not very
          useful for lists, mostly useful for trees.
         </entry>
        </row>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-n-children</code></entry>
         <entry valign="top">
          Returns the number of children the row referenced by the provided iter has. If you pass
          <code>nil</code> instead of iter structure, this function will return the number of top-level
          rows. You can also use this function to count the number of items in a list store.
         </entry>
        </row>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-nth-child</code></entry>
         <entry valign="top">
          Sets the first iter to the n-th child of the row referenced by the second iter. If you pass
          <code>nil</code> instead of an iter structure as the second iter, you can get the first iter set
          to the n-th row of a list.
         </entry>
        </row>
        <row>
         <entry valign="top"><code>gtk-tree-model-iter-parent</code></entry>
         <entry valign="top">
          Sets the first iter to the parent of the row referenced by the second iter; does nothing for
          lists, only useful for trees.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Almost all of those functions return <emphasis>true</emphasis> if the requested operation succeeded,
      and return <code>nil</code> otherwise.  There are more functions that operate on iters.  Check out the
      <ulink url="&gtk-tree-model;"><code>gtk-tree-model</code></ulink> API reference for details.
     </para>
     <para>
      You might notice that there is no <code>gtk-tree-model-iter-prev</code>.  This is unlikely to be
      implemented for a variety of reasons.  It should be fairly simple to write a helper function that
      provides this functionality though once you have read this section.
     </para>
     <para>
      Tree iters are used to retrieve data from the store, and to put data into the store.  You also get a
      tree iter as result if you add a new row to the store using the functions
      <ulink url="&gtk-list-store-append;"><code>gtk-list-store-append</code></ulink> or
      <ulink url="&gtk-tree-store-append;"><code>gtk-tree-store-append</code></ulink>.
     </para>
     <para>
      Tree iters are often only valid for a short time, and might become invalid if the store changes with
      some models.  It is therefore usually a bad idea to store tree iters, unless you really know what you
      are doing.  You can use the function <ulink url="&gtk-tree-model-flags;">
      <code>gtk-tree-model-flags</code></ulink> to get a model's flags, and check whether the
      <code>:iters-persist</code> flag is set, in which case a tree iter will be valid as long as a row
      exists, yet still it is not advisable to store iter structures unless you really mean to do that.
      There is a better way to keep track of a row over time: <code>GtkTreeRowReference</code>.
     </para>
    </section>

    <section id="GtkTreeRowReference">
     <title>GtkTreeRowReference</title>
     <para>
      A <ulink url="&gtk-tree-row-reference;"><code>gtk-tree-row-reference</code></ulink> is basically an
      object that takes a tree path, and watches a model for changes.  If anything changes, like rows getting
      inserted or removed, or rows getting re-ordered, the tree row reference object will keep the given tree
      path up to date, so that it always points to the same row as before.  In case the given row is removed,
      the tree row reference will become invalid.
     </para>
     <para>
      A new tree row reference can be created with the function <ulink url="&gtk-tree-row-reference-new;">
      <code>gtk-tree-row-reference-new</code></ulink>, given a model and a tree path.  After that, the tree
      row reference will keep updating the path whenever the model changes. The current tree path of the row
      originally refered to when the tree row reference was created can be retrieved with the function
      <ulink url="&gtk-tree-row-reference-path;"><code>gtk-tree-row-reference-path</code></ulink>.  If the
      row has been deleted, <code>nil</code> will be returned instead of of a tree path.
     </para>
     <para>
      You can check whether the row referenced still exists with the function
      <ulink url="&gtk-tree-row-reference-valid;"><code>gtk-tree-row-reference-valid</code></ulink>.
     </para>
     <para>
      For the curious: internally, the tree row reference connects to the tree model's "row-inserted",
      "row-deleted", and "rows-reordered" signals and updates its internal tree path whenever something
      happened to the model that affects the position of the referenced row.
     </para>
     <para>
      Note that using tree row references entails a small overhead.  This is hardly significant for 99.9 % of
      all applications out there, but when you have multiple thousands of rows and/or row references, this
      might be something to keep in mind, because whenever rows are inserted, removed, or reordered, a signal
      will be sent out and processed for each row reference.
     </para>
     <para>
      If you have read the tutorial only up to here so far, it is hard to explain really what tree row
      references are good for.  An example where tree row references come in handy can be found further below
      in the section on removing multiple rows in one go.
     </para>
     <para>
      In practice, a programmer can either use tree row references to keep track of rows over time, or store
      tree iters directly, if, and only if, the model has persistent iters.  Both
      <ulink url="&gtk-list-store;"><code>gtk-list-store</code></ulink> and
      <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink> have persistent iters, so storing
      iters is possible.  However, using tree row references is definitively the right way to do things, even
      though it comes with some overhead that might impact performance in case of trees that have a very
      large number of rows, in that case it might be preferable to write a custom model anyway though.
      Especially beginners might find it easier to handle and store tree row references than iters, because
      tree row references are handled by pointer value, which you can easily add to a list or pointer array,
      while it is easy to store tree iters in a wrong way.
     </para>
    </section>

    <section id="Usage">
     <title>Usage</title>
     <para>
      Tree iters can easily be converted into tree paths using the function
      <ulink url="&gtk-tree-model-path;"><code>gtk-tree-model-path</code></ulink>, and tree paths can easily
      be converted into tree iters using the function <ulink url="&gtk-tree-model-iter;">
      <code>gtk-tree-model-iter</code></ulink>.  Here is an example that shows how to get the iter from the
      tree path that is passed to us from the tree view in the "row-activated" signal callback.  We need the
      iter here to retrieve data from the store.
     </para>
     <example id="example-row-activated">
      <title>Converting a gtk-tree-path into a gtk-tree-iter</title>
      <programlisting>
;; Signal handler for the signal "row-activated"
(g-signal-connect view "row-activated"
   (lambda (view path col)
     (declare (ignore col))
     (let* ((model (gtk-tree-view-get-model view))
            ;; Get the iter from the path
            (iter (gtk-tree-model-get-iter model path)))
       (when iter
         (format t
                 "The row containing the name ~A has been double-clicked.~%"
                 (gtk-tree-model-get-value model iter 0))))))
      </programlisting>
     </example>
     <para>
      Tree row references reveal the current path of a row with the function
      <ulink url="&gtk-tree-row-reference-path;"><code>gtk-tree-row-reference-path</code></ulink>.  There is
      no direct way to get a tree iter from a tree row reference, you have to retrieve the tree row
      reference's path first and then convert that into a tree iter.  As tree iters are only valid for a
      short time, they are usually allocated on the stack, as in the following example (keep in mind that
      <ulink url="&gtk-tree-iter;"><code>gtk-tree-iter</code></ulink> is just a structure that contains data
      fields you do not need to know anything about).
     </para>
     <example id="example-traverse-list">
      <title>Going through every row in a list store</title>
      <programlisting>
;; A signal handler which goes through every row in a list store
(g-signal-connect button "clicked"
   (lambda (button)
     (declare (ignore button))
     (let ((model (gtk-tree-view-get-model view)))
       (do ((iter (gtk-tree-model-get-iter-first model)
                  (gtk-tree-model-iter-next model iter)))
           ((not iter))
           (gtk-list-store-set-value model iter 1 0)))))
      </programlisting>
     </example>
     <para>
      The code above asks the model to fill the iter structure to make it point to the first row in the list
      store.  If there is a first row and the list store is not empty, the iter will be set, and the function
      <ulink url="&gtk-tree-model-iter-first;"><code>gtk-tree-model-iter-first</code></ulink> will return
      <emphasis>true</emphasis>.  If there is no first row, it will just return <code>nil</code>.  If a first
      row exists, the while loop will be entered and we change some of the first row's data.  Then we ask
      the model to make the given iter point to the next row, until there are no more rows, which is when the
      function <ulink url="&gtk-tree-model-iter-next;"><code>gtk-tree-model-iter-next</code></ulink> returns
      <code>nil</code>.  Instead of traversing the list store we could also have used
      <ulink url="&gtk-tree-model-foreach;"><code>gtk-tree-model-foreach</code></ulink>.
     </para>
    </section>
   </section>

   <section id="Adding_Rows_to_a_Store">
    <title>Adding Rows to a Store</title>

    <section id="Adding Rows to a List Store">
     <title>Adding Rows to a List Store</title>
     <para>
      Rows are added to a list store with the function <ulink url="&gtk-list-store-append;">
      <code>gtk-list-store-append</code></ulink>. This will insert a new empty row at the end of the list.
      There are other functions, documented in the <ulink url="&gtk-list-store;">
      <code>gtk-list-store</code></ulink> API reference, that give you more control about where exactly the
      new row is inserted, but as they work very similar to the function
      <ulink url="&gtk-list-store-append;"><code>gtk-list-store-append</code></ulink> and are fairly
      straight-forward to use, we will not deal with them here.  Here is a simple example of how to create a
      list store and add an empty row to it.
     </para>
     <programlisting>
(let* ((model (make-instance 'gtk-tree-store
                             :column-types '("gchararray")))
       ;; Append an empty row to the list store
       (iter (gtk-list-store-append model nil)))
  ... )
     </programlisting>
     <para>
      This in itself is not very useful yet of course.  We will add data to the rows in the next section.
     </para>
    </section>    

    <section id="Adding Rows to a Tree Store">
     <title>Adding Rows to a Tree Store</title>
     <para>
      Adding rows to a tree store works similar to adding rows to a list store, only that the function
      <ulink url="&gtk-tree-store-append;"><code>gtk-tree-store-append</code></ulink> is the function to use
      and one more argument is required, namely the tree iter to the parent of the row to insert.  If you
      supply <code>nil</code> instead of providing the tree iter of another row, a new top-level row will be
      inserted.  If you do provide a parent tree iter, the new empty row will be inserted after any already
      existing children of the parent.  Again, there are other ways to insert a row into the tree store and
      they are documented in the <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink> API
      reference manual.  Another short example
     </para>
     <programlisting>
(let* ((model (make-instance 'gtk-tree-store
                             :column-types '("gchararray")))
       ;; Append an empty top-level row to the tree store.
       ;; Iter will point to the new row.
       (iter (gtk-tree-store-append model nil))
       (child nil))
  ;; Append another empty top-level row to the tree store.
  (setf iter (gtk-tree-store-append model nil))
  ;; Append a child to the row we just added.
  (setf child (gtk-tree-store-append model iter))
  ;; Get the first row, and add a child to it as well (could have been done
  ;; right away earlier of course, this is just for demonstration purposes)
  (setf iter (gtk-tree-model-get-iter-first model))
  (setf child (gtk-tree-store-append model iter))
  ... )
     </programlisting>
    </section>

    <section id="Speed_Issues_when_Adding_a_Lot_of_Rows">
     <title>Speed Issues when Adding a Lot of Rows</title>
     <para>
      A common scenario is that a model needs to be filled with a lot of rows at some point, either at
      start-up, or when some file is opened.  An equally common scenario is that this takes an awfully long
      time even on powerful machines once the model contains more than a couple of thousand rows, with an
      exponentially decreasing rate of insertion.  As already pointed out above, writing a custom model might
      be the best thing to do in this case.  Nevertheless, there are some things you can do to work around
      this problem and speed things up a bit even with the stock Gtk+ models:
     </para>
     <para>
      Firstly, you should detach your list store or tree store from the tree view before doing your mass
      insertions, then do your insertions, and only connect your store to the tree view again when you are
      done with your insertions. Like this:
     </para>
     <programlisting>
(let ((model (gtk-tree-view-get-model view)))
  ;; Detach model from view
  (gtk-tree-view-set-model view nil)

  ... insert a couple of thousand rows ...

  ;; Re-attach model to view
  (gtk-tree-view-set-model view model)

  ...)
     </programlisting>
     <para>
      Secondly, you should make sure that sorting is disabled while you are doing your mass insertions,
      otherwise your store might be resorted after each and every single row insertion, which is going to be
      everything but fast.  Thirdly, you should not keep around a lot of tree row references if you have so
      many rows, because with each insertion (or removal) every single tree row reference will check whether
      its path needs to be updated or not.
     </para>
    </section>
   </section>

   <section id="Manipulating Row Data">
    <title>Manipulating Row Data</title>
    <para>
     Adding empty rows to a data store is not terribly exciting, so let's see how we can add or change data
     in the store.  The functions <ulink url="&gtk-list-store-set;"><code>gtk-list-store-set</code></ulink>
     and <ulink url="&gtk-tree-store-set;"><code>gtk-tree-store-set</code></ulink> are used to manipulate a
     given row's data. There is also <ulink url="&gtk-list-store-set-value;">
     <code>gtk-list-store-set-value</code></ulink> and <ulink url="&gtk-tree-store-set-value;">
     <code>gtk-tree-store-set-value</code></ulink>, but those should only be used by people familiar with
     GLib's GValue system.
    </para>
    <para>
     Both functions <ulink url="&gtk-list-store-set;"><code>gtk-list-store-set</code></ulink> and
     <ulink url="&gtk-tree-store-set;"><code>gtk-tree-store-set</code></ulink> take a variable number of
     arguments.  The first two arguments are a pointer to the model, and the iter pointing to the row whose
     data we want to change.  They are followed by a variable number of (column, data) argument pairs.  The
     column refers to the model column number and is usually an enum value (to make the code more readable
     and to make changes easier).  The data should be of the same data type as the model column.  Here is an
     example where we create a store that stores two strings and one integer for each row:
    </para>
    <programlisting>
(let ((model (make-instance 'gtk-list-store
                            :column-types '("gchararray" "guint"))))
  (gtk-list-store-set model (gtk-list-store-append model)
                            "Klaus-Dieter Mustermann" 51)
  ... )
    </programlisting>
    <para>
     You do not need to worry about allocating and freeing memory for the data to store.  The model (or more
     precisely: the GLib/GObject GType and GValue system) will take care of that for you.  If you store a
     string, for example, the model will make a copy of the string and store that.  If you then set the field
     to a new string later on, the model will automatically free the old string and again make a copy of the
     new string and store the copy.  This applies to almost all types, be it <code>G_TYPE_STRING</code> or
     <code>GDK_TYPE_PIXBUF</code>.
    </para>
    <para>
     The exception to note is <code>G_TYPE_POINTER</code>.  If you allocate a chunk of data or a complex
     structure and store it in a <code>G_TYPE_POINTER</code> field, only the pointer value is stored.  The
     model does not know anything about the size or content of the data your pointer refers to, so it could
     not even make a copy if it wanted to, so you need to allocate and free the memory yourself in this case.
     However, if you do not want to do that yourself and want the model to take care of your custom data for
     you, then you need to register your own type and derive it from one of the GLib fundamental types
     (usually <code>G_TYPE_BOXED</code>).  See the GObject GType reference manual for details.  Making a copy
     of data involves memory allocation and other overhead of course, so one should consider the performance
     implications of using a custom GLib type over a <code>G_TYPE_POINTER</code> carefully before taking that
     approach.  Again, a custom model might be the better alternative, depending on the overall amount of
     data to be stored (and retrieved).
    </para>
   </section>

   <section id="Retrieving Row Data">
    <title>Retrieving Row Data</title>
    <para>
     Storing data is not very useful if it cannot be retrieved again.  This is done using the function
     <ulink url="&gtk-tree-model-get;"><code>gtk-tree-model-get</code></ulink>, which takes similar arguments
     as the functions <ulink url="&gtk-list-store-set;"><code>gtk-list-store-set</code></ulink> or
     <ulink url="&gtk-tree-store-set;"><code>gtk-tree-store-set</code></ulink> do, only that it takes
     (column, pointer) arguments.  The pointer must point to a variable that is of the same type as the data
     stored in that particular model column.
    </para>
    <para>
     Here is the previous example extended to traverse the list store and print out the data stored.  As an
     extra, we use the function <ulink url="&gtk-tree-model-foreach;">
     <code>gtk-tree-model-foreach</code></ulink> to traverse the store and retrieve the row number from the
     GtkTreePath passed to us in the foreach callback function:
    </para>
    <programlisting>
(defun foreach-func (model path iter)
  (let ((first-name (gtk-tree-model-get-value model iter 0))
        (last-name (gtk-tree-model-get-value model iter 1))
        (age (gtk-tree-model-get-value model iter 2))
        (tree-path (gtk-tree-path-to-string path)))
    (format t "Row ~A: ~A ~A, age ~A~%" tree-path first-name last-name age)))

(defun create-and-fill-and-dump-model ()
  (let ((model (make-instance 'gtk-list-store
                              :column-types
                              '("gchararray" "gchararray" "guint"))))
    ;; Fill the model with data
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Klaus-Dieter" "Mustermann" 51)
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Ulrike" "Langhals" 23)
    (gtk-list-store-set model (gtk-list-store-append model)
                              "Marius" "Kalinowski" 91)
    ;; Now traverse the list
    (gtk-tree-model-foreach model #'foreach-func)))
    </programlisting>
    <para>
     Note that when a new row is created, all fields of a row are set to a default <code>nil</code> value
     appropriate for the data type in question.  A field of type <code>G_TYPE_INT</code> will automatically
     contain the value 0 until it is set to a different value, and strings and all kind of pointer types will
     be <code>nil</code> until set to something else.  Those are valid contents for the model, and if you
     are not sure that row contents have been set to something, you need to be prepared to handle
     <code>NULL</code> pointers and the like in your code.  Run the above program with an additional empty
     row and look at the output to see this in effect.
    </para>
   </section>

   <section id="Removing Rows">
    <title>Removing Rows</title>
    <para>
     Rows can easily be removed with the functions <ulink url="&gtk-list-store-remove;">
     <code>gtk-list-store-remove</code></ulink> and <ulink url="&gtk-tree-store-remove;">
     <code>gtk-tree-store-remove</code></ulink>.  The removed row will automatically be removed from the tree
     view as well, and all data stored will automatically be freed, with the exception of G_TYPE_POINTER
     columns (see above).
    </para>
    <para>
     Removing a single row is fairly straight forward: you need to get the iter that identifies the row you
     want to remove, and then use one of the above functions. Here is a simple example that removes a row
     when you double-click on it (bad from a user interface point of view, but then it is just an example):
    </para>
    <programlisting>
;; Signal handler for the signal "row-activated"
(g-signal-connect view "row-activated"
  (lambda (view path col)
    (declare (ignore col))
    (let* ((model (gtk-tree-view-get-model view))
           (iter (gtk-tree-model-get-iter model path)))
      (when iter
        (gtk-list-store-remove model iter)))))
    </programlisting>
    <para>
     If you want to remove the n-th row from a list (or the n-th child of a tree node), you have two
     approaches: either you first create a <ulink url="&gtk-tree-path;"><code>gtk-tree-path</code></ulink>
     that describes that row and then turn it into an iter and remove it; or you take the iter of the parent
     node and use the function <ulink url="&gtk-tree-model-iter-nth-child;">
     <code>gtk-tree-model-iter-nth-child</code></ulink> (which will also work for list stores if you use
     <code>nil</code> as the parent iter. Of course you could also start with the iter of the first top-level
     row, and then step-by-step move it to the row you want, although that seems a rather awkward way of
     doing it.  The following code snippet will remove the n-th row of a list if it exists:
    </para>
    <programlisting>
;; Removes the nth row of a list store if it exists.
(defun list-store-remove-nth-row (store n)
  (let (;; nil means the parent is the virtual root node, so the
        ;; n-th top-level element is returned in iter, which is
        ;; the n-th row in a list store as a list store only has
        ;; top-level elements, and no children
        (iter (gtk-tree-model-nth-child store nil n)))
    (when iter
      (gtk-list-store-remove store iter))))
    </programlisting>
    <para>
     Removing multiple rows at once can be a bit tricky at times, and requires some thought on how to do this
     best.  For example, it is not possible to traverse a store with the function
     <ulink url="&gtk-tree-model-foreach;"><code>gtk-tree-model-foreach</code></ulink>, check in the callback
     function whether the given row should be removed and then just remove it by calling one of the stores'
     remove functions.  This will not work, because the model is changed from within the foreach loop, which
     might suddenly invalidate formerly valid tree iters in the foreach function, and thus lead to
     unpredictable results.
    </para>
    <para>
     Here is an example for an alternative approach to removing multiple rows in one go. Here we want to
     remove all rows from the store that contain persons that are older than 30, but it could just as well be
     all selected rows or some other criterion:
    </para>
    <programlisting>
...

(let ((rowref-list nil))
  (defun foreach-func (model path iter)
    (let ((age (gtk-tree-model-get-value model iter 2)))
      (when (> age 30)
        (let ((rowref (gtk-tree-row-reference-new model path)))
          (setf rowref-list (cons rowref rowref-list))))
      nil))

  (defun remove-people-older-than (model)
    (setf rowref-list nil)
    (gtk-tree-model-foreach model #'foreach-func)
    (dolist (rowref rowref-list)
      (let ((path (gtk-tree-row-reference-path rowref)))
      (when path
        (let ((iter (gtk-tree-model-get-iter model path)))
          (when iter
            (gtk-list-store-remove model iter))))))))

...
    </programlisting>
    <para>
     The functions <ulink url="&gtk-list-store-clear;"><code>gtk-list-store-clear</code></ulink> and
     <ulink url="&gtk-tree-store-clear;"><code>gtk-tree-store-clear</code></ulink> come in handy if you want
     to remove all rows.
    </para>
 
<!-- @subsection Storing GObjects (Pixbufs etc.) -->

   </section>
  </section>

  <section id="Creating_a_Tree_View">
   <title>Creating a Tree View</title>
   <para>
    In order to display data in a tree view widget, we need to create one first, and we need to instruct it
    where to get the data to display from.  A new tree view is created with:
   </para>
   <programlisting>
(let ((view (make-instance 'gtk-tree-view)))
  ... )
   </programlisting>

   <section id="Connecting_Tree_View_and_Model">
    <title>Connecting Tree View and Model</title>
    <para>
     Before we proceed to the next section where we display data on the screen, we need connect our data
     store to the tree view, so it knows where to get the data to display from.  This is achieved with the
     function <ulink url="&gtk-tree-view-model;"><code>gtk-tree-view-model</code></ulink>, which will by
     itself do very little.  However, it is a prerequisite for what we do in the following sections.
    </para>
    <para>
     The function <ulink url="&gtk-tree-view-new-with-model;">
     <code>gtk-tree-view-new-with-model</code></ulink> is a convenience function for the previous two.  The
     function <ulink url="&gtk-tree-view-model;"><code>gtk-tree-view-model</code></ulink> will return the
     model that is currently attached to a given tree view, which is particularly useful in callbacks where
     you only get passed the tree view widget (after all, we do not want to go down the road of global
     variables, which will inevitably lead to the Dark Side, do we?).
    </para>

    <section id="Reference_counting">
     <title>Reference counting</title>
     <para>
      Tree models like <ulink url="&gtk-list-store;"><code>gtk-list-store</code></ulink> and
      <ulink url="&gtk-tree-store;"><code>gtk-tree-store</code></ulink> are GObjects and have a reference
      count of 1 after creation.  The tree view will add its own reference to the model when you add the
      model with the function <ulink url="&gtk-tree-view-model;"><code>gtk-tree-view-model</code></ulink>,
      and will unref it again when you replace the model with another model, unset the model by passing
      <code>nil</code> as a model, or when the tree view is destroyed.
     </para>
     <para>
      This means that you need to take care of "your" reference yourself, otherwise the model will not be
      destroyed properly when you disconnect it from the tree view, and its memory will not be freed (which
      does not matter much if the same model is connected to the tree view from application start to end).
      If you plan to use the same model for a tree view for the whole duration of the application, you can
      get rid of "your" reference right after you have connected the model to the view - then the model will
      be destroyed automatically when the tree view is destroyed (which will be automatically destroyed when
      the window it is in is destroyed):
     </para>
     <programlisting>
(let* ((model (make-instance 'gtk-list-store
                             :column-types '("gchararray")))
       (view (make-instance 'gtk-tree-view
                            :model model)))
  ... )
     </programlisting>
    </section>
   </section>

   <section id="Tree View Look and Feel">
    <title>Tree View Look and Feel</title>
    <para>
     There are a couple of ways to influence the look and feel of the tree view.  You can hide or show
     column headers with the function <ulink url="&gtk-tree-view-headers-visible;">
     <code>gtk-tree-view-headers-visible</code></ulink>, and set them clickable or not with the function
     <ulink url="&gtk-tree-view-headers-clickable;"><code>gtk-tree-view-headers-clickable</code></ulink>
     (which will be done automatically for you if you enable sorting).
    </para>
    <para>
     The function <ulink url="&gtk-tree-view-rules-hint;"><code>gtk-tree-view-rules-hint</code></ulink> will
     enable or disable rules in the tree view.  'Rules' means that every second line of the tree view has a
     shaded background, which makes it easier to see which cell belongs to which row in tree views that have
     a lot of columns.  As the function name implies, this setting is only a hint; in the end it depends on
     the active Gtk+ theme engine if the tree view shows ruled lines or not.  Users seem to have strong
     feelings about rules in tree views, so it is probably a good idea to provide an option somewhere to
     disable rule hinting if you set it on tree views (but then, people also seem to have strong feelings
     about options abundance and 'sensible' default options, so whatever you do will probably upset someone
     at some point).
    </para>
    <para>
     The expander column can be set with the function <ulink url="&gtk-tree-view-expander-column;">
     <code>gtk-tree-view-expander-column</code></ulink>.  This is the column where child elements are
     indented with respect to their parents, and where rows with children have an 'expander' arrow with which
     a node's children can be collapsed (hidden) or expanded (shown). By default, this is the first column.
    </para>
   </section>
  </section>

  <section id="Mapping_Data_to_the_Screen">
   <title>Mapping Data to the Screen</title>
   <para>
    As outlined above, tree view columns represent the visible columns on the screen that have a column
    header with a column name and can be resized or sorted.  A tree view is made up of tree view columns,
    and you need at least one tree view column in order to display something in the tree view.  Tree view
    columns, however, do not display anything by themselves, this is done by specialised
    <ulink url="&gtk-cell-renderer;"><code>gtk-cell-renderer</code></ulink> objects.  Cell renderers are
    packed into tree view columns much like widgets are packed into &gtk-box; widgets.
   </para>
   <para>
    Here is a diagram (courtesy of Owen Taylor) that pictures the relationship between tree view columns and
    cell renderers:
   </para>
   <figure id="figure-tree-view-column">
    <title>GtkTreeViewColumn</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/tree-view-column.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    In the above diagram, both 'Country' and 'Representative' are tree view columns, where the 'Country' and
    'Representative' labels are the column headers.  The 'Country' column contains two cell renderers, one to
    display the flag icons, and one to display the country name.  The 'Representative' column only contains
    one cell renderer to display the representative's name.
   </para>

   <section id="Cell_Renderers">
    <title>Cell Renderers</title>
    <para>
     Cell renderers are objects that are responsible for the actual rendering of data within a
     <ulink url="&gtk-tree-view-column;"><code>gtk-tree-view-column</code></ulink>.  They are basically just
     GObjects (i.e. not widgets) that have certain properties, and those properties determine how a
     single cell is drawn.
    </para>
    <para>
     In order to draw cells in different rows with different content, a cell renderer's properties need to be
     set accordingly for each single row/cell to render.  This is done either via attributes or cell data
     functions (see below). If you set up attributes, you tell Gtk which model column contains the data from
     which a property should be set before rendering a certain row.  Then the properties of a cell renderer
     are set automatically according to the data in the model before each row is rendered.  Alternatively,
     you can set up cell data functions, which are called for each row to be rendererd, so that you can
     manually set the properties of the cell renderer before it is rendered.  Both approaches can be used at
     the same time as well.  Lastly, you can set a cell renderer property when you create the cell renderer.
     That way it will be used for all rows/cells to be rendered (unless it is changed later of course).
    </para>
    <para>
     Different cell renderers exist for different purposes:
    </para>
    <table id="table-gtk-cell-renderer" frame='all'>
     <title>GtkCellRenderer</title>
     <tgroup cols='2' align='left' colsep='0' rowsep='0'>
      <thead>
       <row>
        <entry>Class&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry valign="top"><code>gtk-cell-renderer-text</code></entry>
        <entry valign="top">
         Renders strings or numbers or boolean values as text ("Joe", "99.32", "true").
        </entry>
       </row>
       <row>
        <entry valign="top"><code>gtk-cell-renderer-pixbuf</code></entry>
        <entry valign="top">
         Is used to display images; either user-defined images, or one of the stock icons that come with
         Gtk+.
        </entry>
       </row>
       <row>
        <entry valign="top"><code>gtk-cell-renderer-toggle</code></entry>
        <entry valign="top">
         Displays a boolean value in form of a check box or as a radio button.
        </entry>
       </row>
       <row>
        <entry valign="top"><code>gtk-cell-editable</code></entry>
        <entry valign="top">
         Is a special cell that implements editable cells (i.e. <ulink url="&gtk-entry;">
         <code>gtk-entry</code></ulink> or <ulink url="&gtk-spin-button;">
         <code>gtk-spin-button</code></ulink> in a treeview).  This is not a cell renderer!  If you
         want to have editable text cells, use <ulink url="&gtk-cell-renderer-text;">
         <code>gtk-cell-renderer-text</code></ulink> and make sure the "editable" property is set.
         <ulink url="&gtk-cell-editable;"><code>gtk-cell-editable</code></ulink> is only used by
         implementations of editable cells and widgets that can be inside of editable cells.  You are
         unlikely to ever need it.
        </entry>
       </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Contrary to what one may think, a cell renderer does not render just one single cell, but is responsible
    for rendering part or whole of a tree view column for each single row.  It basically starts in the first
    row and renders its part of the column there.  Then it proceeds to the next row and renders its part of
    the column there again.  And so on.
   </para>
   <para>
    How does a cell renderer know what to render? A cell renderer object has certain 'properties' that are
    documented in the API reference (just like most other objects, and widgets).  These properties determine
    what the cell renderer is going to render and how it is going to be rendered.  Whenever the cell renderer 
    is called upon to render a certain cell, it looks at its properties and renders the cell accordingly.
    This means that whenever you set a property or change a property of the cell renderer, this will affect
    all rows that are rendered after the change, until you change the property again.
   </para>
   <para>
    Here is a diagram (courtesy of Owen Taylor) that tries to show what is going on when rows are rendered:
   </para>
   <figure id="figure-cell-renderer-properties">
    <title>Cell Renderer Properties</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/cell-renderer-properties.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The above diagram shows the process when attributes are used. In the example, a text cell renderer's
    "text" property has been linked to the first model column. The "text" property contains the string to be
    rendered.  The "foreground" property, which contains the colour of the text to be shown, has been linked
    to the second model column.  Finally, the "strikethrough" property, which determines whether the text
    should be with a horizontal line that strikes through the text, has been connected to the third model
    column (of type <code>G_TYPE_BOOLEAN</code>).
   </para>
   <para>
    With this setup, the cell renderer's properties are 'loaded' from the model before each cell is rendered.
   </para>
   <para>
    Here is a silly and utterly useless little example that demonstrates this behaviour, and introduces some
    of the most commonly used properties of <ulink url="&gtk-cell-renderer-text;">
    <code>gtk-cell-renderer-text</code></ulink>:
   </para>
   <programlisting>
(defun create-and-fill-model ()
  (let ((model (make-instance 'gtk-tree-store
                              :column-types '("gchararray" "gchararray"))))
    ;; Append a top level row and leave it empty
    (gtk-tree-store-append model nil)
    ;; Append a second top level row, and fill it with some data
    (let ((parent (gtk-tree-store-set model (gtk-tree-store-append model nil)
                                            "Joe" "Average")))
      ;; Append a child to the second top level row, and fill in some data
      (gtk-tree-store-set model (gtk-tree-store-append model parent)
                                "Jane" "Average"))
    model))

(defun create-view-and-model ()
  (let* ((model (create-and-fill-model))
         (view (make-instance 'gtk-tree-view
                              :model model)))
  ;; Create the first column
  (let* ((column (make-instance 'gtk-tree-view-column
                                :title "First Name"))
         (renderer (make-instance 'gtk-cell-renderer-text
                                  :text "Booooo!")))
    ;; pack tree view column into tree view
    (gtk-tree-view-append-column view column)
    ;; pack cell renderer into tree view column
    (gtk-tree-view-column-pack-start column renderer))

  ;; Create the second column
  (let* ((column (make-instance 'gtk-tree-view-column
                                :title "Last Name"))
         (renderer (make-instance 'gtk-cell-renderer-text
                                  :cell-background "Orange"
                                  :cell-background-set t)))
    ;; pack tree view column into tree view
    (gtk-tree-view-append-column view column)
    ;; pack cell renderer into tree view column
    (gtk-tree-view-column-pack-start column renderer))
  ;; No selection possible
  (setf (gtk-tree-selection-mode (gtk-tree-view-selection view)) :none)
  view))

(defun example-cell-renderer-properties ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Cell Renderer Properties"
                                 :type :toplevel
                                 :default-width 350
                                 :default-height 200))
          (view (create-view-and-model-3)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window view)
      (gtk-widget-show-all window))))
   </programlisting>
   <para>
    The above code should produce something looking like this:
   </para>
   <figure id="figure-renderer-properties">
    <title>Persistent Cell Renderer Properties</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/renderer-properties.jpg" format="jpg"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    It looks like the tree view display is partly correct and partly incomplete.  On the one hand the tree
    view renders the correct number of rows, and it displays the hierarchy correctly (on the left), but it
    does not display any of the data that we have stored in the model.  This is because we have made no
    connection between what the cell renderers should render and the data in the model.  We have simply set
    some cell renderer properties on start-up, and the cell renderers adhere to those set properties
    meticulously.
   </para>
   <para>
    There are two different ways to connect cell renderers to data in the model: attributes and cell data
    functions.
    </para>
   </section>

   <section id="Attributes">
    <title>Attributes</title>
    <para>
     An attribute is a connection between a cell renderer property and a field/column in the model.  Whenever
     a cell is to be rendered, a cell renderer property will be set to the values of the specified model
     column of the row that is to be rendered.  It is very important that the column's data type is the same
     type that a property takes according to the API reference manual. Here is some code to look at:
    </para>
    <programlisting>
(let* ((renderer (gtk-cell-renderer-text-new))
       (column (gtk-tree-view-column-new-with-attributes "Example"
                                                         renderer
                                                         "text" 0)))
  (gtk-tree-view-append-column view column)
  ... )
    </programlisting>
    <para>
     This means that the text cell renderer property "text" will be set to the string in model column 0 of
     each row to be drawn.
    </para>
    <para>
     Again, when setting attributes it is very important that the data type stored in a model column is the
     same as the data type that a property requires as argument.  Check the API reference manual to see the
     data type that is required for each property.  When reading through the example a bit further above,
     you might have noticed that we set the "cell-background" property of a
     <ulink url="&gtk-cell-renderer-text;"><code>gtk-cell-renderer-text</code></ulink>, even though the API
     documentation does not list such a property.  We can do this, because
     <ulink url="&gtk-cell-renderer-text;"><code>gtk-cell-renderer-text</code></ulink> is derived from
     <ulink url="&gtk-cell-renderer;"><code>gtk-cell-renderer</code></ulink>, which does in fact have such a
     property. Derived classes inherit the properties of their parents.  This is the same as with widgets
     that you can cast into one of their ancestor classes.  The API reference has an object hierarchy that
     shows you which classes a widget or some other object is derived from.
    </para>
    <para>
     There are two more noteworthy things about @xurl{gtk-cell-renderer} properties: one is that sometimes
     there are different properties which do the same, but take different arguments, such as the
     <code>"foreground"</code> and <code>"foreground-rgba"</code> properties of
     <ulink url="&gtk-cell-renderer-text;"><code>gtk-cell-renderer-text</code></ulink> (which specify the
     text colour).  The <code>"foreground"</code> property take a colour in string form, such as "Orange"
     or "CornflowerBlue", whereas "foreground-rgba" takes a <ulink url="&gdk-rgba;">
     <code>gdk-rgba</code></ulink> argument.  It is up to you to decide which one to use - the effect will
     be the same.  The other thing worth mentioning is that most properties have a <code>"foo-set"</code>
     property taking a boolean value as argument, such as <code>"foreground-set"</code>.  This is useful when
     you want to have a certain setting have an effect or not.  If you set the <code>"foreground"</code>
     property, but set <code>"foreground-set"</code> to <code>nil</code>, then your foreground color setting
     will be disregarded.  This is useful in cell data functions (see below), or, for example, if you want
     set the foreground colour to a certain value at start-up, but only want this to be in effect in some
     columns, but not in others (in which case you could just connect the <code>"foreground-set"</code>
     property to a model column of type <code>G_TYPE_BOOLEAN</code> with the function
     <ulink url="&gtk-tree-view-column-add-attribute;">
     <code>gtk-tree-view-column-add-attribute</code></ulink>.
    </para>
    <para>
     Setting column attributes is the most straight-forward way to get your model data to be displayed.  This
     is usually used whenever you want the data in the model to be displayed exactly as it is in the model.
    </para>
    <para>
     Another way to get your model data displayed on the screen is to set up cell data functions.
    </para>
   </section>

   <section id="Cell_Data_Functions">
    <title>Cell Data Functions</title>
    <para>
     A cell data function is a function that is called for a specific cell renderer for each single row
     before that row is rendered.  It gives you maximum control over what exactly is going to be rendered, as
     you can set the cell renderer's properties just like you want to have them.  Remember not only to set a
     property if you want it to be active, but also to unset a property if it should not be active (and it
     might have been set in the previous row).
    </para>
    <para>
     Cell data functions are often used if you want more fine-grained control over what is to be displayed,
     or if the standard way to display something is not quite like you want it to be.  A case in point are
     floating point numbers.  If you want floating point numbers to be displayed in a certain way, say with
     only one digit after the colon/comma, then you need to use a cell data function.  Use
     <ulink url="&gtk-tree-view-column-set-cell-data-func;">
     <code>gtk-tree-view-column-set-cell-data-func</code></ulink> to set up a cell data function for a
     particular cell renderer. Here is an example:
    </para>
    <programlisting>
   enum
   {
     COLUMN_NAME = 0,
     COLUMN_AGE_FLOAT,
     NUM_COLS
   };

   ...

   void
   age_cell_data_function (GtkTreeViewColumn *col,
                           GtkCellRenderer   *renderer,
                           GtkTreeModel      *model,
                           GtkTreeIter       *iter,
                           gpointer           user_data)
   {
     gfloat  age;
     gchar   buf[20];

     gtk_tree_model_get(model, iter, COLUMN_AGE_FLOAT, &#x26;age, -1);

     g_snprintf(buf, sizeof(buf), "%.1f", age);

     g_object_set(renderer, "text", buf, NULL);
   }

   ...

   liststore = gtk_list_store_new(NUM_COLS, G_TYPE_STRING, G_TYPE_FLOAT);

   col = gtk_tree_view_column_new();

   cell = gtk_cell_renderer_text_new();

   gtk_tree_view_column_pack_start(col, cell, TRUE);

   gtk_tree_view_column_set_cell_data_func(col,
                                           cell,
                                           age_cell_data_func,
                                           NULL, NULL);

   ...
    </programlisting>
    <para>
     For each row to be rendered by this particular cell renderer, the cell data function is going to be
     called, which then retrieves the float from the model, and turns it into a string where the float has
     only one digit after the colon/comma, and renders that with the text cell renderer.
    </para>
    <para>
     This is only a simple example, you can make cell data functions a lot more complicated if you want to.
     As always, there is a trade-off to keep in mind though.  Your cell data function is going to be called
     every single time a cell in that (renderer) column is going to be rendered.  Go and check how often this
     function is called in your program if you ever use one.  If you do time-consuming operations within a
     cell data function, things are not going to be fast, especially if you have a lot of rows.  The
     alternative in this case would have been to make an additional column
     <code>COLUMN_AGE_FLOAT_STRING</code> of type <code>G_TYPE_STRING</code>, and to set the float in string
     form whenever you set the float itself in a row, and then hook up the string column to a text cell
     renderer using attributes.  This way the float to string conversion would only need to be done once.
     This is a cpu cycles / memory trade-off, and it depends on your particular case which one is more
     suitable.  Things you should probably not do is to convert long strings into UTF8 format in a cell data
     function, for example.
    </para>
    <para>
     You might notice that your cell data function is called at times even for rows that are not visible at
     the moment.  This is because the tree view needs to know its total height, and in order to calculate
     this it needs to know the height of each and every single row, and it can only know that by having it
     measured, which is going to be slow when you have a lot of rows with different heights (if your rows all
     have the same height, there should not be any visible delay though).
    </para>

    <section id="GtkCellRendererText_and_Integer_Boolean_and_Float_Types">
     <title>GtkCellRendererText and Integer, Boolean and Float Types</title>
     <para>
      It has been said before that, when using attributes to connect data from the model to a cell renderer
      property, the data in the model column specified in the function
      <ulink url="&gtk-tree-view-column-add-attribute;">
      <code>gtk-tree-view-column-add-attribute</code></ulink> must always be of the same type as the data
      type that the property requires.
     </para>
     <para>
      This is usually true, but there is an exception: if you use the function
      <ulink url="&gtk-tree-view-column-add-attribute;">
      <code>gtk-tree-view-column-add-attribute</code></ulink> to connect a text cell renderer's "text"
      property to a model column, the model column does not need to be of <code>G_TYPE_STRING</code>, it can
      also be one of most other fundamental GLib types, e.g. <code>G_TYPE_BOOLEAN</code>,
      <code>G_TYPE_INT</code>, <code>G_TYPE_UINT</code>, <code>G_TYPE_LONG</code>, <code>G_TYPE_ULONG</code>,
      <code>G_TYPE_INT64</code>, <code>G_TYPE_UINT64</code>, <code>G_TYPE_FLOAT</code>, or
      <code>G_TYPE_DOUBLE</code>.  The text cell renderer will automatically display the values of these
      types correctly in the tree view. For example:
     </para>
     <programlisting>
  enum
  {
    COL_NAME = 0,
    COL_YEAR_BORN,
    NUM_COLS
  };

  liststore = gtk_list_store_new(NUM_COLS, G_TYPE_STRING, G_TYPE_UINT);

  ...

  cell = gtk_cell_renderer_text_new();
  col = gtk_tree_view_column_new();
  gtk_tree_view_column_add_attribute(col, cell, "text", COL_YEAR_BORN);

  ...
     </programlisting>
     <para>
      Even though the "text" property would require a string value, we use a model column of an integer type
      when setting attributes.  The integer will then automatically be converted into a string before the
      cell renderer property is set.
     </para>
     <para>
      If you are using a floating point type, i.e. <code>G_TYPE_FLOAT</code> or <code>G_TYPE_DOUBLE</code>,
      there is no way to tell the text cell renderer how many digits after the floating point (or comma)
      should be rendered.  If you only want a certain amount of digits after the point/comma, you will need
      to use a cell data function.
     </para>
    </section>
   </section>

   <section id="GtkCellRendererText, UTF8, and pango markup">
    <title>GtkCellRendererText, UTF8, and pango markup</title>
    <para>
     All text used in Gtk+-2.0 widgets needs to be in UTF8 encoding, and
     <ulink url="&gtk-cell-renderer-text;"><code>gtk-cell-renderer-text</code></ulink> is no exception.  Text
     in plain ASCII is automatically valid UTF8, but as soon as you have special characters that do not
     exist in plain ASCII (usually characters that are not used in the English language alphabet), they need
     to be in UTF8 encoding.  There are many different character encodings that all specify different ways to
     tell the computer which character is meant.  Gtk+-2.0 uses UTF8, and whenever you have text that is in a
     different encoding, you need to convert it to UTF8 encoding first, using one of the GLib
     <code>g_convert</code> family of functions.  If you only use text input from other Gtk+ widgets, you are
     on the safe side, as they will return all text in UTF8 as well.
    </para>
    <para>
     However, if you use 'external' sources of text input, then you must convert that text from the text's
     encoding (or the user's locale) to UTF8, or it will not be rendered correctly (either not at all, or it
     will be cut off after the first invalid character).  Filenames are especially hard, because there is no
     indication whatsoever what character encoding a filename is in (it might have been created when the user
     was using a different locale, so filename encoding is basically unreliable and broken).  You may want to
     convert to UTF8 with fallback characters in that case.  You can check whether a string is valid UTF8
     with <code>g_utf8_validate</code>.  You should, in this author's opinion at least, put these checks into
     your code at crucial places wherever it is not affecting performance, especially if you are an
     English-speaking programmer that has little experience with non-English locales.  It will make it easier
     for others and yourself to spot problems with non-English locales later on.
    </para>
    <para>
     In addition to the <code>"text"</code> property, <ulink url="&gtk-cell-renderer-text;">
     <code>gtk-cell-renderer-text</code></ulink> also has a <code>"markup"</code> property that takes text
     with pango markup as input. Pango markup allows you to place special tags into a text string that affect
     the style the text is rendered (see the pango documentation).  Basically you can achieve everything you
     can achieve with the other properties also with pango markup (only that using properties is more
     efficient and less messy).  Pango markup has one distinct advantage though that you cannot achieve with
     text cell renderer properties: with pango markup, you can change the text style in the middle of the
     text, so you could, for example, render one part of a text string in bold print, and the rest of the
     text in normal.  Here is an example of a string with pango markup:
    </para>
    <para>
     "You can have text in <code>&#x3c;b>bold&#x3c;/b></code> or in a 
     <code>&#x3c;span color='Orange'>different color&#x3c;/span></code>"
    </para>
    <para>
     When using the <code>"markup"</code> property, you need to take into account that the
     <code>"markup"</code> and <code>"text"</code> properties do not seem to be mutually exclusive (I suppose
     this could be called a bug). In other words: whenever you set <code>"markup"</code> (and have used the
     <code>"text"</code> property before), set the <code>"text"</code> property to <code>nil</code>, and
     vice versa. Example:
    </para>
    <programlisting>
  ...

  void
  foo_cell_data_function ( ... )
  {
    ...
    if (foo->is_important)
      g_object_set(renderer, "markup",
                             "&#x3c;b>important&#x3c;/b>", "text", NULL, NULL);
    else
      g_object_set(renderer, "markup", NULL, "text", "not important", NULL);
    ...
  }

  ...
    </programlisting>
    <para>
     Another thing to keep in mind when using pango markup text is that you might need to escape text if you
     construct strings with pango markup on the fly using random input data. For example:
    </para>
    <programlisting>
  ...

  void
  foo_cell_data_function ( ... )
  {
    gchar *markuptxt;

    ...
    /* This might be problematic if artist_string or title_string
     *   contain markup characters/entities: */
    markuptxt = g_strdup_printf("&#x3c;b>%s&#x3c;/b> - &#x3c;i>%s&#x3c;/i>",
                                artist_string, title_string);
    ...
    g_object_set(renderer, "markup", markuptxt, "text", NULL, NULL);
    ...
    g_free(markuptxt);
  }

  ...
    </programlisting>
    <para>
     The above example will not work if artist_string is "Simon &#x26; Garfunkel" for example, because the
     &#x26; character is one of the characters that is special.  They need to be escaped, so that pango knows
     that they do not refer to any pango markup, but are just characters.  In this case the string would need
     to be "Simon &#x26; Garfunkel" in order to make sense in between the pango markup in which it is going
     to be pasted.  You can escape a string with <code>g_markup_escape</code> (and you will need to free the
     resulting newly-allocated string again with <code>g_free</code>).
    </para>
    <para>
     It is possible to combine both pango markup and text cell renderer properties. Both will be 'added'
     together to render the string in question, only that the text cell renderer properties will be applied
     to the whole string. If you set the <code>"markup"</code> property to normal text without any pango
     markup, it will render as normal text just as if you had used the <code>"text"</code> property. However,
     as opposed to the <code>"text"</code> property, special characters in the <code>"markup"</code> property
     text would still need to be escaped, even if you do not use pango markup in the text.
    </para>
   </section>

   <section id="A_Working_Example">
    <title>A Working Example</title>
    <para>
     Here is our example from the very beginning again (with an additional column though), only that the
     contents of the model are rendered properly on the screen this time.  Both attributes and a cell data
     function are used for demonstration purposes.
    </para>
    <programlisting>
#include &#x3c;gtk/gtk.h>

enum
{
  COL_FIRST_NAME = 0,
  COL_LAST_NAME,
  COL_YEAR_BORN,
  NUM_COLS
} ;

static GtkTreeModel *
create_and_fill_model (void)
{
  GtkTreeStore  *treestore;
  GtkTreeIter    toplevel, child;

  treestore = gtk_tree_store_new(NUM_COLS,
                                 G_TYPE_STRING,
                                 G_TYPE_STRING,
                                 G_TYPE_UINT);

  /* Append a top level row and leave it empty */
  gtk_tree_store_append(treestore, &#x26;toplevel, NULL);
  gtk_tree_store_set(treestore, &#x26;toplevel,
                     COL_FIRST_NAME, "Maria",
                     COL_LAST_NAME, "Incognito",
                     -1);

  /* Append a second top level row, and fill it with some data */
  gtk_tree_store_append(treestore, &#x26;toplevel, NULL);
  gtk_tree_store_set(treestore, &#x26;toplevel,
                     COL_FIRST_NAME, "Jane",
                     COL_LAST_NAME, "Average",
                     COL_YEAR_BORN, (guint) 1962,
                     -1);

  /* Append a child to the second top level row, and fill in some data */
  gtk_tree_store_append(treestore, &#x26;child, &#x26;toplevel);
  gtk_tree_store_set(treestore, &#x26;child,
                     COL_FIRST_NAME, "Janinita",
                     COL_LAST_NAME, "Average",
                     COL_YEAR_BORN, (guint) 1985,
                     -1);

  return GTK_TREE_MODEL(treestore);
}

void
age_cell_data_func (GtkTreeViewColumn *col,
                    GtkCellRenderer   *renderer,
                    GtkTreeModel      *model,
                    GtkTreeIter       *iter,
                    gpointer           user_data)
{
  guint  year_born;
  guint  year_now = 2003; /* to save code not relevant for the example */
  gchar  buf[64];

  gtk_tree_model_get(model, iter, COL_YEAR_BORN, &#x26;year_born, -1);

  if (year_born &#x3c;= year_now &#x26;&#x26; year_born > 0)
  {
    guint age = year_now - year_born;

    g_snprintf(buf, sizeof(buf), "%u years old", age);
    /* print this normal */
    g_object_set(renderer, "foreground-set", FALSE, NULL);
  }
  else
  {
    g_snprintf(buf, sizeof(buf), "age unknown");

    /* make red */
    g_object_set(renderer, "foreground",
                           "Red", "foreground-set", TRUE, NULL);
  }

  g_object_set(renderer, "text", buf, NULL);
}

static GtkWidget *
create_view_and_model (void)
{
  GtkTreeViewColumn   *col;
  GtkCellRenderer     *renderer;
  GtkWidget           *view;
  GtkTreeModel        *model;

  view = gtk_tree_view_new();

  /* --- Column #1 --- */

  col = gtk_tree_view_column_new();

  gtk_tree_view_column_set_title(col, "First Name");

  /* pack tree view column into tree view */
  gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);

  renderer = gtk_cell_renderer_text_new();

  /* pack cell renderer into tree view column */
  gtk_tree_view_column_pack_start(col, renderer, TRUE);

  /* connect 'text' property of the cell renderer to
   *  model column that contains the first name */
  gtk_tree_view_column_add_attribute(col, renderer, "text", COL_FIRST_NAME);


  /* --- Column #2 --- */

  col = gtk_tree_view_column_new();

  gtk_tree_view_column_set_title(col, "Last Name");

  /* pack tree view column into tree view */
  gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);

  renderer = gtk_cell_renderer_text_new();

  /* pack cell renderer into tree view column */
  gtk_tree_view_column_pack_start(col, renderer, TRUE);

  /* connect 'text' property of the cell renderer to
   *  model column that contains the last name */
  gtk_tree_view_column_add_attribute(col, renderer, "text", COL_LAST_NAME);

  /* set 'weight' property of the cell renderer to
   *  bold print (we want all last names in bold) */
  g_object_set(renderer,
               "weight", PANGO_WEIGHT_BOLD,
               "weight-set", TRUE,
               NULL);


  /* --- Column #3 --- */

  col = gtk_tree_view_column_new();

  gtk_tree_view_column_set_title(col, "Age");

  /* pack tree view column into tree view */
  gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);

  renderer = gtk_cell_renderer_text_new();

  /* pack cell renderer into tree view column */
  gtk_tree_view_column_pack_start(col, renderer, TRUE);

  /* connect a cell data function */
  gtk_tree_view_column_set_cell_data_func(col,
                                          renderer,
                                          age_cell_data_func,
                                          NULL, NULL);


  model = create_and_fill_model();

  gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);

  g_object_unref(model); /* destroy model automatically with view */

  gtk_tree_selection_set_mode(
      gtk_tree_view_get_selection(GTK_TREE_VIEW(view)),
      GTK_SELECTION_NONE);

  return view;
}

int
main (int argc, char **argv)
{
  GtkWidget *window;
  GtkWidget *view;

  gtk_init(&#x26;argc, &#x26;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  g_signal_connect(window, "delete_event", gtk_main_quit, NULL); /* dirty */

  view = create_view_and_model();

  gtk_container_add(GTK_CONTAINER(window), view);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
    </programlisting>
   </section>

   <section id="How_to_Make_a_Whole_Row_Bold_or_Coloured">
    <title>How to Make a Whole Row Bold or Coloured</title>
    <para>
     This seems to be a frequently asked question, so it is worth mentioning it here. You have the two
     approaches mentioned above: either you use cell data functions, and check in each whether a particular
     row should be highlighted in a particular way (bold, coloured, whatever), and then set the renderer
     properties accordingly (and unset them if you want that row to look normal), or you use attributes.
     Cell data functions are most likely not the right choice in this case though.
    </para>
    <para>
     If you only want every second line to have a gray background to make it easier for the user to see which
     data belongs to which line in wide tree views, then you do not have to bother with the stuff mentioned
     here. Instead just set the rules hint on the tree view as described in the here, and everything will be 
     done automatically, in colours that conform to the chosen theme even (unless the theme disables rule
     hints, that is).
    </para>
    <para>
     Otherwise, the most suitable approach for most cases is that you add two columns to your model, one for
     the property itself (e.g. a column <code>COL_ROW_COLOR</code> of type <code>G_TYPE_STRING</code>), and
     one for the boolean flag of the property (e.g. a column <code>COL_ROW_COLOR_SET</code> of type
     <code>G_TYPE_BOOLEAN</code>).  You would then connect these columns with the <code>"foreground"</code>
     and <code>"foreground-set"</code> properties of each renderer.  Now, whenever you set a row's
     <code>COL_ROW_COLOR</code> field to a colour, and set that row's <code>COL_ROW_COLOR_SET</code> field to
     <emphasis>true</emphasis>, then this column will be rendered in the colour of your choice.  If you only
     want either the default text colour or one special other colour, you could even achieve the same thing
     with just one extra model column: in this case you could just set all renderer's
     <code>"foreground"</code> property to whatever special color you want, and only connect the
     <code>COL_ROW_COLOR_SET</code> column to all renderer's <code>"foreground-set"</code> property using
     attributes.  This works similar with any other attribute, only that you need to adjust the data type for
     the property of course (e.g. <code>"weight"</code> would take a <code>G_TYPE_INT</code>, in form of a
     <code>PANGO_WEIGHT_FOO</code> define in this case).
    </para>
    <para>
     As a general rule, you should not change the text colour or the background colour of a cell unless you
     have a really good reason for it.  To quote Havoc Pennington: "Because colors in GTK+ represent a theme
     the user has chosen, you should never set colors purely for aesthetic reasons.  If users don't like GTK+
     gray, they can change it themselves to their favorite shade of orange."
    </para>
   </section>

   <section id="How_to_Pack_Icons_into_the_Tree_View">
    <title>How to Pack Icons into the Tree View</title>
    <para>
     So far we have only put text in the tree view.  While everything you need to know to display icons (in
     the form of <ulink url="&gdk-pixbuf;"><code>gdk-pixbuf</code></ulink> objects) has been introduced in
     the previous sections, a short example might help to make things clearer.  The following code will pack
     an icon and some text into the same tree view column:
    </para>
    <programlisting>
  enum
  {
    COL_ICON = 0,
    COL_TEXT,
    NUM_COLS
  };

  GtkListStore *
  create_liststore(void)
  {
    GtkListStore  *store;
    GtkTreeIter    iter;
    GdkPixbuf     *icon;
    GError        *error = NULL;

    store = gtk_list_store_new(2, GDK_TYPE_PIXBUF, G_TYPE_STRING);

    icon = gdk_pixbuf_new_from_file("icon.png", &#x26;error);
    if (error)
    {
      g_warning ("Could not load icon: %s\n", error->message);
      g_error_free(error);
      error = NULL;
    }

    gtk_list_store_append(store, &#x26;iter);
    gtk_list_store_set(store, &#x26;iter,
                       COL_ICON, icon,
                       COL_TEXT, "example",
                       -1);

    return store;
  }

  GtkWidget *
  create_treeview(void)
  {
    GtkTreeModel      *model;
    GtkTreeViewColumn *col;
    GtkCellRenderer   *renderer;
    GtkWidget         *view;

    model = GTK_TREE_MODEL(create_liststore());

    view = gtk_tree_view_new_with_model(model);

    col = gtk_tree_view_column_new();
    gtk_tree_view_column_set_title(col, "Title");

    renderer = gtk_cell_renderer_pixbuf_new();
    gtk_tree_view_column_pack_start(col, renderer, FALSE);
    gtk_tree_view_column_set_attributes(col, renderer,
                                        "pixbuf", COL_ICON,
                                        NULL);

    renderer = gtk_cell_renderer_text_new();
    gtk_tree_view_column_pack_start(col, renderer, TRUE);
    gtk_tree_view_column_set_attributes(col, renderer,
                                        "text", COL_TEXT,
                                        NULL);

    gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);

    gtk_widget_show_all(view);

    return view;
  }
    </programlisting>
    <para>
     Note that the tree view will not resize icons for you, but displays them in their original size.  If
     you want to display stock icons instead of <ulink url="&gdk-pixbuf;"><code>gdk-pixbuf</code></ulink>
     objects loaded from file, you should have a look at the <code>"stock-id"</code> property of
     <ulink url="&gtk-cell-renderer-pixbuf;"><code>gtk-cell-renderer-pixbuf</code></ulink> (and your model
     column should be of type <code>G_TYPE_STRING</code>, as all stock IDs are just strings by which to
     identify the stock icon).
    </para>
   </section>
  </section>

  <section id="Selections_Double-Clicks_and_Context_Menus">
   <title>Selections, Double-Clicks and Context Menus</title>
   <para>
   </para>
  </section>

  <section id="Sorting">
   <title>Sorting</title>
   <para>
   </para>
  </section>

  <section id="Editable_Cells">
   <title>Editable Cells</title>
   <para>
   </para>
  </section>

  <section id="Miscellaneous">
   <title>Miscellaneous</title>
   <para>
   </para>
  </section>

  <section id="Drag_and_Drop">
   <title>Drag and Drop</title>
   <para>
   </para>
  </section>

  <section id="Writing Custom Models">
   <title>Writing Custom Models</title>
   <para>
   </para>
  </section>
 </chapter>

 <chapter id="Dialogs">
  <title>Dialogs</title>

  <section id="General_Dialog">
   <sectioninfo>
    <itermset>
     <indexterm zone="General_Dialog">
      <primary>GtkDialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog, gtk-dialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-new, gtk-dialog-new</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-new-with-buttons, gtk-dialog-new-with-buttons</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-content-area, gtk-dialog-content-area</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-add-button, gtk-dialog-add-button</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>GtkResponseType</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>response-type, gtk-response-type</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-action-area, gtk-dialog-action-area</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>dialog-run, gtk-dialog-run</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>General Dialog</title>
   <figure id="figure-dialog-window">
    <title>General Dialog Window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/dialog-window403x167.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The dialog widget is just a window with a few things pre-packed into it.  The dialog widget is of type
    <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink> which is represented by the Lisp class
    <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>.  A dialog widget can be created with the
    function <ulink url="&gtk-dialog-new;"><code>gtk-dialog-new</code></ulink> or the call
    <code>(make-instance 'gtk-dialog)</code>.  The function <ulink url="&gtk-dialog-new;">
    <code>gtk-dialog-new</code></ulink> does not take an argument.  In addition the function
    <ulink url="&gtk-dialog-new-with-buttons;"><code>gtk-dialog-new-with-buttons</code></ulink> is available.
    It allows you to set the dialog title, some convenient flags, and add simple buttons.
   </para>
   <para>
    The dialog widget consists of an content area which is of type &gtk-box; with the value
    <code>:vertical</code> of type
    &gtk-orientation;.  The content area can be filled with
    the content of a dialog.  At the button of the window the dialog widget has an action area which takes
    the desired buttons of the dialog.
   </para>
   <para>
    The function <ulink url="&gtk-dialog-content-area;"><code>gtk-dialog-content-area</code></ulink> gets the
    content area of a dialog.  Because the content area is a vertical box of type &gtk-box; any desired
    widgets can be added to the content area with the functions &gtk-box-pack-start; or
    &gtk-box-pack-end;. To display the content area it is
    necessary to call the function &gtk-widget-show;
    explicitly. The function <code>create-dialog</code> in example <link linkend="example-dialog-window">
    Dialog Window</link> shows how to fill widgets into a dialog widget.
   </para>
   <para>
    The action area can be filled with the desired buttons for the dialog window. Standard buttons can be
    added with the function <ulink url="&gtk-dialog-add-button;"><code>gtk-dialog-add-button</code></ulink>.
    The function takes three arguments.  The first argument is the dialog window the button is added to.  The
    second argument is a string which is the text of the button or a stock ID.  The last argument is of the
    enumeration type <ulink url="&gtk-response-type;"><code>gtk-response-type</code></ulink> and defines the
    response type of the button.  Possible values of <ulink url="&gtk-response-type;">
    <code>gtk-response-type</code></ulink> are shown in table <link linkend="table-gtk-response-type">
    GtkResponseType</link>.
   </para>
   <para>
    Alternatively to the function <ulink url="&gtk-dialog-add-button;">
    <code>gtk-dialog-add-button</code></ulink> buttons can be added with the functions
    &gtk-box-pack-start; or &gtk-box-pack-end; to the action area.  The action
    area is of type <ulink url="&gtk-button-box;"><code>gtk-button-box</code></ulink> with a
    <code>:horizontal</code> orientation and can be get with the function
    <ulink url="&gtk-dialog-action-area;"><code>gtk-dialog-action-area</code></ulink>.
   </para>
   <table id="table-gtk-response-type" frame='all'>
    <title>Values of the GtkResponseType enumeration</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:none</code></entry>
       <entry valign="top">
        Returned if an action widget has no response ID, or if the dialog gets programmatically hidden or
        destroyed.
       </entry>
      </row>
      <row>
       <entry valign="top"><code>:reject</code></entry>
       <entry valign="top">Generic response ID, not used by GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:accept</code></entry>
       <entry valign="top">Generic response ID, not used by GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:event</code></entry>
       <entry valign="top">Returned if the dialog is deleted.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok</code></entry>
       <entry valign="top">Returned by OK buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:cancel</code></entry>
       <entry valign="top">Returned by Cancel buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:close</code></entry>
       <entry valign="top">Returned by Close buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:yes</code></entry>
       <entry valign="top">Returned by Yes buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:no</code></entry>
       <entry valign="top">Returned by No buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:apply</code></entry>
       <entry valign="top">Returned by Apply buttons in GTK+ dialogs.</entry>
      </row>
      <row>
       <entry valign="top"><code>:help</code></entry>
       <entry valign="top">Returned by Help buttons in GTK+ dialogs.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    After creation and configuration of the dialog window the dialog is executed with the function
    <ulink url="&gtk-dialog-run;"><code>gtk-dialog-run</code></ulink>.  The function takes the dialog window
    of type <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink> as the only argument.  After closing
    the dialog window with one of the buttons the response is returned as an integer value of type
    <ulink url="&gtk-response-type;"><code>gtk-response-type</code></ulink>.
   </para>
  </section>

  <section id="Message_Dialog">
   <sectioninfo>
    <itermset>
     <indexterm zone="General_Dialog">
      <primary>GtkMessageDialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog, gtk-message-dialog</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog-new, gtk-message-dialog-new</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-dialog-new-with-markup, gtk-message-dialog-new-with-markup</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>message-type, gtk-message-type</primary>
     </indexterm>
     <indexterm zone="General_Dialog">
      <primary>buttons-type, gtk-buttons-type</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Message Dialog</title>
   <figure id="figure-message-dialog">
    <title>Message Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/message-dialog480x157.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    A message dialog <ulink url="&gtk-message-dialog;"><code>gtk-message-dialog</code></ulink> is a subclass
    of the more general class <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink> and gives an easy way
    to display messages to the user. The figure <link linkend="figure-message-dialog">Message Dialog</link>
    shows an example for an informational message.
   </para>
   <para>
    A message dialog is created with the call <code>(make-instance 'gtk-message-dialog)</code> or the
    functions <ulink url="&gtk-message-dialog-new;"><code>gtk-message-dialog-new</code></ulink> and
    <ulink url="&gtk-message-dialog-new-with-markup;">
    <code>gtk-message-dialog-new-with-markup</code></ulink>. Various properties control the appearance of a
    message dialog.  The function <code>create-message-dialog</code> in
    <link linkend="example-dialog-window">Dialog Window</link> shows the settings of the properties
    <code>message-type</code>, <code>buttons</code>, <code>text</code>, and <code>secondary-text</code>.
    The type of a message dialog is one of the values of the <ulink url="&gtk-message-type;">
    <code>gtk-message-type</code></ulink> enumeration.  The possible values are listed in table
    <link linkend="table-gtk-message-type">GtkMessageType</link>.  Predefined buttons of the
    <ulink url="&gtk-buttons-type;"><code>gtk-buttons-type</code></ulink> enumeration for a message dialog
    are listed in table <link linkend="table-gtk-buttons-type">GtkButtonsType</link>.
   </para>
   <table id="table-gtk-message-type" frame='all'>
    <title>The type of message being displayed in the dialog</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:info</code></entry>
       <entry valign="top">Informational message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:warning</code></entry>
       <entry valign="top">Nonfatal warning message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:question</code></entry>
       <entry valign="top">Question requiring a choice.</entry>
      </row>
      <row>
       <entry valign="top"><code>:error</code></entry>
       <entry valign="top">Fatal error message.</entry>
      </row>
      <row>
       <entry valign="top"><code>:other</code></entry>
       <entry valign="top">None of the above, does not get an icon.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <table id="table-gtk-buttons-type" frame='all'>
    <title>Prebuilt sets of buttons for a message dialog</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:none</code></entry>
       <entry valign="top">No buttons at all.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok</code></entry>
       <entry valign="top">An OK button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:close</code></entry>
       <entry valign="top">A Close button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:cancel</code></entry>
       <entry valign="top">A Cancel button.</entry>
      </row>
      <row>
       <entry valign="top"><code>:yes-no</code></entry>
       <entry valign="top">Yes and No buttons.</entry>
      </row>
      <row>
       <entry valign="top"><code>:ok-cancel</code></entry>
       <entry valign="top">Ok and Cancel buttons.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </section>

  <section id="About_Dialog">
   <sectioninfo>
    <itermset>
     <indexterm zone="About_Dialog">
      <primary>GtkAboutDialog</primary>
     </indexterm>
     <indexterm zone="About_Dialog">
      <primary>about-dialog, gtk-about-dialog</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>About Dialog</title>
   <figure id="figure-about-dialog">
    <title>About Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/about-dialog353x228.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> offers a simple way to display
    information about a program like its logo, name, copyright, website and license.  It is also possible to
    give credits to the authors, documenters, translators and artists who have worked on the program.  An
    about dialog is typically opened when the user selects the About option from the Help menu.  All parts of
    the dialog are optional.
   </para>
   <para>
    About dialogs often contain links and email addresses. <ulink url="&gtk-about-dialog;">
    <code>gtk-about-dialog</code></ulink> displays these as clickable links.  By default, it calls the
    function &gtk-show-uri; when a user clicks one.  The
    behavior can be overridden with the "activate-link" signal.
   </para>
   <para>
    To make constructing a <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> as
    convenient as possible, the function <ulink url="&gtk-show-about-dialog;">
    <code>gtk-show-about-dialog</code></ulink> is available which constructs and shows a dialog and keeps it
    around so that it can be shown again.
   </para>
   <para>
    Note that GTK+ sets a default title of <code>_("About %s")</code> on the dialog window, where
    <code>%s</code> is replaced by the name of the application, but in order to ensure proper translation of
    the title, applications should set the title property explicitly when constructing a
    <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink>.
   </para>
   <para>
    It is possible to show a <ulink url="&gtk-about-dialog;"><code>gtk-about-dialog</code></ulink> like any
    other <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>, e.g. using
    <ulink url="&gtk-dialog-run;"><code>gtk-dialog-run</code></ulink>.  In this case, you might need to know
    that the 'Close' button returns the <code>:cancel</code> response ID.
   </para>
   <example id="example-dialog-window">
    <title>Examples for a general, a message, and an about dialog</title>
    <programlisting>
(defun license-text ()
  (format nil
          "This program is free software: you can redistribute it and/or ~
          modify it under the terms of the GNU Lesser General Public ~
          License for Lisp as published by the Free Software Foundation, ~
          either version 3 of the License, or (at your option) any later ~
          version and with a preamble to the GNU Lesser General Public ~
          License that clarifies the terms for use with Lisp programs and ~
          is referred as the LLGPL.~%~% ~
          This program is distributed in the hope that it will be useful, ~
          but WITHOUT ANY WARRANTY; without even the implied warranty of ~
          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ~
          GNU Lesser General Public License for more details. ~%~% ~
          You should have received a copy of the GNU Lesser General Public ~
          License along with this program and the preamble to the Gnu ~
          Lesser General Public License.  If not, see ~
          &#x3c;http://www.gnu.org/licenses/> and ~
          &#x3c;http://opensource.franz.com/preamble.html>."))

(defun create-dialog ()
  (let ((dialog (make-instance 'gtk-dialog
                               :title "Dialog Window"
                               :has-separator t)))
    ;; Add a border width to the vbox of the content area
    (setf (gtk-container-border-width (gtk-dialog-get-content-area dialog))
          12)
    ;; Add a label widget with text to the content area
    (let ((vbox (make-instance 'gtk-box :orientation :vertical :border-width 12))
          (label (make-instance 'gtk-label
                                :wrap t
                                :label
                                (format nil
                                        "The content area is the place to ~
                                         put in the widgets.~%~% ~
                                         The action area is separated from ~
                                         the content area with a horizontal ~
                                         line."))))
      (gtk-box-pack-start vbox label)
      (gtk-box-pack-start (gtk-dialog-get-content-area dialog) vbox)
      ;; Show the content area of the dialog
      (gtk-widget-show (gtk-dialog-get-content-area dialog)))
    ;; Add buttons with a stock ID to the action area
    (gtk-dialog-add-button dialog "gtk-yes" :yes)
    (gtk-dialog-add-button dialog "gtk-no" :no)
    (gtk-dialog-add-button dialog "gtk-cancel" :cancel)
    (gtk-dialog-set-default-response dialog :cancel)
    ;; Change the order of the buttons
    (gtk-dialog-set-alternative-button-order dialog
                                             (list :yes :cancel :no))
    ;; Run the dialog and print the message on the console
    (format t "Response was: ~S~%" (gtk-dialog-run dialog))
    ;; Destroy the dialog
    (gtk-widget-destroy dialog)))

(defun create-message-dialog ()
  (let ((dialog (make-instance 'gtk-message-dialog
                               :message-type :info
                               :buttons :ok
                               :text "Info Message Dialog"
                               :secondary-text
                               (format nil
                                       "This is a message dialog of type ~
                                        :info with a secondary text."))))
    ;; Run the message dialog
    (gtk-dialog-run dialog)
    ;; Destroy the message dialog
    (gtk-widget-destroy dialog)))

(defun create-about-dialog ()
  (let ((dialog (make-instance 'gtk-about-dialog
                               :program-name "Example Dialog"
                               :version "0.00"
                               :copyright "(c) Dieter Kaiser"
                               :website
                               "github.com/crategus/cl-cffi-gtk"
                               :website-label "Project web site"
                               :license (license-text)
                               :authors '("Kalyanov Dmitry"
                                          "Dieter Kaiser")
                               :documenters '("Dieter Kaiser")
                               :artists '("None")
                               :logo-icon-name
                               "applications-development"
                               :wrap-license t)))
    ;; Run the about dialog
    (gtk-dialog-run dialog)
    ;; Destroy the about dialog
    (gtk-widget-destroy dialog)))

(defun example-dialog ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Dialog"
                                 :default-width 250
                                 :border-width 12))
          (vbox (make-instance 'gtk-box
                               :orientation :vertical
                               :spacing 6)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (let ((button (make-instance 'gtk-button
                                   :label "Open a Dialog Window")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the dialog
             (create-dialog))))
      (let ((button (make-instance 'gtk-button
                                   :label "Open a Message Dialog")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the message dialog
             (create-message-dialog))))
      (let ((button (make-instance 'gtk-button
                                   :label "Open an About Dialog")))
        (gtk-box-pack-start vbox button)
        (g-signal-connect button "clicked"
           (lambda (widget)
             (declare (ignore widget))
             ;; Create and show the about dialog
             (create-about-dialog))))
      (gtk-box-pack-start vbox
                          (make-instance 'gtk-hseparator))
      ;; Create a quit button
      (let ((button (make-instance 'gtk-button
                                   :label "Quit")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="Selecting_Colors_Files_and_Fonts">
  <title>Selecting Colors, Files, and Fonts</title>

  <section id="Selecting_Colors">
   <title>Selecting Colors</title>

   <section id="Representing_Colors">
    <title>Representing Colors</title>
    <para>
     Colors are represented as a structure of the type <ulink url="&gdk-rgba;"><code>gdk-rgba</code></ulink>,
     which is defined in the library GDK.  The stucture has the properties <code>red</code>,
     <code>green</code>, <code>blue</code>, and <code>alpha</code> to represent rgba colors.  It is based on
     cairo's way to deal with colors and mirrors its behavior.  All values are in the range from
     <code>0.0d0</code> to <code>1.0d0</code> inclusive.  So the color
     <code>(0.0d0, 0.0d0, 0.0d0, 0.0d0)</code> represents transparent black and
     <code>(1.0d0, 1.0d0, 1.0d0, 1.0d0)</code> is opaque white.  Other values will be clamped to this range
     when drawing.
    </para>
    <para>
     To create a representation of the color red use <code>(make-gdk-rgba :red 1.0d0)</code>.  The function
     <ulink url="&make-gdk-rgba;"><code>make-gdk-rgba</code></ulink> is the constructor of the Lisp
     implementation for creating a <ulink url="&gdk-rgba;"><code>gdk-rgba</code></ulink> structure.
     Alternatively, the function <ulink url="&gdk-rgba-parse;"><code>gdk-rgba-parse</code></ulink> parses a
     textual representation of a color, filling in the red, green, blue and alpha fields of the
     <ulink url="&gdk-rgba;"><code>gdk-rgba</code></ulink> structure.  The string can be either one of:
    </para>
    <itemizedlist>
     <listitem>
       A standard name taken from the X11 <code>rgb.txt</code> file.
     </listitem>
     <listitem>
      A hex value in the form <code>rgb</code>, <code>rrggbb</code>, <code>rrrgggbbb</code> or
      <code>rrrrggggbbb</code>.
     </listitem>
     <listitem>
      A RGB color in the form <code>rgb(r,g,b)</code>. In this case the color will have full opacity.
     </listitem>
     <listitem>
      A RGBA color in the form <code>rgba(r,g,b,a)</code>.
     </listitem>
    </itemizedlist>
    <para>
     Where <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code> are respectively the red, green,
     blue and alpha color values. In the last two cases, <code>r</code>,  <code>g</code> and <code>b</code>
     are either integers in the range 0 to 255 or precentage values in the range 0% to 100%, and a is a
     floating point value in the range 0 to 1.
    </para>
    <para>
     Conversely, the function <ulink url="&gdk-rgba-to-string;"><code>gdk-rgba-to-string</code></ulink>
     returns a textual specification of the rgba color in the form <code>rgb (r, g, b)</code> or
     <code>rgba (r, g, b, a)</code>, where <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code>
     represent the red, green, blue and alpha values respectively.  <code>r</code>, <code>g</code>, and
     <code>b</code> are represented as integers in the range 0 to 255, and <code>a</code> is represented as
     floating point value in the range 0 to 1.
    </para>
    <para>
     These string forms are string forms those supported by the CSS3 colors module, and can be parsed by the
     function <ulink url="&gdk-rgba-parse;"><code>gdk-rgba-parse</code></ulink>.
    </para>
    <para>
     Note that this string representation may loose some precision, since <code>r</code>, <code>g</code>,
     and <code>b</code> are represented as 8-bit integers. If this is a concern, you should use a different
     representation.
    </para>
    <para>
     A simple example is the representation of the color red, which can be created with the call
     <code>(gdk-rgba-parse "Red")</code> from a string and converted back to a textual with the call
     <code>(gdk-rgba-to-string (gdk-rgba-parse "Red"))</code>.  The result of the last function is
     <code>"rgba(255,0,0,0)"</code>.
    </para>
    <para>
     Note, that GTK+ knows a second representation of colors as a structure of type <ulink url="&gdk-color;">
     <code>gdk-color</code></ulink>.  The implementation is semilar.  The widgets for choosing a color know
     both representations.
    </para>
   </section>

   <section id="Color_Button_and_Color_Chooser_Dialog">
    <title>Color Button and Color Chooser Dialog</title>
    <figure id="figure-color-button">
     <title>Color Selecting Dialog</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/color-button.gif" format="gif"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     The <ulink url="&gtk-color-button;"><code>gtk-color-button</code></ulink> is a button which displays the
     currently selected color and allows to open a color selection dialog to change the color.  It is
     suitable widget for selecting a color in a preference dialog.  It implements the
     <ulink url="&gtk-color-chooser;"><code>gtk-color-chooser</code></ulink> interface.
    </para>
    <para>
     Example <link linkend="example-color-button">Color Button</link> shows a simple implementation of a
     <ulink url="&gtk-color-button;"><code>gtk-color-button</code></ulink>.  The example displays a button
     with the predefined color gray.  When clicking the button, a color selection dialog is opened.  The
     dialog is shown in figure <link linkend="figure-color-button">Color Button</link>.  To get the currently
     selected color you should connect a signal handler to the signal "color-set" and retrieve the color with
     the <ulink url="&gtk-color-chooser-rgba;"><code>gtk-color-chooser-rgba</code></ulink> slot access
     function.
    </para>
    <example id="example-color-button">
     <title>Color Button</title>
     <programlisting>
(let ((color (gdk-rgba-parse "Gray")))
  (defun example-color-button ()
    (within-main-loop
      (let ((window (make-instance 'gtk-window
                                   :title "Example Color Button"
                                   :border-width 12
                                   :default-width 250
                                   :default-height 200))
            (button (make-instance 'gtk-color-button
                                   :rgba color)))
        (g-signal-connect window "destroy"
                          (lambda (widget)
                            (declare (ignore widget))
                            (leave-gtk-main)))
        (g-signal-connect button "color-set"
           (lambda (widget)
             (let ((rgba (gtk-color-chooser-rgba widget)))
               (format t "Selected color is ~A~%"
                       (gdk-rgba-to-string rgba)))))
        (gtk-container-add window button)
        (gtk-widget-show-all window)))))
     </programlisting>
    </example>
    <para>
     The <ulink url="&gtk-color-chooser-dialog;"><code>gtk-color-chooser-dialog</code></ulink> widget is a
     dialog for choosing a color.  It implements the <ulink url="&gtk-color-chooser;">
     <code>gtk-color-chooser</code></ulink> interface.  To provide a dialog in the
     <ulink url="&gtk-color-chooser-dialog;"><code>gtk-color-chooser-dialog</code></ulink> the
     <ulink url="&gtk-color-chooser-widget;"><code>gtk-color-chooser-widget</code></ulink> is used.
    </para>
    <para>
     By default, the chooser presents a prefined palette of colors, plus a small number of settable custom
     colors.  It is also possible to select a different color with the single-color editor.  To enter the
     single-color editing mode, use the context menu of any color of the palette, or use the '+' button to
     add a new custom color.
    </para>
    <para>
     The chooser automatically remembers the last selection, as well as custom colors.
    </para>
    <para>
     To change the initially selected color or to get the selected color use the
     <ulink url="&gtk-color-chooser-rgba;"><code>gtk-color-chooser-rgba</code></ulink> slot access function.
    </para>
    <para>
     Example <link linkend="example-color-chooser-dialog">Chooser Dialog</link> shows how to replace the
     default color palette and the default gray palette with the function
     <ulink url="&gtk-color-chooser-add-palette;"><code>gtk-color-chooser-add-palette</code></ulink>.
    </para>
    <figure id="figure-color-chooser-dialog">
     <title>Color Selecting Dialog with a custom color and gray palette</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/color-chooser-dialog.gif" format="gif"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <example id="example-color-chooser-dialog">
     <title>Color Chooser Dialog</title>
     <programlisting>    
(let ((color (gdk-rgba-parse "Blue"))
      ;; Color palette with 4 rgba colors
      (palette1 (list (gdk-rgba-parse "Red")
                      (gdk-rgba-parse "Yellow")
                      (gdk-rgba-parse "Blue")
                      (gdk-rgba-parse "Green")))
      ;; Gray palette with 3 rgba grays
      (palette2 (list (gdk-rgba-parse "White")
                      (gdk-rgba-parse "Gray")
                      (gdk-rgba-parse "Black"))))
  (defun drawing-area-event (widget event area)
    (declare (ignore widget))
    (let ((handled nil))
      (when (eql (gdk-event-type event) :button-press)
        (let ((dialog (make-instance 'gtk-color-chooser-dialog
                                      :color color
                                      :use-alpha nil)))
          (setq handled t)
          ;; Add a custom palette to the dialog
          (gtk-color-chooser-add-palette dialog :vertical 1 palette1)
          ;; Add a second coustom palette to the dialog
          (gtk-color-chooser-add-palette dialog :vertical 1 palette2)
          ;; Run the color chooser dialog
          (let ((response (gtk-dialog-run dialog)))
            (when (eql response :ok)
              (setq color (gtk-color-chooser-rgba dialog)))
            ;; Set the color of the area widget
            (gtk-widget-override-background-color area :normal color)
            ;; Destroy the color chooser dialog
            (gtk-widget-destroy dialog))))
      handled))

  (defun example-color-chooser-dialog ()
    (within-main-loop
      (let ((window (make-instance 'gtk-window
                                   :title "Example Color Chooser Dialog"
                                   :default-width 300))
            (area (make-instance 'gtk-drawing-area)))
        (g-signal-connect window "destroy"
                          (lambda (widget)
                            (declare (ignore widget))
                            (leave-gtk-main)))
        (gtk-widget-override-background-color area :normal color)
        (setf (gtk-widget-events area) :button-press-mask)
        (g-signal-connect area "event"
                          (lambda (widget event)
                            (drawing-area-event widget event area)))
        (gtk-container-add window area)
        (gtk-widget-show-all window)))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Selecting_Files">
   <title>Selecting Files</title>
   <figure id="figure-file-chooser-dialog">
    <title>File Chooser Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/file-chooser-dialog.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <ulink url="&gtk-file-chooser;"><code>gtk-file-chooser</code></ulink> is an interface that can be
    implemented by file selection widgets. In GTK+, the main objects that implement this interface are
    <ulink url="&gtk-file-chooser-widget;"><code>gtk-file-chooser-widget</code></ulink>,
    <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink>, and
    <ulink url="&gtk-file-chooser-button;"><code>gtk-file-chooser-button</code></ulink>. You do not need to
    write an object that implements the <ulink url="&gtk-file-chooser;"><code>gtk-file-chooser</code></ulink>
    interface unless you are trying to adapt an existing file selector to expose a standard programming
    interface.
   </para>
   <para>
    <ulink url="&gtk-file-chooser;"><code>gtk-file-chooser</code></ulink> allows for shortcuts to various
    places in the filesystem.  In the default implementation these are displayed in the left pane.
    It may be a bit confusing at first that these shortcuts come from various sources and in various
    flavours, so lets explain the terminology here:
   </para>
   <variablelist>
    <varlistentry>
     <term>Bookmarks</term>
     <listitem>
      are created by the user, by dragging folders from the right pane to the left pane, or by using the
      "Add". Bookmarks can be renamed and deleted by the user.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Shortcuts</term>
     <listitem>
      can be provided by the application or by the underlying filesystem abstraction (e.g. both the gnome-vfs
      and the Windows filesystems provide "Desktop" shortcuts). Shortcuts cannot be modified by the user.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Volumes</term>
     <listitem>
      are provided by the underlying filesystem abstraction. They are the "roots" of the filesystem.
     </listitem>
    </varlistentry>
   </variablelist>

   <bridgehead renderas='sect3'>File Names and Encodings</bridgehead>
   <para>
    When the user is finished selecting files in a <ulink url="&gtk-file-chooser;">
    <code>gtk-file-chooser</code></ulink>, your program can get the selected names either as filenames or as
    URIs.  For URIs, the normal escaping rules are applied if the URI contains non-ASCII characters. However,
    filenames are always returned in the character set specified by the <code>G_FILENAME_ENCODING</code>
    environment variable.  Please see the Glib documentation for more details about this variable.
   </para>
   <para>
    <emphasis>Note:</emphasis> This means that while you can pass the result of
    <ulink url="&gtk-file-chooser-filename;"><code>gtk-file-chooser-filename</code></ulink> to
    <code>open(2)</code> or <code>fopen(3)</code>, you may not be able to directly set it as the text of a
    &gtk-label; widget unless you convert it first to UTF-8,
    which all GTK+ widgets expect. You should use the function <ulink url="&g-filename-to-utf8;">
    <code>g-filename-to-utf8</code></ulink> to convert filenames into strings that can be passed to GTK+
    widgets.
   </para>

   <bridgehead renderas='sect3'>Adding a Preview Widget</bridgehead>
   <para>
    You can add a custom preview widget to a file chooser and then get notification about when the preview
    needs to be updated. To install a preview widget, use <ulink url="&gtk-file-chooser-preview-widget;">
    <code>gtk-file-chooser-preview-widget</code></ulink>. Then, connect to the "update-preview" signal to get
    notified when you need to update the contents of the preview.
   </para>
   <para>
    Your callback should use <ulink url="&gtk-file-chooser-preview-filename;">
    <code>gtk-file-chooser-preview-filename</code></ulink> to see what needs previewing.  Once you have
    generated the preview for the corresponding file, you must call
    <ulink url="&gtk-file-chooser-preview-widget-active;">
    <code>gtk-file-chooser-preview-widget-active</code></ulink> with a boolean flag that indicates whether
    your callback could successfully generate a preview.
   </para>

   <bridgehead renderas='sect3'>Adding Extra Widgets</bridgehead>
   <para>
    You can add extra widgets to a file chooser to provide options that are not present in the default
    design.  For example, you can add a toggle button to give the user the option to open a file in read-only
    mode. You can use <ulink url="&gtk-file-chooser-extra-widget;">
    <code>gtk-file-chooser-extra-widget</code></ulink> to insert additional widgets in a file chooser.
   </para>
   <para>
    <emphasis>Note:</emphasis> If you want to set more than one extra widget in the file chooser, you can use
    a container such as a &gtk-box; or a &gtk-table; and include your widgets in it.  Then, set the container
    as the whole
    extra widget.
   </para>
   <para>
    <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink> is a dialog box
    suitable for use with "File/Open" or "File/Save as" commands.  This widget works by putting a
    <ulink url="&gtk-file-chooser-widget;"><code>gtk-file-chooser-widget</code></ulink> inside a
    <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>.  It exposes the
    <code>GtkFileChooserIface</code> interface, so you can use all of the <ulink url="&gtk-file-chooser;">
    <code>gtk-file-chooser</code></ulink> functions on the file chooser dialog as well as those for
    <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>.
   </para>
   <para>
    Note that <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink> does not
    have any methods of its own. Instead, you should use the functions that work on a
    <ulink url="&gtk-file-chooser;"><code>gtk-file-chooser</code></ulink>.
   </para>

   <section id="Setting up a file chooser dialog">
    <title>Setting up a file chooser dialog</title>
    <para>
     The enumeration <ulink url="&gtk-file-chooser-action;"><code>gtk-file-chooser-action</code></ulink>
     describes whether a <ulink url="&gtk-file-chooser;"><code>gtk-file-chooser</code></ulink> is being used
     to open existing files or to save to a possibly new file.  These are the cases in which you may need to
     use a <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink>.
    </para>
    <itemizedlist>
     <listitem>
      To select a file for opening, as for a File/Open command.  Use the keyword <code>:open</code> for the
      slot <code>:action</code>, when creating a file chooser dialog.
     </listitem>
     <listitem>
      To save a file for the first time, as for a File/Save command.  Use the keyword <code>:save</code>,
      and suggest a name such as "Untitled" with <ulink url="&gtk-file-chooser-current-name;">
      <code>gtk-file-chooser-current-name</code></ulink>.
     </listitem>
     <listitem>
      To save a file under a different name, as for a File/Save As command. Use the keyword
      <code>:save</code>, and set the existing filename with <ulink url="&gtk-file-chooser-filename;">
      <code>gtk-file-chooser-filename</code></ulink>.
     </listitem>
     <listitem>
      To choose a folder instead of a file. Use the keyword <code>select-folder</code>.
     </listitem>
    </itemizedlist>
   </section>

   <section id="Response_Codes">
    <title>Response Codes</title>
    <para>
     <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink> inherits from
     <ulink url="&gtk-dialog;"><code>gtk-dialog</code></ulink>, so buttons that go in its action area have
     response codes such as <code>:accept</code> and <code>:canel</code>.  For example, you could create a
     file chooser dialog as follows:
    </para>
    <programlisting>
(let ((dialog (gtk-file-chooser-dialog-new "Speichern"
                                           nil
                                           :save
                                           "gtk-save" :accept
                                           "gtk-cancel" :cancel)))
[...]
    </programlisting>
    <para>
     This will create buttons for "Cancel" and "Save" that use stock response identifiers from
     <ulink url="&gtk-response-type;"><code>gtk-response-type</code></ulink>.  For most dialog boxes you can
     use your own custom response codes rather than the ones in <ulink url="&gtk-response-type;">
     <code>gtk-response-type</code></ulink>, but <ulink url="&gtk-file-chooser-dialog;">
     <code>gtk-file-chooser-dialog</code></ulink> assumes that its "accept"-type action, e.g. an "Open" or
     "Save" button, will have one of the following response codes <code>:accept</code>, <code>:ok</code>,
     <code>:yes</code>, or <code>:apply</code>.
    </para>
    <para>
     This is because <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink> must
     intercept responses and switch to folders if appropriate, rather than letting the dialog terminate - the
     implementation uses these known response codes to know which responses can be blocked if appropriate.
     To summarize, make sure you use a stock response code when you use
     <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink> to ensure proper
     operation.
    </para>
    <para>
     Example <link linkend="example-file-chooser-dialog">File Chooser Dialog</link> shows an example for
     selecting a file for save.  The dialog is shown in figure <link linkend="figure-file-chooser-dialog">
     File Chooser Dialog</link>.
    </para>
    <example id="example-file-chooser-dialog">
     <title>File Chooser Dialog</title>
     <programlisting>
(defun example-file-chooser-dialog ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example File Chooser Dialog"
                                 :type :toplevel
                                 :border-width 12
                                 :default-width 300
                                 :default-height 100))
          (button (make-instance 'gtk-button
                                 :label "Select a file for save ..."
                                 :image
                                 (gtk-image-new-from-stock "gtk-save"
                                                           :button))))
      ;; Handle the signal "destroy" for the window.
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Handle the signal "clicked" for the button.
      (g-signal-connect button "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (let ((dialog (gtk-file-chooser-dialog-new "Speichern"
                                                      nil
                                                      :save
                                                      "gtk-save" :accept
                                                      "gtk-cancel" :cancel)))
             (when (eq (gtk-dialog-run dialog) :accept)
               (format t "Saved to file ~A~%"
                       (gtk-file-chooser-get-filename dialog)))
             (gtk-widget-destroy dialog))))
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
    <para>
     The <ulink url="&gtk-file-chooser-button;"><code>gtk-file-chooser-button</code></ulink> is a widget
     that lets the user select a file. It implements the <ulink url="&gtk-file-chooser;">
     <code>gtk-file-chooser</code></ulink> interface.  Visually, it is a file name with a button to bring up
     a <ulink url="&gtk-file-chooser-dialog;"><code>gtk-file-chooser-dialog</code></ulink>.  The user can
     then use that dialog to change the file associated with that button.
    </para>
    <para>
     Example <link linkend="example-file-chooser-button">File Chooser Button</link> shows an example for a
     file chooser button to open a file.
    </para>
    <example id="example-file-chooser-button">
     <title>File Chooser Button</title>
     <programlisting>
(defun example-file-chooser-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example File Chooser Button"
                                 :type :toplevel
                                 :border-width 12
                                 :default-width 300
                                 :default-height 100))
          (button (make-instance 'gtk-file-chooser-button
                                 :action :open)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect button "file-set"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "File set: ~A~%"
                                  (gtk-file-chooser-get-filename button))))
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Selecting_Fonts">
   <title>Selecting Fonts</title>
   <figure id="figure-font-chooser-widget">
    <title>Font Chooser Dialog</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/font-chooser-dialog.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-font-chooser-widget;"><code>gtk-font-chooser-widget</code></ulink> widget lists the
    available fonts, styles and sizes, allowing the user to select a font.  It is used in the
    <ulink url="&gtk-font-chooser-dialog;"><code>gtk-font-chooser-dialog</code></ulink> widget to provide a
    dialog box for selecting fonts.
   </para>
   <para>
    The <ulink url="&gtk-font-chooser-dialog;"><code>gtk-font-chooser-dialog</code></ulink> widget is a
    dialog for selecting a font.  It implements the <ulink url="&gtk-font-chooser;">
    <code>gtk-font-chooser</code></ulink> interface.
   </para>
   <para>
    To set the font which is initially selected, use the functions <ulink url="&gtk-font-chooser-font;">
    <code>gtk-font-chooser-font</code></ulink> or <ulink url="&gtk-font-chooser-font-desc;">
    <code>gtk-font-chooser-font-desc</code></ulink>.
   </para>
   <para>
    To get the selected font use the functions <ulink url="&gtk-font-chooser-font;">
    <code>gtk-font-chooser-font</code></ulink> or <ulink url="&gtk-font-chooser-font-desc;">
    <code>gtk-font-chooser-font-desc</code></ulink>.
   </para>
   <para>
    To change the text which is shown in the preview area, use the function
    <ulink url="&gtk-font-chooser-preview-text;"><code>gtk-font-chooser-preview-text</code></ulink>.
   </para>
   <para>
    The <ulink url="&gtk-font-button;"><code>gtk-font-button</code></ulink> is a button which displays the
    currently selected font and allows to open a font chooser dialog to change the font.  It is a suitable
    widget for selecting a font in a preference dialog.
   </para>
   <example id="example-font-button">
    <title>Font Chooser Dialog with a filter to select fonts</title>
    <programlisting>
(defun font-filter (family face)
  (declare (ignore face))
  (member (pango-font-family-name family)
          '("Sans" "Serif")
          :test #'equal))

(defun example-font-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Font Chooser Button"
                                 :type :toplevel
                                 :border-width 12
                                 :default-width 300
                                 :default-height 100))
          (button (make-instance 'gtk-font-button)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Set a filter function to select fonts for the font chooser
      (gtk-font-chooser-set-filter-func button #'font-filter)
      (g-signal-connect button "font-set"
         (lambda (widget)
           (declare (ignore widget))
           (format t "Font is set:~%")
           (format t "   Font name   : ~A~%"
                   (gtk-font-chooser-font button))
           (format t "   Font family : ~A~%"
                   (pango-font-family-name
                     (gtk-font-chooser-font-family button)))
           (format t "   Font face   : ~A~%"
                   (pango-font-face-face-name
                     (gtk-font-chooser-get-font-face button)))
           (format t "   Font size   : ~A~%"
                   (gtk-font-chooser-get-font-size button))))
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>
    
 <chapter id="Miscellaneous Widgets">
  <title>Miscellaneous Widgets</title>

  <section id="Arrows">
   <sectioninfo>
    <itermset>
     <indexterm zone="Arrows">
      <primary>GtkArrow</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>arrow, gtk-arrow</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>arrow-new, gtk-arrow-new</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>arrow-set, gtk-arrow-set</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>GtkArrowType</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>arrow-type, gtk-arrow-type</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>GtkShadowType</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>shadow-type, gtk-shadow-type</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>arrow-scaling</primary>
     </indexterm>
     <indexterm zone="Arrows">
      <primary>widget-tooltip-text, gtk-widget-tooltip-text</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Arrows</title>
   <figure id="figure-arrows">
    <title>Arrows</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/arrow-buttons.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The arrow widget draws an arrowhead, facing in a number of possible directions and having a number of
    possible styles.  It can be very useful when placed on a button.  Like the label widget, the arrow
    widget emits no signals. There are only two functions for manipulating an arrow widget
    <ulink url="&gtk-arrow-new;"><code>gtk-arrow-new</code></ulink> and <ulink url="&gtk-arrow-set;">
    <code>gtk-arrow-set</code></ulink>.  The first function creates a new arrow widget with the indicated
    type and appearance.  The second function allows these values to be altered retrospectively.  The type
    of an arrow can be one of of the values of the enumeration type <ulink url="&gtk-arrow-type;">
    <code>gtk-arrow-type</code></ulink>. Possible values are <code>:up</code>, <code>:down</code>,
    <code>:left</code> and <code>:right</code>.  These values obviously indicate the direction in which the
    arrow will point.
   </para>
   <para>
    The shadow type argument is of the enumeration type <ulink url="&gtk-shadow-type;">
    <code>gtk-shadow-type</code></ulink> and may take one of the the values <code>:none</code>,
    <code>:in</code>, <code>:etched-in</code> and <code>:etched-out</code>.
   </para>
   <para>
    The amount of space used by the arrow is controlled by the style property <code>arrow-scaling</code>.
    The style property <code>arrow-scaling</code> takes values of type <code>double</code> in a range of
    <code>[0,1]</code>.  The default value is <code>0.7</code>.
   </para>
   <para>
    Example <link linkend="example-arrows">Arrows</link> shows a brief example to illustrate the use of
    arrows in buttons.  In addition, this example introduces the function
    <ulink url="&gtk-widget-tooltip-text;"><code>gtk-widget-tooltip-text</code></ulink>, which attaches a
    tooltip to the button widget.  The tooltip pops up, when the mouse is over the button.
   </para>
   <example id="example-arrows">
    <title>Buttons with Arrows</title>
    <programlisting>
(defun create-arrow-button (arrow-type shadow-type)
  (let (;; Create a button
        (button (make-instance 'gtk-button
                               ;; Add a small margin around the button
                               :margin 3
                               ;; Make big buttons of size 75 x 75
                               :width-request 75
                               :height-request 75)))
    ;; Add an arrow to the button
    (gtk-container-add button
                       (make-instance 'gtk-arrow
                                      :arrow-type arrow-type
                                      :shadow-type shadow-type))
    ;; Add a tooltip to the button
    (setf (gtk-widget-tooltip-text button)
          (format nil "Arrow of type ~A" (symbol-name arrow-type)))
    button))

(defun example-arrows ()
  (within-main-loop
    (let ((;; Create the main window
           window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Arrow Buttons"
                                 :default-width 275
                                 :default-height 125
                                 :border-width 12))
          ;; Create a grid for the buttons
          (grid (make-instance 'gtk-grid
                               :orientation :horizontal
                               :column-homogeneous t)))
      ;; Connect a signal handler to the window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Create buttons with an arrow and add the buttons to the grid
      (gtk-container-add grid (create-arrow-button :up :in))
      (gtk-container-add grid (create-arrow-button :down :out))
      (gtk-container-add grid (create-arrow-button :left :etched-in))
      (gtk-container-add grid (create-arrow-button :right :etched-out))
      ;; Add the grid to the window
      (gtk-container-add window grid)
      ;; Show the window
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Calendar">
   <sectioninfo>
    <itermset>
     <indexterm zone="Calendar">
      <primary>GtkCalendar</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar, gtk-calendar</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-new, gtk-calendar-new</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-select-month, gtk-calendar-select-month</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-select-day, gtk-calendar-select-day</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-mark-day, gtk-calendar-mark-day</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-unmark-day, gtk-calendar-unmark-day</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-clear-marks, gtk-calendar-clear-marks</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-display-options, gtk-calendar-display-options</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-date, gtk-calendar-date</primary>
     </indexterm>
     <indexterm zone="Calendar">
      <primary>calendar-set-detail-func, gtk-calendar-set-detail-func</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Calendar</title>
   <figure id="figure-calendar">
    <title>Calendar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/calendar.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The <ulink url="&gtk-calendar;"><code>gtk-calendar</code></ulink> widget displays a Gregorian calendar,
    one month at a time.  It can be created with the function <ulink url="&gtk-calendar-new;">
    <code>gtk-calendar-new</code></ulink>.
   </para>
   <para>
    The month and year currently displayed can be altered with the function
    <ulink url="&gtk-calendar-select-month;"><code>gtk-calendar-select-month</code></ulink>.  The exact day
    can be selected from the displayed month using the function <ulink url="&gtk-calendar-select-day;">
    <code>gtk-calendar-select-day</code></ulink>.
   </para>
   <para>
    To place a visual marker on a particular day, use the function <ulink url="&gtk-calendar-mark-day;">
    <code>gtk-calendar-mark-day</code></ulink> and to remove the marker the function
    <ulink url="&gtk-calendar-unmark-day;"><code>gtk-calendar-unmark-day</code></ulink>.  Alternative, all
    marks can be cleared with the function <ulink url="&gtk-calendar-clear-marks;">
    <code>gtk-calendar-clear-marks</code></ulink>.
   </para>
   <para>
    The way in which the calendar itself is displayed can be altered using the function
    <ulink url="&gtk-calendar-display-options;"><code>gtk-calendar-display-options</code></ulink>.
   </para>
   <para>
    The selected date can be retrieved from a <ulink url="&gtk-calendar;"><code>gtk-calendar</code></ulink>
    using the function <ulink url="&gtk-calendar-date;"><code>gtk-calendar-date</code></ulink>.
   </para>
   <para>
    Users should be aware that, although the Gregorian calendar is the legal calendar in most countries, it
    was adopted progressively between 1582 and 1929.  Display before these dates is likely to be historically
    incorrect.
   </para>
   <para>
    Example <link linkend="example-calendar">Calendar</link> shows a brief example of the calendar widget.
    It is possible to set a special function with the function <ulink url="&gtk-calendar-set-detail-func;">
    <code>gtk-calendar-set-detail-func</code></ulink>.  The example uses this to show a tooltip
    whenever the 12th day of a month is selected.
   </para>
   <example id="example-calendar">
    <title>Calendar</title>
    <programlisting>
(defun example-calendar ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Example Calendar"
                                 :type :toplevel
                                 :border-width 24
                                 :default-width 250
                                 :default-height 100))
          (frame (make-instance 'gtk-frame))
          (calendar (make-instance 'gtk-calendar
                                   :show-details nil)))
      ;; Connect a signal handler to the window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Connect a signal handler to print the selected day
      (g-signal-connect calendar "day-selected"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "selected: year ~A month ~A day ~A~%"
                                  (gtk-calendar-year calendar)
                                  (gtk-calendar-month calendar)
                                  (gtk-calendar-day calendar))))
      ;; Install a calendar detail function
      (gtk-calendar-set-detail-func calendar
                                    (lambda (calendar year month day)
                                      (declare (ignore calendar year month))
                                      (when (= day 12)
                                        "This day has a tooltip.")))
      ;; Mark a day
      (gtk-calendar-mark-day calendar 6)
      ;; Put the calendar into the frame and the frame into the window.
      (gtk-container-add frame calendar)
      (gtk-container-add window frame)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Event_Box">
   <sectioninfo>
    <itermset>
     <indexterm zone="Event_Box">
      <primary>GtkEventBox</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>event-box, gtk-event-box</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>event-box-new, gtk-event-box-new</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-events, gtk-widget-events</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-realize, gtk-widget-realize</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>GdkWindow</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>window, gdk-window</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>GdkCursor</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>cursor, gdk-cursor</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>cursor-new-from-name, gdk-cursor-new-from-name</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>widget-window, gtk-widget-window</primary>
     </indexterm>
     <indexterm zone="Event_Box">
      <primary>window-cursor, gdk-window-cursor</primary>
     </indexterm>
    </itermset>
   </sectioninfo>

   <title>Event Box</title>

   <figure id="figure-event-box-2">
    <title>Event Box</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/event-box.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Some GTK+ widgets do not have associated X windows, so these widgets just draw on their parents.  Because
    of this, they cannot receive events and if they are incorrectly sized, they do not clip so you can get
    messy overwriting.  If you require more from these widgets, the <ulink url="&gtk-event-box;">
    <code>gtk-event-box</code></ulink> widget is for you.
   </para>
   <para>
    At first glance, the <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink> widget might appear
    to be totally useless. It draws nothing on the screen and responds to no events. However, it does serve
    a function - it provides an X window for its child widget. This is important as many GTK+ widgets do not
    have an associated X window. Not having an X window saves memory and improves performance, but also has
    some drawbacks. A widget without an X window cannot receive events, and does not perform any clipping on
    its contents. Although the name <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink>
    emphasizes the event-handling function, the widget can also be used for clipping.
   </para>
   <para>
    To create a new <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink> widget, use the call
    <code>(make-instance 'gtk-event-box)</code> or the function <ulink url="&gtk-event-box-new;">
    <code>gtk-event-box-new</code></ulink>. A child widget can then be added to this event box with the
    function &gtk-container-add;. With the function
    <ulink url="&gtk-widget-events;"><code>gtk-widget-events</code></ulink> the events are set for the event
    box which can be connected to a signal handler. To create the resources associated with an event box,
    the function <ulink url="&gtk-widget-realize;"><code>gtk-widget-realize</code></ulink> has to be called
    explicitly for the <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink> widget.
   </para>
   <para>
    Example <link linkend="example-event-box">Event Box</link> demonstrates both uses of a
    <ulink url="&gtk-event-box;"><code>gtk-event-box</code></ulink> widget - a label is created that is
    clipped to a small box, and set up so that a mouse-click on the label causes the program to exit.
    Resizing the window reveals varying amounts of the label.
   </para>
   <para>
    In addition, example <link linkend="example-event-box">Event Box</link> shows how to change the cursor
    over a window. Every widget has an associated window of type <ulink url="&gdk-window;">
    <code>gdk-window</code></ulink>, which can be get with the function <ulink url="&gtk-widget-window;">
    <code>gtk-widget-window</code></ulink>. The function <ulink url="&gdk-window-cursor;">
    <code>gdk-window-cursor</code></ulink> sets a cursor for this <ulink url="&gdk-window;">
    <code>gdk-window</code></ulink>. A new cursor is created with the function
    <ulink url="&gdk-cursor-new-from-name;"><code>gdk-cursor-new-from-name</code></ulink>. The function
    takes two arguments. The first argument is the <ulink url="&gdk-display;">
    <code>gdk-display</code></ulink> object for which the cursor will be created. The second argument is a
    string with the name of the cursor. Look at the documentation of the function
    <ulink url="&gdk-cursor-new-from-name;"><code>gdk-cursor-new-from-name</code></ulink> for available
    cursor names. In example <link linkend="example-event-box">Event Box</link> the cursor with the name
    "pointer" is choosen. This cursor is associated to the <ulink url="&gdk-window;">
    <code>gdk-window</code></ulink> with the function <ulink url="&gdk-window-cursor;">
    <code>gdk-window-cursor</code></ulink>.
   </para>
   <example id="example-event-box">
    <title>Event Box</title>
    <programlisting>
(defun example-event-box ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Event Box"
                                 :default-height 150
                                 :border-width 24))
          (eventbox (make-instance 'gtk-event-box))
          (label (make-instance 'gtk-label
                                :ellipsize :end
                                :label
                                "Click here to quit this Example Event Box.")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Set the available events for the event box
      (setf (gtk-widget-events eventbox) :button-press-mask)
      ;; Connect a signal handler to the eventbox
      (g-signal-connect eventbox "button-press-event"
                        (lambda (widget event)
                          (declare (ignore widget event))
                          (gtk-widget-destroy window)))
      ;; Add the label to the event box and the event box to the window
      (gtk-container-add eventbox label)
      (gtk-container-add window eventbox)
      ;; Realize the event box
      (gtk-widget-realize eventbox)
      ;; Set a new cursor for the event box
      (setf (gdk-window-cursor (gtk-widget-window eventbox))
            (gdk-cursor-new-from-name (gdk-display-default) "pointer"))
      ;; Show the window
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="Text_Entries">
   <title>Text Entries</title>

   <figure id="figure-text-entry">
    <title>Text Entry</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/text-entry256x106.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    The entry widget allows text to be typed and displayed in a single line text box.  The text may be set
    with function calls that allow new text to replace, prepend or append the current contents of the Entry
    widget.
   </para>
   <para>
    Create a new Entry widget with the function <ulink url="&gtk-entry-new;">
    <code>gtk-entry-new</code></ulink>.  The generic function <ulink url="&gtk-entry-text;">
    <code>gtk-entry-text</code></ulink> alters the text which is currently within the entry widget.  The
    function <ulink url="&gtk-entry-text;"><code>gtk-entry-text</code></ulink> sets the contents of the entry   
    widget, replacing the current contents.  Note that the class entry implements the editable interface
    which contains some more functions for manipulating the contents.
   </para>
   <para>
    The contents of the entry can be retrieved by using a call to the function <ulink url="&gtk-entry-text;">
    <code>gtk-entry-text</code></ulink>.  This is useful in the callback functions described below.
   </para>
   <para>
    If we do not want the contents of the entry to be changed by someone typing into it, we can change its
    editable state with the function <ulink url="&gtk-editable-editable;">
    <code>gtk-editable-editable</code></ulink>.  This function allows us to toggle the editable state of the
    entry widget by passing in a <code>T</code> or <code>NIL</code> value for the editable argument.
   </para>
   <para>
    If we are using the entry where we do not want the text entered to be visible, for example when a
    password is being entered, we can use the function <ulink url="&gtk-entry-visibility;">
    <code>gtk-entry-visibility</code></ulink>, which also takes a boolean flag.
   </para>
   <para>
    A region of the text may be set as selected by using the function
    <ulink url="&gtk-editable-select-region;"><code>gtk-editable-select-region</code></ulink>.  This would
    most often be used after setting some default text in an Entry, making it easy for the user to remove it.
   </para>
   <para>
    If we want to catch when the user has entered text, we can connect to the activate or changed signal.
    Activate is raised when the user hits the enter key within the entry widget.  Changed is raised when the
    text changes at all, e.g., for every character entered or removed.
   </para>
   <para>
    Example <link linkend="example-text-entry">Text Entry</link> is an example of using an entry widget.
   </para>
   <example id="example-text-entry">
    <title>Text Entry</title>
    <programlisting>
(defun example-text-entry ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :title "Example Text Entry"
                                  :default-width 250))
           (vbox (make-instance 'gtk-box :orientation :vertical))
           (hbox (make-instance 'gtk-box :orientation :horizontal))
           (entry (make-instance 'gtk-entry
                                 :text "Hello"
                                 :max-length 50))
           (pos (gtk-entry-text-length entry)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (g-signal-connect entry "activate"
                        (lambda (widget)
                          (declare (ignore widget))
                          (format t "Entry contents: ~A"
                                  (gtk-entry-text entry))))
      (gtk-editable-insert-text entry " world" pos)
      (gtk-editable-select-region entry 0 (gtk-entry-text-length entry))
      (gtk-box-pack-start vbox entry :expand t :fill t :padding 0)
      (let ((check (gtk-check-button-new-with-label "Editable")))
        (g-signal-connect check "toggled"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-editable-set-editable
                                      entry
                                      (gtk-toggle-button-active check))))
        (gtk-box-pack-start hbox check))
      (let ((check (gtk-check-button-new-with-label "Visible")))
        (setf (gtk-toggle-button-active check) t)
        (g-signal-connect check "toggled"
           (lambda (widget)
             (declare (ignore widget))
             (setf (gtk-entry-visibility entry)
                   (gtk-toggle-button-active check))))
        (gtk-box-pack-start hbox check))
      (gtk-box-pack-start vbox hbox)
      (let ((button (gtk-button-new-with-label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Spin_Buttons">
   <title>Spin Buttons</title>
   <figure id="figure-spin-button">
    <title>Spin Button</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/spin-button306x347.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The spin button widget is generally used to allow the user to select a value from a range of numeric
    values.  It consists of a text entry box with up and down arrow buttons attached to the side.  Selecting
    one of the buttons causes the value to "spin" up and down the range of possible values.  The entry box
    may also be edited directly to enter a specific value.
   </para>
   <para>
    The spin button allows the value to have zero or a number of decimal places and to be incremented or
    decremented in configurable steps.  The action of holding down one of the buttons optionally results in
    an acceleration of change in the value according to how long it is depressed.
   </para>
   <para>
    The spin button uses an adjustment object to hold information about the range of values that the spin
    button can take. This makes for a powerful spin button widget.
   </para>
   <para>
    Recall that an adjustment object is created with the function <ulink url="&gtk-adjustment-new;">
    <code>gtk-adjustment-new</code></ulink>, which has the arguments <code>value</code>, <code>lower</code>,
    <code>step-increment</code>, <code>page-increment</code>, and <code>page-size</code>.  These properties
    of an adjustment are used by the spin button in the following way:
   </para>
   <table id="table-gtk-adjustment-properties" frame='all'>
    <title>Properties of GtkAdjustment</title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>value</code></entry>
       <entry valign="top">initial value for the Spin Button</entry>
      </row>
      <row>
       <entry valign="top"><code>lower</code></entry>
       <entry valign="top">lower range value</entry>
      </row>
      <row>
       <entry valign="top"><code>upper</code></entry>
       <entry valign="top">upper range value</entry>
      </row>
      <row>
       <entry valign="top"><code>step-increment</code></entry>
       <entry valign="top">value to increment/decrement when pressing mouse button 1 on a button</entry>
      </row>
      <row>
       <entry valign="top"><code>page-increment</code></entry>
       <entry valign="top">value to increment/decrement when pressing mouse button 2 on a button</entry>
      </row>
      <row>
       <entry valign="top"><code>page-size</code></entry>
       <entry valign="top">unused</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Additionally, mouse button 3 can be used to jump directly to the upper or lower values when used to
    select one of the buttons. A spin button is created with the function <ulink url="&gtk-spin-button-new;">
    <code>gtk-spin-button-new</code></ulink>, which as the arguments <code>adjustment</code>,
    <code>climb-rate</code>, and <code>digits</code>.
   </para>
   <para>
    The <code>climb-rate</code> argument take a value between 0.0 and 1.0 and indicates the amount of
    acceleration that the spin button has.  The <code>digits</code> argument specifies the number of decimal
    places to which the value will be displayed.
   </para>
   <para>
    A spin button can be reconfigured after creation using the function
    <ulink url="&gtk-spin-button-configure;"><code>gtk-spin-button-configure</code></ulink>.  The first
    argument specifies the spin button that is to be reconfigured.  The other arguments are as specified for
    the function <ulink url="&gtk-spin-button-new;"><code>gtk-spin-button-new</code></ulink>.
   </para>
   <para>
    The adjustment can be set and retrieved independently using the function
    <ulink url="&gtk-spin-button-adjustment;"><code>gtk-spin-button-adjustment</code></ulink>.
   </para>
   <para>
    The number of decimal places can also be altered using the function
    <ulink url="&gtk-spin-button-digits;"><code>gtk-spin-button-digits</code></ulink> and the value that a
    spin button is currently displaying can be changed using the function
    <ulink url="&gtk-spin-button-value;"><code>gtk-spin-button-value</code></ulink>.
   </para>
   <para>
    The current value of a spin button can be retrieved as either a floating point or integer value with the
    functions <ulink url="&gtk-spin-button-value;"><code>gtk-spin-button-value</code></ulink> and
    <ulink url="&gtk-spin-button-value-as-int;"><code>gtk-spin-button-value-as-int</code></ulink>.
   </para>
   <para>
    If you want to alter the value of a spin button relative to its current value, then the function
    <ulink url="&gtk-spin-button-spin;"><code>gtk-spin-button-spin</code></ulink> can be used, which has the
    three arguments <code>spin-button</code>, <code>direction</code>, and <code>increment</code>.  The
    argument <code>direction</code> is of the enumeration type <code>GtkSpinType</code>, which can take one
    of the values shown in table <link linkend="table-gtk-spin-type">GtkSpinType</link>.
   </para>
   <table id="table-gtk-spin-type" frame='all'>
    <title>Values of the type <code>GtkSpinType</code></title>
    <tgroup cols='2' align='left' colsep='0' rowsep='0'>
     <thead>
      <row>
       <entry>Value&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry valign="top"><code>:step-forward</code></entry>
       <entry valign="top">Increment by the adjustments step increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:backward</code></entry>
       <entry valign="top">Decrement by the adjustments step increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:forward</code></entry>
       <entry valign="top">Increment by the adjustments page incremstent.</entry>
      </row>
      <row>
       <entry valign="top"><code>:page-backward</code></entry>
       <entry valign="top">Decrement by the adjustments page increment.</entry>
      </row>
      <row>
       <entry valign="top"><code>:home</code></entry>
       <entry valign="top">Go to the adjustments lower bound.</entry>
      </row>
      <row>
       <entry valign="top"><code>:end</code></entry>
       <entry valign="top">Go to the adjustments upper bound.</entry>
      </row>
      <row>
       <entry valign="top"><code>:user-defined</code></entry>
       <entry valign="top">Change by a specified amount.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <code>:step-forward</code> and <code>:step-backward</code> change the value of the spin button by the
    amount specified by increment, unless increment is equal to 0, in which case the value is changed by the
    value of <code>step-increment</code> in the adjustment.
   </para>
   <para>
    <code>:page-forward</code> and <code>:page-backward</code> simply alter the value of the spin button by
    <code>increment</code>.
   </para>
   <para>
    <code>:home</code> sets the value of the spin button to the bottom of the adjustments range and
    <code>:end</code> sets the value of the spin button to the top of the adjustments range.
   </para>
   <para>
    <code>:user-defined</code> simply alters the value of the spin button by the specified amount.
   </para>
   <para>
    We move away from functions for setting and retrieving the range attributes of the spin button now, and
    move onto functions that affect the appearance and behavior of the spin button widget itself.
   </para>
   <para>
    The first of these functions is <ulink url="&gtk-spin-button-numeric;">
    <code>gtk-spin-button-numeric</code></ulink>, which is used to constrain the text box of the spin button
    such that it may only contain a numeric value.  This prevents a user from typing anything other than
    numeric values into the text box of a spin button.
   </para>
   <para>
    You can set whether a Spin Button will wrap around between the upper and lower range values with the
    function <ulink url="&gtk-spin-button-wrap;"><code>gtk-spin-button-wrap</code></ulink>.  You can set a
    spin button to round the value to the nearest <code>step-increment</code>, which is set within the
    adjustment object used with the spin button.  This is accomplished with the function
    <ulink url="&gtk-spin-button-snap-to-ticks;"><code>gtk-spin-button-snap-to-ticks</code></ulink>.
   </para>
   <para>
    The update policy of a spin button can be changed with the function
    <ulink url="&gtk-spin-button-update-policy;"><code>gtk-spin-button-update-policy</code></ulink>.  The
    possible values of policy are either <code>:always</code> or <code>:if-valid</code>.  These policies
    affect the behavior of a Spin Button when parsing inserted text and syncing its value with the values of
    the adjustment.
   </para>
   <para>
    In the case of <code>:if-valid</code> the spin button value only gets changed if the text input is a
    numeric value that is within the range specified by the adjustment.  Otherwise the text is reset to the
    current value.  In case of <code>:always</code> we ignore errors while converting text into a numeric
    value.
   </para>
   <para>
    Finally, you can explicitly request that a spin button update itself with the function
    <ulink url="&gtk-spin-button-update;"><code>gtk-spin-button-update</code></ulink>.
   </para>
   <example id="example-spin-button">
    <title>Spin Button</title>
    <programlisting>
(defun example-spin-button ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Example Spin Button"
                                 :default-width 300))
          (vbox (make-instance 'gtk-box
                               :orientatin :vertical
                               :homogeneous nil
                               :spacing 6
                               :border-width 12))
          (vbox1 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0
                                :border-width 6))
          (vbox2 (make-instance 'gtk-box
                                :orientation :vertical
                                :homogeneous nil
                                :spacing 0
                                :boder-width 6))
          (hbox (make-instance 'gtk-box :orientation :horizontal))
          (frame1 (make-instance 'gtk-frame
                                 :label "Not accelerated"))
          (frame2 (make-instance 'gtk-frame
                                 :label "Accelerated"))
          (label (make-instance 'gtk-label
                                :label "0")))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1.0
                                                   :upper 31.0
                                                   :step-increment 1.0
                                                   :page-increment 5.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Day :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1.0
                                                   :upper 12.0
                                                   :step-increment 1.0
                                                   :page-increment 5.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Month :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner (make-instance 'gtk-spin-button
                                    :adjustment
                                    (make-instance 'gtk-adjustment
                                                   :value 1.0
                                                   :lower 1998.0
                                                   :upper 2100.0
                                                   :step-increment 1.0
                                                   :page-increment 100.0
                                                   :page-size 0.0)
                                    :climb-rate 0
                                    :digits 0
                                    :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Year :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner :expand nil :fill t)
        (gtk-box-pack-start hbox vbox :padding 6))
      (gtk-box-pack-start vbox1 hbox :padding 6)
      (gtk-container-add frame1 vbox1)
      (gtk-box-pack-start vbox frame1)
      (setq hbox (make-instance 'gtk-box :orientation :horizontal))
      (let ((vbox (make-instance 'gtk-box :orientation :vertical))
            (spinner1 (make-instance 'gtk-spin-button
                                     :adjustment
                                     (make-instance 'gtk-adjustment
                                                    :value 1.0
                                                    :lower -10000.0
                                                    :upper  10000.0
                                                    :step-increment 0.5
                                                    :page-increment 100.0
                                                    :page-size 0.0)
                                     :climb-rate 1.0
                                     :digits 2
                                     :wrap t))
            (spinner2 (make-instance 'gtk-spin-button
                                     :adjustment
                                     (make-instance 'gtk-adjustment
                                                    :value 2
                                                    :lower 1
                                                    :upper 5
                                                    :step-increment 1
                                                    :page-increment 1
                                                    :page-size 0)
                                     :climb-rate 0.0
                                     :digits 0
                                     :wrap t)))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Value :"
                                           :xalign 0
                                           :yalign 0.5)
                            :fill t)
        (gtk-box-pack-start vbox spinner1 :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6)
        (g-signal-connect spinner2 "value-changed"
           (lambda (widget)
             (declare (ignore widget))
             (gtk-spin-button-set-digits
                               spinner1
                               (gtk-spin-button-get-value-as-int spinner2))))
        (setq vbox (make-instance 'gtk-box :orientation :vertical))
        (gtk-box-pack-start vbox
                            (make-instance 'gtk-label
                                           :label "Digits :"
                                           :xalign 0
                                           :yalign 0.5)
                            :expand nil)
        (gtk-box-pack-start vbox spinner2 :expand nil)
        (gtk-box-pack-start hbox vbox :padding 6)
        (gtk-box-pack-start vbox2 hbox :padding 6)
        (let ((check (make-instance 'gtk-check-button
                                    :label "Snap to 0.5-ticks"
                                    :active t)))
          (g-signal-connect check "clicked"
             (lambda (widget)
               (gtk-spin-button-set-snap-to-ticks
                                     spinner1
                                     (gtk-toggle-button-active widget))))
          (gtk-box-pack-start vbox2 check))
        (let ((check (make-instance 'gtk-check-button
                                    :label "Numeric only input mode"
                                    :active t)))
          (g-signal-connect check "clicked"
             (lambda (widget)
               (gtk-spin-button-set-numeric
                                     spinner1
                                     (gtk-toggle-button-active widget))))
          (gtk-box-pack-start vbox2 check))
        (gtk-container-add frame2 vbox2)
        (setq hbox (make-instance 'gtk-box :orientation :horizontal))
        (let ((button (gtk-button-new-with-label "Value as Int")))
          (g-signal-connect button "clicked"
             (lambda (widget)
               (declare (ignore widget))
               (setf (gtk-label-text label)
                     (format nil "~A"
                             (gtk-spin-button-get-value-as-int spinner1)))))
            (gtk-box-pack-start hbox button))
        (let ((button (gtk-button-new-with-label "Value as Float")))
          (g-signal-connect button "clicked"
             (lambda (widget)
               (declare (ignore widget))
               (setf (gtk-label-text label)
                     (format nil "~A"
                             (gtk-spin-button-value spinner1)))))
          (gtk-box-pack-start hbox button))
        (gtk-box-pack-start vbox2 hbox)
        (gtk-box-pack-start vbox2 label))
      (gtk-box-pack-start vbox frame2)
      (let ((button (make-instance 'gtk-button
                                   :label "Close")))
        (g-signal-connect button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window)))
        (gtk-box-pack-start vbox button))
      (gtk-container-add window vbox)
      (gtk-widget-show window))))
    </programlisting>
   </example>
  </section>

  <section id="Combo_Box">
   <title>Combo Box</title>

   <section id="General_Combo_Box">
    <sectioninfo>
     <itermset>
      <indexterm zone="General_Combo_Box">
       <primary>GtkComboBox</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>combo-box, gtk-combo-text</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>GtkCellLayout</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>cell-layout, gtk-cell-layout</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>has-entry</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>GtkEntry</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>entry, gtk-entry</primary>
      </indexterm>
      <indexterm zone="General_Combo_Box">
       <primary>bin-child, gtk-bin-child</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>General Combo Box</title>
    <figure id="figure-combo-box">
     <title>Combo Box</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/combo-box386x131.gif" format="gif"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     A <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> is a widget that allows the user to
     choose from a list of valid choices.  The <ulink url="&gtk-combo-box;">
     <code>gtk-combo-box</code></ulink> displays the selected choice.  When activated, the
     <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> displays a popup which allows the user
     to make a new choice.  The style in which the selected value is displayed, and the style of the popup is
     determined by the current theme.  It may be similar to a Windows-style combo box.
    </para>
    <para>
     The <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> uses the model-view pattern; the
     list of valid choices is specified in the form of a tree model, and the display of the choices can be
     adapted to the data in the model by using cell renderers, as you would in a tree view.  This is possible
     since <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> implements the
     <ulink url="&gtk-cell-layout;"><code>gtk-cell-layout</code></ulink> interface.  The tree model holding
     the valid choices is not restricted to a flat list, it can be a real tree, and the popup will reflect 
     the tree structure.
    </para>
    <para>
     To allow the user to enter values not in the model, the <code>has-entry</code> property allows the
     <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> to contain a <ulink url="&gtk-entry;">
     <code>gtk-entry</code></ulink>.  This entry can be accessed by calling <ulink url="&gtk-bin-child;">
     <code>gtk-bin-child</code></ulink> on the combo box.
    </para>
    <para>
     For a simple list of textual choices, the model-view API of <ulink url="&gtk-combo-box;">
     <code>gtk-combo-box</code></ulink> can be a bit overwhelming.  In this case,
     <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> offers a simple alternative.
     Both <ulink url="&gtk-combo-box;"><code>gtk-combo-box</code></ulink> and
     <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> can contain an entry.
    </para>
    <example id="Combo Box">
     <title>Combo Box</title>
     <programlisting>
(defun example-combo-box ()
  (within-main-loop
    (let* ((window (make-instance 'gtk-window
                                  :type :toplevel
                                  :border-width 12
                                  :title "Example Combo Box"))
           (model (make-instance 'gtk-list-store
                                 :column-types '("gchararray" "gint")))
           (combo-box (make-instance 'gtk-combo-box :model model))
           (title-label (make-instance 'gtk-label :label "Title:"))
           (value-label (make-instance 'gtk-label :label "Value:"))
           (title-entry (make-instance 'gtk-entry))
           (value-entry (make-instance 'gtk-entry))
           (button (make-instance 'gtk-button :label "Add"))
           (table (make-instance 'gtk-table
                                 :n-rows 3
                                 :n-columns 3)))
      ;; Fill in data into the columns
      (gtk-list-store-set model (gtk-list-store-append model) "Monday" 1)
      (gtk-list-store-set model (gtk-list-store-append model) "Tuesday" 2)
      (gtk-list-store-set model (gtk-list-store-append model) "Wednesday" 3)
      (gtk-list-store-set model (gtk-list-store-append model) "Thursday" 4)
      (gtk-list-store-set model (gtk-list-store-append model) "Friday" 5)
      (gtk-list-store-set model (gtk-list-store-append model) "Saturday" 6)
      (gtk-list-store-set model (gtk-list-store-append model) "Sunday" 7)
      ;; Set the first entry to active
      (setf (gtk-combo-box-active combo-box) 0)
      ;; Define the signal handlers
      (g-signal-connect window "destroy"
                        (lambda (w)
                          (declare (ignore w))
                          (leave-gtk-main)))
      (g-signal-connect button "clicked"
         (lambda (widget)
           (declare (ignore widget))
           (gtk-list-store-set model
                               (gtk-list-store-append model)
                               (gtk-entry-text title-entry)
                               (or (parse-integer
                                     (gtk-entry-text value-entry)
                                     :junk-allowed t)
                                   0))))
      (g-signal-connect combo-box "changed"
         (lambda (widget)
           (declare (ignore widget))
           (let ((dialog (gtk-message-dialog-new
                             window
                             '(:destroy-with-parent)
                             :info
                             :close
                             "You selected row ~A"
                             (gtk-combo-box-active combo-box))))
             (gtk-dialog-run dialog)
             (gtk-widget-destroy dialog))))
      ;; Create renderers for the cells
      (let ((renderer (make-instance 'gtk-cell-renderer-text
                                     :text "A text")))
        (gtk-cell-layout-pack-start combo-box renderer :expand t)
        (gtk-cell-layout-add-attribute combo-box renderer "text" 0))
      (let ((renderer (make-instance 'gtk-cell-renderer-text
                                     :text "A number")))
        (gtk-cell-layout-pack-start combo-box renderer :expand nil)
        (gtk-cell-layout-add-attribute combo-box renderer "text" 1))
      ;; Align the labels
      (gtk-misc-set-alignment title-label 0.0 0.0)
      (gtk-misc-set-alignment value-label 0.0 0.0)
      ;; Put the widgets into the table
      (gtk-table-attach table title-label 0 1 0 1)
      (gtk-table-attach table value-label 1 2 0 1)
      (gtk-table-attach table title-entry 0 1 1 2)
      (gtk-table-attach table value-entry 1 2 1 2)
      (gtk-table-attach table button      2 3 1 2)
      (gtk-table-attach table combo-box   0 3 2 3)
      ;; Put the table into the window
      (gtk-container-add window table)
      ;; Show the window
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="Combo_Box_Text">
    <sectioninfo>
     <itermset>
      <indexterm zone="Combo_Box_Text">
       <primary>GtkComboBoxText</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text, gtk-combo-box-text</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-new, gtk-combo-box-text-new</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-new-with-entry, gtk-combo-box-text-new-with-entry</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-append-text, gtk-combo-box-text-append-text</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-insert-text, gtk-combo-box-text-insert-text</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-prepend-text, gtk-combo-box-text-prepend-text</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-remove, gtk-combo-box-text-remove</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>combo-box-text-active-text, gtk-combo-box-text-active-text</primary>
      </indexterm>
      <indexterm zone="Combo_Box_Text">
       <primary>bin-child, gtk-bin-child</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Combo Box Text</title>
    <figure id="figure-combo-box-text">
     <title>Combo Box Text</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/combo-box-text151x85.gif" format="gif"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     A <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> is a simple variant of
     <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> that hides the model-view
     complexity for simple text-only use cases.
    </para>
    <para>
     To create a <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink>, use the functions
     <ulink url="&gtk-combo-box-text-new;"><code>gtk-combo-box-text-new</code></ulink> or
     <ulink url="&gtk-combo-box-text-new-with-entry;"><code>gtk-combo-box-text-new-with-entry</code></ulink>.
    </para>
    <para>
     You can add items to a <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> with
     the functions <ulink url="&gtk-combo-box-text-append-text;">
     <code>gtk-combo-box-text-append-text</code></ulink>, <ulink url="&gtk-combo-box-text-insert-text;">
     <code>gtk-combo-box-text-insert-text</code></ulink> or <ulink url="&gtk-combo-box-text-prepend-text;">
     <code>gtk-combo-box-text-prepend-text</code></ulink> and remove options with the function    
     <ulink url="&gtk-combo-box-text-remove;"><code>gtk-combo-box-text-remove</code></ulink>.
    </para>
    <para>
     If the <ulink url="&gtk-combo-box-text;"><code>gtk-combo-box-text</code></ulink> contains an entry via
     the <code>has-entry</code> property, its contents can be retrieved using
     <ulink url="&gtk-combo-box-text-active-text;"><code>gtk-combo-box-text-active-text</code></ulink>.  The
     entry itself can be accessed by calling <ulink url="&gtk-bin-child;"><code>gtk-bin-child</code></ulink>
     on the combo box.
    </para>
    <example id="example-combo-box-text">
     <title>Combo Box Text</title>
     <programlisting>
(defun example-combo-box-text ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :border-width 12
                                 :title "Example Combo Box Text"))
          (combo (make-instance 'gtk-combo-box-text)))
      (gtk-combo-box-text-append-text combo "First entry")
      (gtk-combo-box-text-append-text combo "Second entry")
      (gtk-combo-box-text-append-text combo "Third entry")
      (setf (gtk-combo-box-active combo) 0)
      (gtk-container-add window combo)
      (gtk-widget-show window))))
     </programlisting>
    </example>
   </section>
  </section>
 </chapter>

 <chapter id="Menus_and_Toolbars">
  <title>Menus and Toolbars</title>
  <para>
   This chapter is derived from Stewart Weiss's tutorial
   <ulink url="http://www.compsci.hunter.cuny.edu/~sweiss/course_materials/csci493.70/lecture_notes/GTK_menus.pdf">
   Menus and Toolbars in GTK</ulink>. The original code snippets have been translated to Lisp.
  </para>
  <para>
   GUI applications have menus and toolbars.  They are an important part of how the user interacts with the
   application.  Although menus and toolbars look like different things, they are both containers for widgets
   that, when clicked, result in the performance of actions.  Menus contain menu items, and toolbars usually
   contain buttons.  Although toolbars are actually more general than this in that they can contain arbitrary
   widgets, they are usually used to provide quick access to frequently used menu items.
  </para>

  <section id="Menus">
   <sectioninfo>
    <itermset>
     <indexterm zone="Menus">
      <primary>GtkMenuShell</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-shell, gtk-menu-shell</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenuBar</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-bar, gtk-menu-bar</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenu</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>mneu, gtk-menu</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>menu-item, gtk-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkCheckMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>check-menu-item, gtk-check-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkImageMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>image-menu-item, gtk-image-menu-item</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>GtkSeparatorMenuItem</primary>
     </indexterm>
     <indexterm zone="Menus">
      <primary>separator-menu-itemm gtk-separator-menu-item</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Menus</title>
   <para>
    GTK+ knows several classes related to the creation of menus:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>gtk-menu-shell</code></term>
     <listitem>
      A <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> is the abstract base class used
      to derive the <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> and <ulink url="&gtk-menu-bar;">
      <code>gtk-menu-bar</code></ulink> subclasses. A <ulink url="&gtk-menu-shell;">
      <code>gtk-menu-shell</code></ulink> is a container of <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink> objects arranged in a list which can be navigated, selected, and
      activated by the user to perform application functions.  A <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink> can have a submenu associated with it, allowing for nested
      hierarchical menus.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu-bar</code></term>
     <listitem>
      The <ulink url="&gtk-menu-bar;"><code>gtk-menu-bar</code></ulink> is a subclass of
      <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> which contains one or more menu
      items.  The result is a standard menu bar which can hold many menu items.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu</code></term>
     <listitem>
      A <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> is a <ulink url="&gtk-menu-shell;">
      <code>gtk-menu-shell</code></ulink> that implements a drop down menu consisting of a list of
      <ulink url="&gtk-menu-item;"><code>gtk-menu-item</code></ulink> objects which can be navigated and
      activated by the user to perform application functions. A <ulink url="&gtk-menu;">
      <code>gtk-menu</code></ulink> is most commonly dropped down by activating a
      <ulink url="&gtk-menu-item;"><code>gtk-menu-item</code></ulink> in a <ulink url="&gtk-menu-bar;">
      <code>gtk-menu-bar</code></ulink> or popped up by activating a <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink> in another <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink>.
      Applications can display a <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> as a pop-up menu by
      calling the function <ulink url="&gtk-menu-popup;"><code>gtk-menu-popup</code></ulink>.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-menu-item</code></term>
     <listitem>
      The <ulink url="&gtk-menu-item;"><code>gtk-menu-item</code></ulink> widget and the derived widgets are
      the only valid childs for menus.  Their function is to correctly handle highlighting, alignment, events
      and submenus. As it derives from &gtk-bin; it can hold any
      valid child widget, although only a few are really useful.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-check-menu-item</code></term>
     <listitem>
      A &gtk-check-menu-item; is a menu item that
      maintains the state of a boolean value in addition to a <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink> usual role in activating application code. A check box indicating
      the state of the boolean value is displayed at the left side of the <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink>.  Activating the <ulink url="&gtk-menu-item;">
      <code>gtk-menu-item</code></ulink> toggles the value.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-image-menu-item</code></term>
     <listitem>
      A &gtk-image-menu-item; is a menu item which has
      an icon next to the text label. Note that the user can disable display of menu icons, so make sure to
      still fill in the text label.
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>gtk-separator-menu-item</code></term>
     <listitem>
      The <ulink url="&gtk-separator-menu-item;"><code>gtk-separator-menu-item</code></ulink> is a separator
      used to group items within a menu.  It displays a horizontal line with a shadow to make it appear
      sunken into the interface.
     </listitem>
    </varlistentry>
   </variablelist>

   <section id="Principles_of_Menus">

    <sectioninfo>
     <itermset>
      <indexterm zone="Principles_of_Menus">
       <primary>menu-item-submenu, gtk-menu-item-submenu</primary>
      </indexterm>
     </itermset>
    </sectioninfo>

    <title>Principles of Menus</title>
    <para>
     Menu creation and menu handling follows the following:
    </para>
    <itemizedlist>
     <listitem>
      Menus of the <ulink url="&gtk-menu;"><code>gtk-menu</code></ulink> class and menubars of the
      <ulink url="&gtk-menu-bar;"><code>gtk-menu-bar</code></ulink> class are containers.  They are dervid
      from the same abstract base class <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink>.
     </listitem>
     <listitem>
      The only thing that can be put into a menu or a menubar is a menu item.
     </listitem>
     <listitem>
      Menus can be attached to menu items so that when the item is activated, the menu drops down or pops up.
      If a menu item is a child of a menubar, the menu attached to it drops down.  If it is a child of a
      menu, the menu attached to it pops up.
     </listitem>
     <listitem>
      Menu items are the only things that can be activated, and these emit an "activate" signal, which must
      be connected to a callback to handle the user's clicks on that item.  Although they emit other signals,
      this is the normally used.
     </listitem>
    </itemizedlist>
    <para>
     In essence, menus form a recursively defined hierarchy.  The root of this hierarchy is always a menubar.
     Usually menubars are horizontal, rectangular regions at the top of a window, but they can be vertical as
     well, and can be placed anywhere.  Those labels that can be seen in the menubar, such as "File", "Edit"
     or "Help", are menu items.  Menu items can have menus attached to them, so that when they get clicked,
     the menu appears.  Each of the menus attached to a menu item may have menu items that have menus
     attached to them, and these may have items that have menus attached to them, and so on.
    </para>
    <para>
     Use the term submenu refers to a menu that is attached to a menu item within another menu, but there is
     no special class of submenus; a submenu is just a menu.  Because a menu item always exists as a child of
     either a menu or a menubar, the menu that is attached to a menu item is always a submenu of something
     else.  This should make it easy to remember the fact that there is but a single way to attach a menu to
     a menu item with the generic function <ulink url="&gtk-menu-item-submenu;">
     <code>gtk-menu-item-submenu</code></ulink>.  The point is that the attached menu is of necessity a
     submenu of something else.
    </para>
   </section>

   <section id="Creating_Menus_by_Hand">
    <sectioninfo>
     <itermset>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new, gtk-menu-item-new</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new-with-label, gtk-menu-item-new-with-label</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-new-with-mnemonic, gtk-menu-item-new-with-mnemonic</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-item-label, gtk-menu-item-label</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-append, gtk-menu-shell-append</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-prepend, gtk-menu-shell-prepend</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>menu-shell-insert, gtk-menu-shell-insert</primary>
      </indexterm>
      <indexterm zone="Creating_Menus_by_Hand">
       <primary>separator-menu-item-new, gtk-separator-menu-item-new</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Creating Menus by Hand</title>
    <figure id="figure-menus-by-hand">
     <title>Creating Menus by Hand</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/menus-by-hand.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     This method is called "by hand" because the menu is constructed in the same way that a typical house is
     constructed, by assembling the pieces and attaching them to each other, one by one.  The outline of the
     steps that must be taken is:
    </para>
    <orderedlist>
     <listitem>Create the menubar.</listitem>
     <listitem>Create the menu items that will be packed into the menubar.</listitem>
     <listitem>Pack the menu items into the menubar.</listitem>
     <listitem>Create the menus that the menu items will activate.</listitem>
     <listitem>Attach these submenus to the menu items.</listitem>
     <listitem>
      For each submenu (a) create the menu items that it will contain, and (b) pack these menu items into
      the submenu.
     </listitem>
    </orderedlist>
    <para>
     These steps are listed in a top-down sequence, but it is conceivable to carry them out in many different
     permutations.
    </para>
    <para>
     An empty menubar is created with the function <ulink url="&gtk-menu-bar-new;">
     <code>gtk-menu-bar-new</code></ulink> or the call <code>(make-instance 'gtk-menu-bar)</code>. The
     menubar itself should be added to its parent container with an appropriate packing function.  Typically
     the menubar is put at the top of the content area just below the top-level windows's title bar, so the
     usual sequence is
    </para>
    <programlisting>
(let ((vbox (gtk-box-new :vertical 0)))
  (let ((menu-bar (gtk-menu-bar-new)))
    (gtk-container-add vbox menu-bar))
  (gtk-container-add window vbox)
  ... )
    </programlisting>
    <para>
     For each menu in the menubar, a separate menu item is needed.  Regular menu items can be created with
     the functions <ulink url="&gtk-menu-item-new;"><code>gtk-menu-item-new</code></ulink>,
     <ulink url="&gtk-menu-item-new-with-label;"><code>gtk-menu-item-new-with-label</code></ulink>,
     <ulink url="&gtk-menu-item-new-with-mnemonic;"><code>gtk-menu-item-new-with-mnemonic</code></ulink>, or
     with the appropriate calls of the function <code>make-instance</code>.
    </para>
    <para>
     The first of these creates a menu item with no label; later the generic function
     <ulink url="&gtk-menu-item-label;"><code>gtk-menu-item-label</code></ulink> can be used to create a
     label for it.  The second and third functions create menu items with either a plain label or with a
     label and a mnemonic, just like is done with buttons.  There are four subclasses of menu items, among
     which are image menu items, which can contain an image instead of or in addition to a label.
    </para>
    <para>
     There are three different ways to pack menu items into menubars and menus; they are all methods of the
     <ulink url="&gtk-menu-shell;"><code>gtk-menu-shell</code></ulink> base class:
     <ulink url="&gtk-menu-shell-append;"><code>gtk-menu-shell-append</code></ulink>,
     <ulink url="&gtk-menu-shell-prepend;"><code>gtk-menu-shell-prepend</code></ulink>, and
     <ulink url="&gtk-menu-shell-insert;"><code>gtk-menu-shell-insert</code></ulink>.
    </para>
    <para>
     The second argument in all three is the menu item to be put into the container. The differences are
     probably obvious.  The append method adds the menu item to the end of the list of those already in the
     menu shell, whereas the prepend method inserts it before all of the items already in it.  The insert
     method takes an integer position as the third argument, which is the position in the item list where
     child is added. Positions are numbered from 0 to (n-1).  If an item is put into position k, then all
     items currently in the list at positions k through (n-1) are shifted downward in the list to make room
     for the new item.
    </para>
    <para>
     The following code fragment creates a few labeled menu items, and packs them into the menubar in
     left-to-right order:
    </para>
    <programlisting>
(let ((file-item (gtk-menu-item-new-with-label "File"))
      (view-item (gtk-menu-item-new-with-label "View"))
      (tools-item (gtk-menu-item-new-with-label "Tools"))
      (help-item (gtk-menu-item-new-with-label "Help")))
  (gtk-menu-shell-append menu-bar file-item)
  (gtk-menu-shell-append menu-bar view-item)
  (gtk-menu-shell-append menu-bar tools-item)
  (gtk-menu-shell-append menu-bar help-item)
  ... )
    </programlisting>
    <para>
     The next step is to create the menus that will be dropped down when these menu items are activated.
     Menus are created with the function @xurl{gtk-menu-new}.
    </para>
    <para>
     For the above menu items, four menus are created and attached to the menu items with the generic
     function <ulink url="&gtk-menu-item-submenu;"><code>gtk-menu-item-submenu</code></ulink>:
    </para>
    <programlisting>
(let ((file-menu (gtk-menu-new))
      (view-menu (gtk-menu-new))
      (tools-menu (gtk-menu-new))
      (help-menu (gtk-menu-new)))
  (setf (gtk-menu-item-submenu file-item) file-menu)
  (setf (gtk-menu-item-submenu view-item) view-menu)
  (setf (gtk-menu-item-submenu tools-item) tools-menu)
  (setf (gtk-menu-item-submenu help-item) help-menu)
  ... )
    </programlisting>
    <para>
     The next step is to create the menu items to populate each of the menus, and add them to these menus.
     In the example, the "File" menu will have an "Open" item, a "Close" item, and an "Exit" item.  Between
     the "Close" item and the "Exit" item a separator item is added.  Separators are members of the
     <ulink url="&gtk-separator-menu-item;"><code>gtk-separator-menu-item</code></ulink> class and are
     created with the function <ulink url="&gtk-separator-menu-item-new;">
     <code>gtk-separator-menu-item-new</code></ulink> or the call
     <code>(make-instance 'gtk-separator)</code>.
    </para>
    <para>
     The "File" menus's items will be simple labeled items.  The code to create them and pack them is:
    </para>
    <programlisting>
 (let ((open-item (gtk-menu-item-new-with-label "Open"))
       (close-item (gtk-menu-item-new-with-label "Close"))
       (exit-item (gtk-menu-item-new-with-label "Exit")))
   (gtk-menu-shell-append file-menu open-item)
   (gtk-menu-shell-append file-menu close-item)
   (gtk-menu-shell-append file-menu (gtk-separator-menu-item-new))
   (gtk-menu-shell-append file-menu exit-item)
   ... )
    </programlisting>
    <para>
     To create a menu that contains submenus does not involve anything other than descending a level in the
     menu hierarchy and repeating these steps.  To illustrate, a "Help" menu is designed so that it has two
     items, one of which is a menu item that, when activated, pops up a submenu.  The first two steps are
     to create the two menu items and pack the into the "Help" menu:
    </para>
    <programlisting>
(let ((query-item (gtk-menu-item-new-with-label "What's this?"))
      (about-help-item
        (gtk-menu-item-new-with-label "About this program")))
  (gtk-menu-shell-append help-menu query-item)
  (gtk-menu-shell-append help-menu (gtk-separator-menu-item-new))
  (gtk-menu-shell-append help-menu about-help-item)
  ... )
    </programlisting>
    <para>
     The next step is to create a submenu and attach it to the <code>about-help-item</code>:
    </para>
    <programlisting>
(let ((about-help-menu (gtk-menu-new)))
  (setf (gtk-menu-item-submenu about-help-item) about-help-menu)
  ... )
    </programlisting>
    <para>
     The last step is to create a submenu and attach it to the <code>about-help-menu</code>:
    </para>
    <programlisting>
(let ((about-tool-item (gtk-menu-item-new-with-label "About Tools"))
      (about-stuff-item
        (gtk-menu-item-new-with-label "About Other Stuff")))
  (gtk-menu-shell-append about-help-menu about-tool-item)
  (gtk-menu-shell-append about-help-menu about-stuff-item)
  ... )
    </programlisting>
    <para>
     The preceding steps create the menu items, but they are not yet connected to the "activate" signal.
     Menu items that have a submenu do not need to be connected to the "activate" signal; GTK+ arranges for
     that signal to open the submenu. But the others need to be connected.  For example, the "Exit" menu item
     is connected to a callback to quit the application with
    </para>
    <programlisting>
(g-signal-connect exit-item "activate"
                  (lambda (widget)
                    (declare (ignore widget))
                    (gtk-widget-destroy window))))
    </programlisting>
    <para>
     The following Lisp code shows a complete example for creating menus by hand. It includes all code
     snippets shown above. The output is shown in figure <link linkend="figure-menus-by-hand">
     Menus by hand</link>.
    </para>
    <example id="example-menus-by-hand">
     <title>Creating Menus by Hand</title>
     <programlisting>
(defun example-menus-by-hand ()
  (within-main-loop
    ;; We set the "gtk-shell-shows-menubar" property to NIL to display the
    ;; menubar by the application itself and not by the desktop environment.
    (setf (gtk-settings-gtk-shell-shows-menubar (gtk-settings-get-default))
          nil)
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 425
                                 :default-height 250
                                 :title "Example Menus by Hand"))
          ;; A vbox to put in a menu and a button
          (vbox (gtk-box-new :vertical 0)))
      ;; Create a menu bar and the menu items for the menu bar
      (let ((menu-bar (gtk-menu-bar-new))
            (file-item (gtk-menu-item-new-with-label "File"))
            (view-item (gtk-menu-item-new-with-label "View"))
            (tools-item (gtk-menu-item-new-with-label "Tools"))
            (help-item (gtk-menu-item-new-with-label "Help")))
        ;; Add the menu bar to the main container
        (gtk-container-add vbox menu-bar)
        ;; Add the menu items to the menu bar
        (gtk-menu-shell-append menu-bar file-item)
        (gtk-menu-shell-append menu-bar view-item)
        (gtk-menu-shell-append menu-bar tools-item)
        (gtk-menu-shell-append menu-bar help-item)
        ;; Create the menus for the menu items in the menu bar
        (let ((file-menu (gtk-menu-new))
              (view-menu (gtk-menu-new))
              (tools-menu (gtk-menu-new))
              (help-menu (gtk-menu-new)))
          ;; Attach the submenus to the items of the menu bar
          (setf (gtk-menu-item-submenu file-item) file-menu)
          (setf (gtk-menu-item-submenu view-item) view-menu)
          (setf (gtk-menu-item-submenu tools-item) tools-menu)
          (setf (gtk-menu-item-submenu help-item) help-menu)
          ;; Create items to put into the File menu
          (let ((open-item (gtk-menu-item-new-with-label "Open"))
                (close-item (gtk-menu-item-new-with-label "Close"))
                (exit-item (gtk-menu-item-new-with-label "Exit")))
            ;; Append the items to the File menu
            (gtk-menu-shell-append file-menu open-item)
            (gtk-menu-shell-append file-menu close-item)
            (gtk-menu-shell-append file-menu (gtk-separator-menu-item-new))
            (gtk-menu-shell-append file-menu exit-item)
            ;; Add a signal handler for exit-item
            (g-signal-connect exit-item "activate"
                              (lambda (widget)
                                (declare (ignore widget))
                                (gtk-widget-destroy window))))

          ;; The view and tools menus will be empty for now

          ;; Create items to put into the Help menu
          (let ((query-item (gtk-menu-item-new-with-label "What's this?"))
                (about-help-item (gtk-menu-item-new-with-label "Info")))
            ;; Append the items to the About Help Menu
            (gtk-menu-shell-append help-menu query-item)
            (gtk-menu-shell-append help-menu (gtk-separator-menu-item-new))
            (gtk-menu-shell-append help-menu about-help-item)
            ;; Create a submenu and items for about-help-item
            (let ((about-help-menu (gtk-menu-new))
                  (about-tool-item
                    (gtk-menu-item-new-with-label "About This"))
                  (about-more-item
                    (gtk-menu-item-new-with-label "About That")))
              ;; Attach the submenu to the about-help-item
              (setf (gtk-menu-item-submenu about-help-item) about-help-menu)
              ;; Append the items to the about-help-menu
              (gtk-menu-shell-append about-help-menu about-tool-item)
              (gtk-menu-shell-append about-help-menu about-more-item)))))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>

   <section id="Pop-Up_Menus_for_Widgets">
    <sectioninfo>
     <itermset>
      <indexterm zone="Pop-Up_Menus_for_Widgets">
       <primary>menu-popup, gtk-menu-popup</primary>
      </indexterm>
     </itermset>
    </sectioninfo>
    <title>Pop-Up Menus for Widgets</title>
    <figure id="figure-menu-popup">
     <title>Creating a Pop-Up Menu</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/menu-popup.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     The same techniques for creating menus rooted in a menubar applies to the creation of pop-up menus for
     other widgets.  For example, to create a button, which when the mouse button is pressed on it, would pop
     up a menu instead of taking some action, first the menu is created using the instructions above. Then a
     mouse button press event signal is connected to a callback that popped up the menu, using the function
     &g-signal-connect;.  To illustrate, a small pop-up
     menu is created and two menu items are packed into it.
    </para>
    <programlisting>
(let ((popup-menu (gtk-menu-new))
      (big-item (gtk-menu-item-new-with-label "Larger"))
      (small-item (gtk-menu-item-new-with-label "Smaller")))
  (gtk-menu-shell-append popup-menu big-item)
  (gtk-menu-shell-append popup-menu small-item)
  ... )
    </programlisting>
    <para>
     Next a callback is connected to the "button-press-event" signal.  The callback will be responsible for
     popping up the menu with the function <ulink url="&gtk-menu-popup;"><code>gtk-menu-popup</code></ulink>.
     This function displays a menu and makes it available for selection.  It exists precisely for the purpose
     of displaying context sensitive menus.
    </para>
    <para>
     The first argument of the function is the menu to pop-up.  All other arguments are keyword arguments
     with the keywords <code>:parent-menu-shell</code>, <code>:parent-menu-item</code>,
     <code>:position-func</code>, <code>:button</code>, and <code>:activate-time</code>.  For normal use the
     default values for most of the arguments can be accepted.
    </para>
    <para>
     The <code>:button</code> parameter should be the mouse button pressed to initiate the menu popup.  If
     the menu popup was initiated by something other than a mouse press, such as a mouse button release or a
     key-press, button should be 0.
    </para>
    <para>
     The API documentation states that the <code>:activate-time</code> parameter is used to conflict-resolve
     initiation of concurrent requests for mouse/keyboard grab requests.  To function properly, this needs to
     be the time stamp of the user event that caused the initiation of the popup.
    </para>
    <para>
     Putting this together, the callback should be:
    </para>
    <programlisting>
(g-signal-connect button "button-press-event"
   (lambda (widget event)
     (declare (ignore widget))
     (gtk-menu-popup popup-menu
                     :button (gdk-event-button-button event)
                     :activate-time (gdk-event-button-time event))
     t))
    </programlisting>
    <para>
     The following code shows a complete example for creating a pop-up menu. It includes the code shown
     above.  The output is shown in figure <link linkend="figure-menu-popup">Menu Popup</link>.
    </para>
    <example id="example-menu-popup">
     <title>Creating Pop-Up Menus</title>
     <programlisting>
(defun example-menu-popup ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 150
                                 :title "Example Popup Menu"))
          (button (gtk-button-new-with-label "Click me")))
      ;; Create pop-up menu for button
      (let ((popup-menu (gtk-menu-new))
            (big-item (gtk-menu-item-new-with-label "Larger"))
            (small-item (gtk-menu-item-new-with-label "Smaller")))
        (gtk-menu-shell-append popup-menu big-item)
        (gtk-menu-shell-append popup-menu small-item)
        (gtk-widget-show-all popup-menu)
        ;; Signal handler to pop up the menu
        (g-signal-connect button "button-press-event"
           (lambda (widget event)
             (gtk-menu-popup popup-menu
                             :button (gdk-event-button-button event)
                             :activate-time (gdk-event-button-time event))
             t)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window button)
      (gtk-widget-show-all window))))
     </programlisting>
    </example>
   </section>
  </section>

  <section id="Toolbars">
   <title>Toolbars</title>
   <figure id="figure-toolbar-by-hand">
    <title>Creating a Toolbar</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/toolbar-by-hand.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Toolbars provide quick access to commonly used actions.  They are containers that should be populated
    with instances of the <ulink url="&gtk-tool-item;"><code>gtk-tool-item</code></ulink> class. Usually you
    will insert toolbar buttons into a toolbar.  Toolbar buttons belong to the
    <ulink url="&gtk-tool-button;"><code>gtk-tool-button</code></ulink> class, which is a sub class of
    <ulink url="&gtk-tool-item;"><code>gtk-tool-item</code></ulink>.  There are also two subclasses of the
    tool button class: <ulink url="&gtk-menu-tool-button;"><code>gtk-menu-tool-button</code></ulink> and
    <ulink url="&gtk-toggle-tool-button;"><code>gtk-toggle-tool-button</code></ulink>, which has a subclass
    &gtk-radio-tool-button;.
   </para>
   <para>
    A toolbar is created with only a single function <ulink url="&gtk-toolbar-new;">
    <code>gtk-toolbar-new</code></ulink>.  Once it is created, tool items can be inserted into it, using the
    function <ulink url="&gtk-toolbar-insert;"><code>gtk-toolbar-insert</code></ulink>.
   </para>
   <para>
    This inserts the tool item at position <code>pos</code>.  If <code>pos</code> is 0 the item is prepended
    to the start of the toolbar. If <code>pos</code> is negative, the item is appended to the end of the
    toolbar.  Therefore, if items are inserted successively into a toolbar passing -1 as <code>pos</code>,
    they will appear in the toolbar in left to right order.
   </para>
   <para>
    Although tool items can be created with the function <ulink url="&gtk-tool-item-new;">
    <code>gtk-tool-item-new</code></ulink>; we will have little use for this function, as we will be putting
    only buttons and separators into our toolbars.  Each of these has its own specialized constructors.  To
    create a toolbar button, you can use any of two different methods: <ulink url="&gtk-tool-button-new;">
    <code>gtk-tool-button-new</code></ulink> or <ulink url="&gtk-tool-button-new-from-stock;">
    <code>gtk-tool-button-new-from-stock</code></ulink>.
   </para>
   <para>
    The first method requires that you supply a custom icon and label; the second lets you pick a stock ID.
    You can use any stock item from the documentation. As we have not yet covered how to create icons, we
    will stay with the second method in the examples that follow.  The following code fragment creates a
    toolbar and a few toolbar buttons using stock items and puts them into a toolbar.
   </para>
   <programlisting>
(let ((toolbar (gtk-toolbar-new))
      (new-button (gtk-tool-button-new-from-stock "gtk-new"))
      (open-button (gtk-tool-button-new-from-stock "gtk-open"))
      (save-button (gtk-tool-button-new-from-stock "gtk-save"))
      (quit-button (gtk-tool-button-new-from-stock "gtk-quit"))
      (separator (make-instance 'gtk-separator-tool-item
                                :draw nil)))
  (gtk-toolbar-insert toolbar new-button -1)
  (gtk-toolbar-insert toolbar open-button -1)
  (gtk-toolbar-insert toolbar save-button -1)
  (gtk-toolbar-insert toolbar separator -1)
  (gtk-toolbar-insert toolbar quit-button -1)
  ... )
   </programlisting>
   <para>
    You can create separator items using the function <ulink url="&gtk-separator-tool-item-new;">
    <code>gtk-separator-tool-item-new</code></ulink>.  This creates a vertical separator in horizontal
    toolbar.  If for some reason you want the buttons to the right of the separator to be grouped at the far
    end of the toolbar, you can use the separator like a "spring" to push them to that end by setting its
    "expand" property to <emphasis>true</emphasis> and its "draw" property to <code>nil</code>, using the
    sequence
   </para>
   <programlisting>
(let (...
      (separator (gtk-separator-tool-item-new))
      ...)
  (setf (gtk-separator-tool-item-draw separator) nil)
  (setf (gtk-tool-item-expand separator) t)
  ... )
   </programlisting>
   <para>
    The "expand" property is inherited from <ulink url="&gtk-tool-item;"><code>gtk-tool-item</code></ulink>  
    whereas the "draw" property is specific to the separator.  Because "draw" is a property of the
    <ulink url="&gtk-separator-tool-item;"><code>gtk-separator-tool-item</code></ulink> class, we can save
    one function call, when using the function <code>make-instance</code> to create a
    <ulink url="&gtk-separator-tool-item;"><code>gtk-separator-tool-item</code></ulink> widget.
   </para>
   <programlisting>
(let (...
      (separator (make-instance 'gtk-separator-tool-item
                                :draw nil))
      ...)
  (setf (gtk-tool-item-expand separator) t)
  ... )
   </programlisting>
   <para>
    Toolbar buttons are buttons, not items, and therefore they emit a "clicked" signal.  To respond to button
    clicks, connect a callback to the button as if it were an ordinary button, such as
   </para>
   <programlisting>
(g-signal-connect quit-button "clicked"
                  (lambda (widget)
                    (declare (ignore widget))
                    (gtk-widget-destroy window)))
   </programlisting>
   <para>
    A complete program showing how to create a simple toolbar using this manual method is shown in the
    following example. The output is shown in figure <link linkend="figure-toolbar-by-hand">
    Toolbar by hand</link>.
   </para>
   <example id="example-toolbar-by-hand">
    <title>Creating a Toolbar</title>
    <programlisting>
(defun example-toolbar-by-hand ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :default-width 250
                                 :default-height 150
                                 :title "Example Toolbar"))
          ;; A vbox to put a menu and a button in
          (vbox (gtk-box-new :vertical 0)))
      (let ((toolbar (gtk-toolbar-new))
            (new-button (gtk-tool-button-new-from-stock "gtk-new"))
            (open-button (gtk-tool-button-new-from-stock "gtk-open"))
            (save-button (gtk-tool-button-new-from-stock "gtk-save"))
            (quit-button (gtk-tool-button-new-from-stock "gtk-quit"))
            (separator (make-instance 'gtk-separator-tool-item
                                      :draw nil)))
        (gtk-toolbar-insert toolbar new-button -1)
        (gtk-toolbar-insert toolbar open-button -1)
        (gtk-toolbar-insert toolbar save-button -1)
        (gtk-toolbar-insert toolbar separator -1)
        (gtk-toolbar-insert toolbar quit-button -1)
        (setf (gtk-tool-item-expand separator) t)
        (gtk-box-pack-start vbox toolbar :fill nil :expand nil :padding 3)
        ;; Connect a signal handler to the quit button
        (g-signal-connect quit-button "clicked"
                          (lambda (widget)
                            (declare (ignore widget))
                            (gtk-widget-destroy window))))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window vbox)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>

  <section id="GtkUIManager">
   <title>GtkUIManager</title>
   <para>
    A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> is an object that can dynamically
    construct a user interface consisting of menus and toolbars from a UI description.  A UI description is a
    specification of what menu and toolbar widgets should be present in an application and is described in an
    XML format. A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> makes it possible to
    change menus and toolbars dynamically using what is called UI merging.
   </para>

   <section id="Actions">
    <title>Actions</title>
    <para>
     The principal objects manipulated by a <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink>
     are actions, which are instances of the <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class.
     Actions represent operations that the user can perform.  Associated with an action are
    </para>
    <itemizedlist>
     <listitem>a callback function</listitem>
     <listitem>its name</listitem>
     <listitem>a label</listitem>
     <listitem>an accelerator</listitem>
     <listitem>a flag indicating whether the label is a stock ID</listitem>
     <listitem>a tooltip</listitem>
     <listitem>a toolbar label</listitem>
     <listitem>a flag indicating whether it is sensitive</listitem>
     <listitem>a flag indicating whether it is visible</listitem>
    </itemizedlist>
    <para>
     The callback function is the function that is executed when the action is activated.  The action name is
     how it is referred to, not what appears in a menu item or toolbar button, which is its label.  Actions
     can have associated keyboard accelerators and tooltips.  Their visibility and sensitivity can be
     controlled as well.  The idea is that you can create actions that the <ulink url="&gtk-ui-manager;">
     <code>gtk-ui-manager</code></ulink> can bind to proxies such as menu items and toolbar buttons.
    </para>
    <para>
     The <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class has methods to create icons, menu
     items and toolbar items representing itself, as well as get and set methods for accessing and changing
     its properties.
    </para>
    <para>
     The <ulink url="&gtk-action;"><code>gtk-action</code></ulink> class also has two subclasses:
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> and
     <ulink url="&gtk-recent-action;"><code>gtk-recent-action</code></ulink>.  The
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> class has a
     &gtk-radio-action; subclass.  These correspond to
     toggle buttons and radio buttons respectively.
    </para>
   </section>

   <section id="UI_Definitions">
    <title>UI Definitions</title>
    <para>
     You can specify the set user interface action elements in your application with an XML description
     called a UI definition.  A UI definition is a textual description that represents the actions and the
     widgets that will be associated with them.  It must b e bracketed by the pair of tags
     <code>&#x3c;ui></code> and <code>&#x3c;/ui></code>.  Within these tags you describe your user interface
     in a hierarchical way, by defining menubars, which would contain menus, which in turn contain menus and
     menu items, toolbars, which would contain tool items, and pop-up menus, which can contain menus and menu
     items.  The set of tags that can be used in these UI definitions, with their descriptions and
     attributes, is
    </para>
    <table frame='all'>
     <tgroup cols='4' align='left' colsep='0' rowsep='0'>
      <thead>
       <row>
        <entry>Tag</entry>
        <entry>Description</entry>
        <entry>Attributes</entry>
        <entry>Closing Tag</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry valign="top"><code>&#x3c;menubar></code></entry>
        <entry valign="top"><code>gtk-menu-bar</code></entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;toolbar></code></entry>
        <entry valign="top"><code>gtk-toolbar</code></entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;popup></code></entry>
        <entry valign="top">toplevel <code>gtk-menu</code></entry>
        <entry valign="top">name, action, accelerators</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;menu></code></entry>
        <entry valign="top"><code>gtk-menu</code> attached to a menu item</entry>
        <entry valign="top">name, action, position</entry>
        <entry valign="top">yes</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;menuitem></code></entry>
        <entry valign="top"><code>gtk-menu-item</code> subclass, the exact type depends on the action</entry>
        <entry valign="top">name, action, position, always-show-image</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;toolitem></code></entry>
        <entry valign="top"><code>gtk-tool-item</code> subclass, the exact type depends on the action</entry>
        <entry valign="top">name, action, position</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;separator></code></entry>
        <entry valign="top">
         <code>gtk-separator-menu-item</code> or <code>gtk-separator-tool-item</code>
        </entry>
        <entry valign="top">name, action, expand</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;accelerator></code></entry>
        <entry valign="top">keyboard accelerator</entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">no</entry>
       </row>
       <row>
        <entry valign="top"><code>&#x3c;placeholder></code></entry>
        <entry valign="top">placeholder for dynamically adding an item</entry>
        <entry valign="top">name, action</entry>
        <entry valign="top">yes</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <bridgehead renderas='sect3'>Example</bridgehead>
    <para>
     The following example shows a UI definition of a menubar and its submenus.
    </para>
    <programlisting>
&#x3c;ui>
  &#x3c;menubar name='MainMenu'>
    &#x3c;menu name='File' action='FileMenu'>
      &#x3c;menuitem name='Open'action='Open' always-show-image='true'/>
      &#x3c;menuitem name='Close' action='Close' always-show-image='true'/>
      &#x3c;separator/>
      &#x3c;menuitem name='Exit' action='Exit'/>
    &#x3c;/menu>
    &#x3c;menu action='ViewMenu'>
      &#x3c;menuitem name='ZoomIn' action='ZoomIn'/>
      &#x3c;menuitem name='ZoomOut' action='ZoomOut'/>
      &#x3c;separator/>
      &#x3c;menuitem name='FullScreen' action='FullScreen'/>
      &#x3c;separator/>
      &#x3c;menuitem name='JustifyLeft' action='JustifyLeft'/>
      &#x3c;menuitem name='JustifyCenter' action='JustifyCenter'/>
      &#x3c;menuitem name='JustifyRight' action='JustifyRight'/>
      &#x3c;menu action='IndentMenu'>
        &#x3c;menuitem action='Indent'/>
        &#x3c;menuitem action='Unindent'/>
      &#x3c;/menu>
    &#x3c;/menu>
  &#x3c;/menubar>
&#x3c;/ui>
    </programlisting>

    <bridgehead renderas='sect3'>Notes</bridgehead>
    <itemizedlist>
     <listitem>
      Some tags must have a closing tag and some do not. Those with no closing tag are
      <code>&#x3c;menuitem></code>, <code>&#x3c;toolitem></code>, <code>&#x3c;separator></code>, and
      <code>&#x3c;accelerator></code>. A tag that does not have a closing tag must have a forward slash
      preceding its right bracket: <code>/></code>.  All other tags can have content.
     </listitem>
     <listitem>
      All attribute values are plain text strings.
     </listitem>
     <listitem>
      All UI elements have a name and action attribute. The name is optional; if a name is not specified, the
      action is used as its own name. If for some reason, neither the name nor the action attribute are
      specified, the name of the element is used when referring to it. The name and action attributes must
      not contain "/" characters after parsing, nor double quotes.
     </listitem>
     <listitem>
      Menus, menu items, and toolitems have a position attribute with two possible values: "top" and
      "bottom". If this attribute is missing, its default value of "bottom" is used. This attribute
      determines where the element is placed relative to its siblings. If position="top" then when it is
      added to the parent container, it will be placed before its siblings, meaning to the left in a
      horizontal container or above the siblings in a vertical container. If it is "bottom" then it will be
      placed to the right of the siblings or below them in horizontal and vertical containers respectively.
     </listitem>
     <listitem>
      The elements are added to the UI interface in the order in which they appear in the XML string. In the
      above example, the JustifyLeft action precedes the JustifyCenter action, so the former will appear
      above the latter. If however, the UI was defined as follows:
      <programlisting>
&#x3c;menuitem name='JustifyLeft' action='JustifyLeft' position='top'/>
&#x3c;menuitem name='JustifyCenter action='JustifyCenter' position='top'/>
&#x3c;menuitem name='JustifyRight' action='JustifyRight' position='top'/>
      </programlisting> 
      then they would appear in the order
      <programlisting>
JustifyRight
JustifyCenter
JustifyLeft
      </programlisting>
      because each time the element is inserted, the position='top' attribute forces it to be above its
      siblings. The 'top' attribute converts the packing into a stack push operation in effect.
     </listitem>
     <listitem>
      Menu items have a "always-show-image" attribute with two possible values: "true" and "false". If this
      attribute is true, then menu item icons will always be visible, overriding any user settings in the
      desktop environment.
     </listitem>
     <listitem>
      Separators can have an expand attribute, with the value "true" or "false". If it is set to "true" then
      the separator will expand to take up extra space in the parent container and become invisible.
      Otherwise it is drawn as a thin line, depending on the user's theme.
     </listitem>
     <listitem>
      Submenus are created in a different way using the XML than they are when constructing these
      programmatically. Remember that submenus are attached to menu items, which are contained in the parent
      menu. Here, a <code>&#x3c;menu></code> element can be a direct child of a parent
      <code>&#x3c;menu></code> element. In the example above, the menu whose action is 'IndentMenu' is a
      child of the 'ViewMenu'.
     </listitem>
     <listitem>
      Placeholders are merged into their parent containers invisibly. If a placeholder has child elements X,
      Y, and Z, these will be at the same level of the tree as the placeholder itself. An example later will
      illustrate the utility of this feature.
     </listitem>
     <listitem>
      Finally, observe the hierarchy implicit in the UI definition. As a matter of style, you should indent
      these using standard rules of indentation, to make them easier to read.
     </listitem>
    </itemizedlist>
    <para>
     We can create a toolbar definition in a similar way:
    </para>
    <programlisting>
&#x3c;ui>
  &#x3c;toolbar name='ToolBar' action="ToolBarAction">
    &#x3c;placeholder name="ExtraToolItems">
      &#x3c;separator/>
      &#x3c;toolitem name="ZoomIn"action="ZoomIn"/>
      &#x3c;toolitem name="ZoomOut"action="ZoomOut"/>
      &#x3c;separator/>
      &#x3c;toolitem name='FullScreen' action='FullScreen'/>
      &#x3c;separator/>
      &#x3c;toolitem name='JustifyLeft' action='JustifyLeft'/>
      &#x3c;toolitem name='JustifyCenter' action='JustifyCenter'/>
      &#x3c;toolitem name='JustifyRight' action='JustifyRight'/>
    &#x3c;/placeholder>
  &#x3c;/toolbar>
&#x3c;/ui>
    </programlisting>
    <para>
     Notice that the tool items have the same action names as some of the menu items. This is how you can
     create multiple proxies for the same action. When the <ulink url="&gtk-ui-manager;">
     <code>gtk-ui-manager</code></ulink> loads these descriptions, and you take the appropriate steps in your
     program, they will be connected to the same callback functions.
    </para>
    <para>
     Notice also that there is a placeholder in the toolbar defined above. We can use that placeholder to
     dynamically add more tool items in that position. It does not occupy space in the toolbar widget; it
     just marks a position to be accessed, so there is no downside to putting these placeholders into the UI
     definition.
    </para>
   </section>

   <section id="Actions_Groups">
    <title>Actions Groups</title>
    <para>
     Actions are organized into action groups. An action group is essentially a map from names to
     <ulink url="&gtk-action;"><code>gtk-action</code></ulink> objects. Action groups are the easiest means
     for adding actions to a UI manager object.
    </para>
    <para>
     In general, related actions should be placed into a single group. More precisely, since the UI manager
     can add and remove actions as groups, if the interface is supposed to change dynamically, then all
     actions that should be available in the same state of the application should be in the same group. It
     is typical that multiple action groups are defined for a particular user interface. Most nontrivial
     applications will make use of multiple groups. For example, in an application that can play media files,
     when a media file is open, the playback actions (play, pause, rewind, etc.) would be in a group that
     could be added and removed as needed.
    </para>
   </section>

   <section id="Creating_the_UI">
    <title>Creating the UI</title>
    <para>
     The basic steps in creating the UI are to
    </para>
    <orderedlist>
     <listitem>
      Define the UI in an XML format, either in a separate file or in a constant string within the source
      code.
     </listitem>
     <listitem>Create the actions and action groups.</listitem>
     <listitem>Create a UI manager.</listitem>
     <listitem>Add the action groups to the UI manager.</listitem>
     <listitem>
      Extract the accelerators from the UI manager and add them to the top-level window.
     </listitem>
     <listitem>Add the UI definition to the UI manager from the file or string.</listitem>
     <listitem>
      Get the menubar and toolbar widgets from the UI manager and pack them into the window.
     </listitem>
     <listitem>Create the callbacks referenced in the action objects created in step 2.</listitem>
    </orderedlist>
    <para>
     We will next describe how to program each of steps 2 through 7.
    </para>

    <bridgehead>Creating Actions and Action Groups</bridgehead>
    <para>
     The function to create an action group is <ulink url="&gtk-action-group-new;">
     <code>gtk-action-group-new</code></ulink>. The name argument can be used by various methods for
     accessing this particular action group. It should reflect what this particular group's purpose or common
     feature is. Actions are added to an action group in one of two ways.  You can add them one at a time
     with the function <ulink url="&gtk-action-group-add-action;">
     <code>gtk-action-group-add-action</code></ulink>, or as a list of related actions with the function
     <ulink url="&gtk-action-group-add-actions;"><code>gtk-action-group-add-actions</code></ulink>.
    </para>
    <para>
     The problem with the first method is that it is tedious to add actions one by one, and that this method
     does not provide a means to add the accelerators for the actions without additional steps. Even if there
     is just a single action in the group, it is more convenient to use the second function. To use the
     function <ulink url="&gtk-action-group-add-actions;"><code>gtk-action-group-add-actions</code></ulink>,
     you first have to create a list of action entries, which looks like the following example:
    </para>
    <programlisting>
(list
  (list &#x3c;name> &#x3c;stock-id> &#x3c;label> &#x3c;accelerator> &#x3c;tooltip> &#x3c;callback>)
  ... )
    </programlisting>
    <para>
     The members of the list have the following meanings:
    </para>
    <variablelist>
     <varlistentry>
      <term>name</term>
      <listitem>The name of the action.</listitem>
     </varlistentry>
     <varlistentry>
      <term>stock-id</term>
      <listitem>The stock ID for the action, or the name of an icon from the icon theme.</listitem>
     </varlistentry>
     <varlistentry>
      <term>label</term>
      <listitem>
       The label for the action. This field should typically be marked for translation, see the function
       <ulink url="&gtk-action-group-set-translation-domain;">
       <code>gtk-action-group-set-translation-domain</code></ulink>. If label is <code>nil</code>, the label
       of the stock item with ID <code>stock-id</code> is used.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>accelerator</term>
      <listitem>
       The accelerator for the action, in the format understood by the function
       <ulink url="&gtk-accelerator-parse;"><code>gtk-accelerator-parse</code></ulink>.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>tooltip</term>
      <listitem>
       The tooltip for the action. This field should typically be marked for translation, see the function
       <ulink url="&gtk-action-group-set-translation-domain;">
       <code>gtk-action-group-set-translation-domain</code></ulink>.
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>callback</term>
      <listitem>
       The function to call when the action is activated.
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     The <code>name</code> must match the name of the action to which it corresponds in the UI  definition.
     The <code>stock-id</code> can be <code>nil</code>, as can the <code>label</code>. The
     <code>accelerator</code> syntax is very flexible. You can specify control keys, function keys and even
     ordinary characters, for example, using "&#x3c;Control>a", "Ctrl>a","&#x3c;ctrl>a", or
     "&#x3c;Shift>&#x3c;Alt>F1", "&#x3c;Release>z", or "minus", to name a few. If you use a stock item, it is
     not necessary to supply an accelerator, unless you want to override the default one. The
     <code>tooltip</code> is a string that will appear when the cursor hovers over the proxy for this action
     entry.
    </para>
    <para>
     Below is an example of a declaration of a small list of action entries.
    </para>
    <programlisting>
(defvar file-entries
        (list (list "FileMenu"
                    nil
                    "_File")
              (list "Open"
                    "gtk-open"
                    "_Open"
                    "&#x3c;control>O"
                    "Open a file"
                    #'on-open-file)
              (list "Close"
                    "gtk-close"
                    "_Close"
                    "&#x3c;control>W"
                    "Close a file" #'on-close-file)
              (list "Exit"
                    "gtk-quit"
                    "E_xit" "&#x3c;control>Q"
                    "Exit the program"
                    #'(lambda (widget)
                        (declare (ignore widget))
                        (gtk-widget-destroy toplevel-window)))))
    </programlisting>
    <para>
     Notice that the FileMenu action does not have a tooltip nor a callback. The Open, Close, and Exit
     actions have both a mnemonic label and an accelerator. Having defined this list, it can be added to a
     group as follows:
    </para>
    <programlisting>
(let ((action-group (gtk-action-group-new "common-actions")))
  (gtk-action-group-add-actions action-group file-entries)
  ... )
    </programlisting>
    <para>
     Multiple action entry lists can be added to a single action group. In fact, you probably will need to do
     this, because toggle actions and radio actions must be defined differently. A
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> entry contains all of the
     members of a <ulink url="&gtk-action;"><code>gtk-action</code></ulink> entry, as well as an additional
     boolean flag <code>is-active</code>.
    </para>
    <para>
     The <code>is-active</code> flag indicates whether or not the action is active or inactive. To add toggle
     action entries to an action group you need to use the function
     <ulink url="&gtk-action-group-add-toggle-actions;">
     <code>gtk-action-group-add-toggle-actions</code></ulink> designed for that purpose.
    </para>
    <para>
     The function differs from <ulink url="&gtk-action-group-add-actions;">
     <code>gtk-action-group-add-actions</code></ulink> only in that it expects a list of
     <ulink url="&gtk-toggle-action;"><code>gtk-toggle-action</code></ulink> entries. To illustrate, we could
     define a list with a single toggle action entry:
    </para>
    <programlisting>
(defvar toggle-entries
        (list (list "FullScreen"
                    "gtk-fullscreen"
                    "_FullScreen"
                    "F11"
                    "Switch between full screen and windowed mode"
                    #'on-full-screen
                    nil)))
    </programlisting>
    <para>
     and add it to the same group as above with
    </para>
    <programlisting>
(gtk-action-group-add-toggle-actions common-actions toggle-entries)
    </programlisting>
    <para>
     GTK+ defines radio action entries separately. Usually you use radio buttons when there are three or more
     alternatives. If there are just two, a toggle is the cleaner interface element. Because radio actions
     can have more than two values, the list's last element is an integer instead of a boolean.
    </para>
    <para>
     Unlike ordinary actions and toggle actions, which can have different callbacks for each action, radio
     action entries do not specify a callback function. Furthermore, the last member of this structure is the
     value that that particular radio action has. If for example, there are three radio actions for how text
     is to be aligned, left, right, or centered, then one would have the value 0, the next, 1, and the third,
     2. An example of a list of radio action entries is below.
    </para>
    <programlisting>
(defvar radio-entries
        (list (list "JustifyLeft"
                    "gtk-justify-left"
                    "_Left"
                    nil
                    "Left justify text"
                    0)
              (list "JustifyCenter"
                    "gtk-justify-center"
                    "_Center"
                    nil
                    "Center the text"
                    1)
              (list "JustifyRight"
                    "gtk-justify-right"
                    "_Right"
                    nil
                    "Right justify the text"
                    2)))
    </programlisting>
    <para>
     Because radio action entries do not have a callback function as a member, the function
     <ulink url="&gtk-action-group-add-radio-actions;">
     <code>gtk-action-group-add-radio-actions</code></ulink> to add radio actions to an action group
     specifies a single callback to be used for all of the actions in the array of radio actions being added.
     This is the callback that will be called in response to the "changed" signal.
    </para>
    <para>
     Also, this function has another parameter that specifies the value that should be active initially. It
     is either one of the values in the individual radio action entries, or -1 to indicate that none should
     be active to start. We could add the radio_entries action list to our group with the call
    </para>
    <programlisting>
(gtk-action-group-add-radio-actions action-group
                                    radio-entries
                                    0
                                    #'on-change)
    </programlisting>
    <para>
     specifying that the JustifyLeft action is the initial value.
    </para>

    <bridgehead>Creating the UIManager and Adding the Action Groups</bridgehead>
    <para>
     A <ulink url="&gtk-ui-manager;"><code>gtk-ui-manager</code></ulink> is created with the function
     <ulink url="&gtk-ui-manager-new;"><code>gtk-ui-manager-new</code></ulink>. This creates a UI manager
     object that can then be used for creating and managing the application's user interface. It is now ready
     to be populated with the action groups that you already defined. To insert an action group into the UI
     manager, use the function @xurl{gtk-ui-manager-insert-action-group}.
    </para>
    <para>
     The first argument is the object returned by the call to create the UI manager. The second is the group
     to be inserted. The <code>pos</code> argument specifies the position in the list of action groups
     managed by this UI manager. Action groups that are earlier in this list will be accessed before those
     that are later in this list. A consequence of this is that, if an action with the same name, e.g.
     "Open", is in two different groups, the entry in the group with smaller position will hide the one in
     the group with larger position. For example, if an "Open" action is in groups named
     <code>action-group1</code> and <code>action-group2</code>, and <code>action-group1</code> is inserted at
     position 1, and <code>action-group2</code> is at position 2, then the entry for the "Open" action in
     <code>action-group1</code> will be used by the UI manager when its proxy is activated. If it has a
     different callback or label or accelerator, these will be associated with this action, not the one in
     <code>action-group2</code>. You can use this feature if you need to change the semantics of a menu item
     or toolbar button, but not the menu item or button itself.
    </para>
    <para>
     While we are on the subject of inserting actions, we might as well look at how you can remove an action
     group, if you have need to do that dynamically. That function is
     <ulink url="&gtk-ui-manager-remove-action-group;">
     <code>gtk-ui-manager-remove-action-group</code></ulink>. This searches the list of action groups in the
     UI manager and deletes the one which is passed to it.
    </para>

    <bridgehead>Extracting Accelerators and adding them to the Top-Level Window</bridgehead>
    <para>
     Accelerators are key combinations that provide quick access to the actions in a window. They are usually
     associated with the top-level window so that key-presses while that window has focus can be handled by
     the top-level window's "key-press-event" handler, which can propagate it through the chain of widgets.
     The problem is that the accelerators are stored within the UI manager, not the top-level window, when
     you insert the action groups into it. The UI manager aggregates the accelerators into its private data
     as action groups are added to it. However it provides a method of extracting them. The set of
     accelerators can be extracted into a <ulink url="&gtk-accel-group;"><code>gtk-accel-group</code></ulink>
     object that can be added into a top-level window. The function that does this is
     <ulink url="&gtk-ui-manager-get-accel-group;"><code>gtk-ui-manager-get-accel-group</code></ulink>.
     The function that adds this group into a top-level window is <ulink url="&gtk-window-add-accel-group;">
     <code>gtk-window-add-accel-group</code></ulink>. The following code-snippet will extract the
     accelerators and add them to the top-level window:
    </para>
    <programlisting>
(let ((accel-group (gtk-ui-manager-get-accel-group ui-manager)))
  (gtk-window-add-accel-group window accel-group)
  ... )
    </programlisting>

    <bridgehead>Loading the UI Definition</bridgehead>
    <para>
     If the UI definition is in a separate file, it can be loaded using the function
     <ulink url="&gtk-ui-manager-add-ui-from-file;"><code>gtk-ui-manager-add-ui-from-file</code></ulink>. The
     first argument is the UI manager object, the second, a filename passed as a UTF-8 string. If this
     function is successful, it will return a positive integer called a merge-id. Merge-ids will be explained
     in the next section. If the function fails, for one reason or another, the return value will be zero.
     Therefore it is a good idea to check the return value of the function. The following code fragment tests
     both conditions and terminates the program with an error message if there is an error:
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-file ui-manager
                                                 "menu-1.xml")))
  (when (eql 0 merge-id)
    (error-message "Could not load UI Manager definition"))
  ... )
    </programlisting>
    <para>
     The function <code>error-message</code> displays a message dialog with a suitable message.
    </para>
    <para>
     An alternative to storing the UI definition in a file in the source code tree is to store the UI
     definition as a string within a source code file itself. If the UI definition is in a string, then it
     can be added with the function <ulink url="&gtk-ui-manager-add-ui-from-string;">
     <code>gtk-ui-manager-add-ui-from-string</code></ulink>.
    </para>
    <para>
     The buffer argument is the name of the string containing the UI definition. The return value is also
     either a positive integer on success, in which case it is a valid merge-id, or zero on failure. The
     following listing shows how to define a UI definition in a string.
    </para>
    <programlisting>
(defparameter ui-constant
  "&#x3c;ui>
     &#x3c;menubar name='MainMenu'>
       &#x3c;menu action='FileMenu'>
         &#x3c;placeholder name='FilePlace'/>
         &#x3c;separator/>
         &#x3c;menuitem action='Exit'/>"
       &#x3c;/menu>"
       &#x3c;menu action='ViewMenu'>"
         &#x3c;menuitem action='ZoomIn'/>"
         &#x3c;menuitem action='ZoomOut'/>"
         &#x3c;separator/>"
         &#x3c;menuitem action='FullScreen'/>"
         &#x3c;separator/>"
       &#x3c;/menu>"
     &#x3c;/menubar>"
   &#x3c;/ui>")
    </programlisting>
    <para>
     This would then be added to the UI manager with the fragment
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-string ui-manager 
                                                   ui-constant)))
  (when (eql 0 merge-id)
    (error-message "Could not load UI Manager definition"))
  ... )
    </programlisting>

    <bridgehead>Getting the Widgets</bridgehead>
    <para>
     The last step is to retrieve the widgets that the UI manager created when the UI definition was loaded
     into it, and pack those widgets into the window where you want them to be. This is where the names of
     the UI definition elements come into play. The UI manager can find a widget for you when you give it the
     absolute pathname of the element that you want to construct. The absolute pathname is a string starting
     with a forward slash '/', much like a file's absolute pathname, with a sequence of the ancestor elements
     in the XML tree of that element.
    </para>
    <para>
     Elements which do not have a name or action attribute in the XML (e.g. <code>&#x3c;popup></code>) can
     be addressed by their XML element name (e.g. "popup"). The root element ("/ui") can be omitted in the
     path.
    </para>
    <para>t
     As an example, the absolute pathname of the FileMenu in the UI definition above is "/MainMenu/FileMenu".
    </para>
    <para>
     The function <ulink url="&gtk-ui-manager-get-widget;"><code>gtk-ui-manager-get-widget</code></ulink>
     finds the widget that the UI manager constructed, whose name matches the pathname that you give it. If
     you give it the name of a menubar, you get a menubar widget with its entire subtree. If you give it the
     name of a menu, you get the menu item to which the menu is attached, not the menu.
    </para>
    <para>
     If our UI definition had a menubar and toolbar at the top level named "MainMenu" and "MainToolBar"
     respectively, we could get them from the UI manager using
    </para>
    <programlisting>
(let ((menubar (gtk-ui-manget-get-widget ui-manager "/MainMenu"))
      (toolbar (gtk-ui-manager-get-widget ui-manager "/MainToolBar")))
  ... )
    </programlisting>
    <para>
     We could then pack these into a &gtk-box; one below the other
     in our main window, and we would be finished, except of course for defining all of the required callback
     functions.
    </para>
    <para>
     <emphasis>Note.</emphasis> The widgets that are constructed by a UI manager are not tied to the
     life-cycle of that UI manager. It does acquire a reference to them, but when you add the widgets
     returned by this function to a container or if you explicitly ref them, they will survive the
     destruction of the UI manager. (Read the notes on memory management in GTK if you are unfamiliar with
     these concepts.)
    </para>
    <para>
     Lastly, you can tell the UI manager to create tear-off menus if you want, using the function
     <ulink url="&gtk-ui-manager-add-tearoffs;"><code>gtk-ui-manager-add-tearoffs</code></ulink>.
     By passing <emphasis>true</emphasis>, all menus (except popup menus) will have the tear-off property.
    </para>
   </section>

   <section id="UI_Merging">
    <title>UI Merging</title>
    <para>
     One of the most powerful features of the UI manager is its ability to dynamically change the menus and
     toolbars by overlaying or inserting menu items or toolbar items over others and removing them later.
     This feature is called UI merging. The ability to merge elements is based on the use of the pathnames
     to the UI elements defined in the UI definition, and merge-ids.
    </para>
    <para>
     A merge-id is an unsigned integer value that is associated with a particular UI definition inside the UI
     manager. The functions that add UI definitions into the UI manager, such as
     <ulink url="&gtk-ui-manager-add-ui-from-string;"><code>gtk-ui-manager-add-ui-from-string</code></ulink>
     and <ulink url="&gtk-ui-manager-add-ui-from-file;"><code>gtk-ui-manager-add-ui-from-file</code></ulink>,
     return a merge-id that can be used at a later time, for example, to remove that particular UI
     definition. The function that removes a UI definition is @xurl{gtk-ui-manager-remove-ui}.
    </para>
    <para>
     This is given the merge-id of the UI definition to be removed. For example, if I create a UI with the
     call
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-add-ui-from-string ui_manager
                                                   ui_toolbar)))
  ... )
    </programlisting>
    <para>
     and I later want to remove the toolbar from the window, I would call
    </para>
    <programlisting>
(gtk-ui-manager-remove-ui ui-manger merge-id)
    </programlisting>
    <para>
     In order to add an element such as a toolbar in one part of the code, and later remove it in a callback
     function, you would need to make the merge-id either a shared variable, or attach it as a property to a
     widget that the callback is passed.
    </para>
    <para>
     There is a third function <ulink url="&gtk-ui-manager-add-ui;">
     <code>gtk-ui-manager-add-ui</code></ulink> for adding a new element to the user interface. The
     parameters have the following meanings:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>self</code></term>
      <listitem>a <code>gtk-ui-manager</code></listitem>
     </varlistentry>
     <varlistentry>
      <term><code>merge-id</code></term>
      <listitem>the merge-id for the merged UI</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>path</code></term>
      <listitem>a path</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>name</code></term>
      <listitem>the name for the added UI element</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>action</code></term>
      <listitem>the name of the action to be proxied, or <code>nil</code> to add a separator</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>type</code></term>
      <listitem>the type of UI element to add</listitem>
     </varlistentry>
     <varlistentry>
      <term><code>top</code></term>
      <listitem>
       if <emphasis>true</emphasis>, the UI element is added before its siblings, otherwise it is added
       after its siblings.
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     This function can add a single element to the UI, such as a menu item, a toolbar item, a menu, or a
     menubar. It cannot add an entire UI definition such as the ones contained in the strings defined above.
     Furthermore, it cannot be used to insert an element in a place where such an element cannot be inserted.
     For example, you cannot insert a toolbar inside a menu, or a menu inside a menu, but you can insert a
     menu item in a menu, or a menu in a menubar.
    </para>
    <para>
     In order to use this function, you need a merge-id to give to it. It will assign associate the new UI
     element to this merge-id so that it can be removed at a later time. New merge-ids are created with the
     function <ulink url="&gtk-ui-manager-new-merge-id;"><code>gtk-ui-manager-new-merge-id</code></ulink>.
     The third parameter is the absolute path name to the position at which you want to add the new UI
     element. For example, if you want to insert a new menu item at the top of the File menu, the path would
     be "/MainMenu/FileMenu". The fourth parameter is a name that you want this item to have for future
     access and the fifth is the name for the action, which must exist already, that should be connected to
     this element.
    </para>
    <para>
     The type must be a member of the <ulink url="&gtk-ui-manager-item-type;">
     <code>gtk-ui-manager-item-type</code></ulink>, which has the following values
    </para>
    <programlisting>
:auto
:menubar
:menu
:toolbar
:placeholder
:popup
:menuitem
:toolitem
:separator
:accelerator
    </programlisting>
    <para>
     Their meanings should be self-explanatory, except for the first. You can use <code>:auto</code> as the
     type to let GTK decide the type of the element that can be inserted at the indicated path. Lastly, if
     you want the element to be above the element that is currently in that position, you set top to
     <emphasis>true</emphasis>, otherwise <code>nil</code>.
    </para>
    <para>
     As an example, suppose that I want to add a Print menu item in my File menu just below the Open menu
     item. I could use the following code fragment, assuming that I have already defined an action named
     Print:
    </para>
    <programlisting>
(let ((merge-id (gtk-ui-manager-new-merge-id ui-manager)))
  (gtk-ui-manager-add-ui ui-manager
                         merge-id
                         "/MainMenu/FileMenu/Open"
                         "Print"
                         "Print"
                         :menu-item
                         nil)
    ... )
    </programlisting>
    <para>
     This will insert the Print menu item into the proper position.
    </para>
    <para>
     Assuming that  your menu is to be changed dynamically, these steps will not be enough to make the menu
     elements appear dynamically. The UI manager does not handle the task of packing new toolbars or menubars
     into their places in the window. However, it does emit the "add-widget" signal for each generated
     menubar and toolbar. Your application can respond to this signal with a callback function that can pack
     the UI element into the appropriate position. Therefore, two additional steps are needed by a program
     that adds and removes menubars or toolbars:
    </para>
    <itemizedlist>
     <listitem>
      Create a callback function to pack these widgets into the parent container, and
     </listitem>
     <listitem>
      Connect the "add-widget" signal emitted by the UI manager to this callback.
     </listitem>
    </itemizedlist>
    <para>
     The callback for this signal has the prototype
    </para>
    <programlisting>
lambda (merge widget)
    </programlisting>
    <para>
     The first parameter is the UI manager emitting the signal, the second is the widget that has been added.
     For example
    </para>
    <programlisting>
(g-signal-connect ui-manager "add-widget"
   (lambda (merge widget)
     (declare (ignore merge))
     (gtk-box-pack-start menu-box widget :fill nil :expand nil)
     (gtk-widget-show widget)))
    </programlisting>
    <para>
     This will pack the menubar or toolbar after any other widgets in the parent, assuming that menu-box is
     a &gtk-box; of some kind that the menu or toolbar should be
     packed into. It must show the widget to realize it.
    </para>
   </section>
  </section>
 </chapter>

 <chapter id="Application_Suport">
  <title>Application Support</title>
  <section id="Application_Class">
   <sectioninfo>
    <itermset>
     <indexterm zone="Application_Class">
      <primary>GtkApplication</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application, gtk-application</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>GtkApplicationWindow</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application-window, gtk-application-window</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>GApplication</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application, g-application</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>action-group-activate-action, g-action-group-activate-action</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>GMenuModel</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>menu-model, g-menu-model</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>GtkBuilder</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>builder, gtk-builder</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>GActionMap</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>action-map, g-action-map</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application-app-menu, gtk-application-app-menu</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application-menubar, gtk-application-menubar</primary>
     </indexterm>
     <indexterm zone="Application_Class">
      <primary>application-inhibit, gtk-application-inhibit</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Application Class</title>
   <para>
    <ulink url="&gtk-application;"><code>gtk-application</code></ulink> is a class that handles many
    important aspects of a GTK+ application in a convenient fashion, without enforcing a one-size-fits-all
    application model.
   </para>
   <para>
    Currently, <ulink url="&gtk-application;"><code>gtk-application</code></ulink> handles GTK+
    initialization, application uniqueness, session management, provides some basic scriptability and desktop
    shell integration by exporting actions and menus and manages a list of toplevel windows whose life-cycle
    is automatically tied to the life-cycle of your application.
   </para>
   <para>
    While <ulink url="&gtk-application;"><code>gtk-application</code></ulink> works fine with plain
    &gtk-window; widgets, it is recommended to use it together
    with <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink>.
   </para>
   <para>
    When GDK threads are enabled, <ulink url="&gtk-application;"><code>gtk-application</code></ulink> will
    acquire the GDK lock when invoking actions that arrive from other processes.  The GDK lock is not touched
    for local action invocations.  In order to have actions invoked in a predictable context it is therefore
    recommended that the GDK lock be held while invoking actions locally with the function
    <ulink url="&g-action-group-activate-action;"><code>g-action-group-activate-action</code></ulink>.  The
    same applies to actions associated with <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> and to the 'activate' and 'open'
    <ulink url="&g-application;"><code>g-application</code></ulink> methods.
   </para>
   <para>
    To set an application menu for a <ulink url="&gtk-application;"><code>gtk-application</code></ulink>, use
    the generic function <ulink url="&gtk-application-app-menu;">
    <code>gtk-application-app-menu</code></ulink>.  The <ulink url="&g-menu-model;">
    <code>g-menu-model</code></ulink> that this function expects is usually constructed using
    <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink>, as seen in example
    <link linkend="example-application">Application</link>.  To specify a menubar that will be shown by
    <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink> widgets, use the
    generic function <ulink url="&gtk-application-menubar;"><code>gtk-application-menubar</code></ulink>.
    Use the base <ulink url="&g-action-map;"><code>g-action-map</code></ulink> interface to add actions, to
    respond to the user selecting these menu items.
   </para>
   <para>
    GTK+ displays these menus as expected, depending on the platform the application is running on.
   </para>
   <para>
    <ulink url="&gtk-application;"><code>gtk-application</code></ulink> optionally registers with a session
    manager of the users session, if you set the <ulink url="&register-session;">
    <code>register-session</code></ulink> property, and offers various functionality related to the session
    life-cycle.
   </para>
   <para>
    An application can block various ways to end the session with the function
    <ulink url="&gtk-application-inhibit;"><code>gtk-application-inhibit</code></ulink>.  Typical use cases
    for this kind of inhibiting are long-running, uninterruptible operations, such as burning a CD or
    performing a disk backup.  The session manager may not honor the inhibitor, but it can be expected to
    inform the user about the negative consequences of ending the session while inhibitors are present.
   </para>
  </section>

  <section id="Application_Window">
   <sectioninfo>
    <itermset>
     <indexterm zone="Application_Window">
      <primary>GtkApplicationWindow</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>application-window, gtk-application-window</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GActionGroup</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>action-group, g-action-group</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GActionMap</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>action-map, g-action-map</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GMenuModel</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>menu-model, g-menu-model</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>GtkMenuBar</primary>
     </indexterm>
     <indexterm zone="Application_Window">
      <primary>menu-bar,gtk-menu-bar</primary>
     </indexterm>
    </itermset>
   </sectioninfo>
   <title>Application Window</title>
   <para>
    <ulink url="&gtk-application-window;"><code>gtk-application-window</code></ulink> is a
    &gtk-window; subclass that offers some extra functionality
    for better integration with <ulink url="&gtk-application;"><code>gtk-application</code></ulink> features.
    Notably, it can handle both the application menu as well as the menubar. See the functions
    <ulink url="&gtk-application-app-menu;"><code>gtk-application-app-menu</code></ulink> and
    <ulink url="&gtk-application-menubar;"><code>gtk-application-menubar</code></ulink>.
   </para>
   <para>
    This class implements the <ulink url="&g-action-group;"><code>g-action-group</code></ulink> and
    <ulink url="&g-action-map;"><code>g-action-map</code></ulink> interfaces, to let you add window-specific
    actions that will be exported by the associated <ulink url="&gtk-application;">
    <code>gtk-application</code></ulink>, together with its application-wide actions. Window-specific actions
    are prefixed with the "win." prefix and application-wide actions are prefixed with the "app." prefix.
    Actions must be addressed with the prefixed name when referring to them from a
    <ulink url="&g-menu-model;"><code>g-menu-model</code></ulink>.
   </para>
   <para>
    Note that widgets that are placed inside a <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> can also activate these actions, if they implement the
    <ulink url="&gtk-actionable;"><code>gtk-actionable</code></ulink> interface.
   </para>
   <para>
    As with <ulink url="&gtk-application;"><code>gtk-application</code></ulink>, the GDK lock will be
    acquired when processing actions arriving from other processes and should therefore be held when
    activating actions locally if GDK threads are enabled.
   </para>
   <para>
    The settings <ulink url="&gtk-shell-shows-app-menu;"><code>gtk-shell-shows-app-menu</code></ulink> and
    <ulink url="&gtk-shell-shows-menubar;"><code>gtk-shell-shows-menubar</code></ulink> tell GTK+ whether the
    desktop environment is showing the application menu and menubar models outside the application as part of
    the desktop shell.  For instance, on OS X, both menus will be displayed remotely; on Windows neither will
    be.  gnome-shell (starting with version 3.4) will display the application menu, but not the menubar.
   </para>
   <para>
    If the desktop environment does not display the menubar, then <ulink url="&gtk-application-window;">
    <code>gtk-application-window</code></ulink> will automatically show a <ulink url="&gtk-menu-bar;">
    <code>gtk-menu-bar</code></ulink> for it. See the <ulink url="&gtk-application;">
    <code>gtk-application</code></ulink> docs for some screenshots of how this looks on different platforms.
    This behaviour can be overridden with the <ulink url="&show-menubar;"><code>show-menubar</code></ulink>
    property.  If the desktop environment does not display the application menu, then it will automatically
    be included in the menubar.
   </para>
   <para>
    The XML format understood by <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink> for
    <ulink url="&g-menu-model;"><code>g-menu-model</code></ulink> consists of a toplevel
    <code>&#x3c;menu></code> element, which contains one or more <code>&#x3c;item></code> elements. Each
    <code>&#x3c;item></code> element contains <code>&#x3c;attribute></code> and <code>&#x3c;link></code>
    elements with a mandatory name attribute.  <code>&#x3c;link></code> elements have the same content model
    as <code>&#x3c;menu></code>.
   </para>
   <para>
    Attribute values can be translated using gettext, like other <ulink url="&gtk-builder;">
    <code>gtk-builder</code></ulink> content.  <code>&#x3c;attribute></code> elements can be marked for
    translation with a translatable = "yes" attribute.  It is also possible to specify message context and
    translator comments, using the context and comments attributes. To make use of this, the
    <ulink url="&gtk-builder;"><code>gtk-builder</code></ulink> must have been given the gettext domain to
    use.
   </para>
  </section>

  <section id="Simple_Application">
   <title>Simple Application</title>
   <figure id="figure-bloatpad">
    <title>Simple Application</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/bloatpad.gif" format="gif"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="example-application">
    <title>Simple GTK+ Application</title>
    <programlisting>
(defclass bloat-pad (gtk-application)
  ()
  (:metaclass gobject-class)
  (:g-type-name . "BloatPad"))

(register-object-type-implementation "BloatPad"
                                     bloat-pad
                                     "GtkApplication"
                                     nil
                                     nil)

(defun new-window (application file)
  (declare (ignore file))
    (let (;; Create the application window
          (window (make-instance 'gtk-application-window
                                 :application application
                                 :title "Bloatpad"
                                 :border-width 12
                                 :default-width 500
                                 :default-height 400))
          (grid (make-instance 'gtk-grid))
          (toolbar (make-instance 'gtk-toolbar)))

      ;; Connect signal "destroy" to the application window
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)
                          (if (zerop gtk::*main-thread-level*)
                              (g-application-quit application))))

      ;; Add action "copy" to the application window
      (let ((action (g-simple-action-new "copy" nil)))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore action parameter))
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text"))))
               (gtk-text-buffer-copy-clipboard
                                  (gtk-text-view-buffer view)
                                  (gtk-widget-clipboard view "CLIPBOARD"))))))

      ;; Add action "paste" to the application window
      (let ((action (g-simple-action-new "paste" nil)))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore action parameter))
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text"))))
               (gtk-text-buffer-paste-clipboard
                                       (gtk-text-view-buffer view)
                                       (gtk-widget-clipboard view "CLIPBOARD")
                                       :editable t)))))

      ;; Add action "fullscreen" to the application window
      (let ((action (g-simple-action-new-stateful
                                               "fullscreen"
                                               nil
                                               (g-variant-new-boolean nil))))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (declare (ignore parameter))
             (let* ((state (g-action-state action))
                    (value (g-variant-boolean state)))
               (g-action-change-state action
                                      (g-variant-new-boolean (not value))))))
        (g-signal-connect action "change-state"
           (lambda (action parameter)
             (if (g-variant-boolean parameter)
                 (gtk-window-fullscreen window)
                 (gtk-window-unfullscreen window))
             (setf (g-simple-action-state action) parameter))))

      ;; Add action "justify" to the application window
      (let ((action (g-simple-action-new-stateful
                                             "justify"
                                             (g-variant-type-new "s")
                                             (g-variant-new-string "left"))))
        (g-action-map-add-action window action)
        (g-signal-connect action "activate"
           (lambda (action parameter)
             (g-action-change-state action parameter)))
        (g-signal-connect action "change-state"
           (lambda (action parameter)
             (let ((view (gobject::get-g-object-for-pointer
                           (g-object-data window "bloatpad-text")))
                   (str (g-variant-string parameter)))
               (cond ((equal str "left")
                      (setf (gtk-text-view-justification view) :left))
                     ((equal str "center")
                      (setf (gtk-text-view-justification view) :center))
                     (t
                      (setf (gtk-text-view-justification view) :right)))
               (setf (g-simple-action-state action) parameter)))))

      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-left")))
        (gtk-actionable-set-detailed-action-name button "win.justify::left")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-center")))
        (gtk-actionable-set-detailed-action-name button
                                                 "win.justify::center")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-toggle-tool-button
                                   :stock-id "gtk-justify-right")))
        (gtk-actionable-set-detailed-action-name button "win.justify::right")
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-separator-tool-item
                                   :draw nil)))
        (setf (gtk-tool-item-expand button) t)
        (gtk-container-add toolbar button))
      (let ((button (make-instance 'gtk-tool-item))
            (box (make-instance 'gtk-box
                                :orientation :horizontal
                                :spacing 6))
            (label (make-instance 'gtk-label
                                  :label "Fullscreen:"))
            (switch (make-instance 'gtk-switch)))
        (setf (gtk-actionable-action-name switch) "win.fullscreen")
        (gtk-container-add box label)
        (gtk-container-add box switch)
        (gtk-container-add button box)
        (gtk-container-add toolbar button))
      (gtk-grid-attach grid toolbar 0 0 1 1)
      (let ((scrolled (make-instance 'gtk-scrolled-window
                                     :hexpand t
                                     :vexpand t))
            (view (make-instance 'gtk-text-view)))
        (setf (g-object-data window "bloatpad-text") (pointer view))
        (gtk-container-add scrolled view)
        (gtk-grid-attach grid scrolled 0 1 1 1))
      (gtk-container-add window grid)
      (gtk-widget-show-all window)))

(defun bloat-pad-activate (application)
  ;; Start a main loop and create an application window
  (within-main-loop
    (new-window application nil))
  ;; Wait until the main loop has finished
  (join-gtk-main))

(defun create-about-dialog ()
  (let (;; Create an about dialog
        (dialog (make-instance 'gtk-about-dialog
                               :program-name "Example Dialog"
                               :version "0.00"
                               :copyright "(c) Dieter Kaiser"
                               :website
                               "github.com/crategus/cl-cffi-gtk"
                               :website-label "Project web site"
                               :license "LLGPL"
                               :authors '("Dieter Kaiser")
                               :documenters '("Dieter Kaiser")
                               :artists '("None")
                               :logo-icon-name
                               "applications-development"
                               :wrap-license t)))
    ;; Run the about dialog
    (gtk-dialog-run dialog)
    ;; Destroy the about dialog
    (gtk-widget-destroy dialog)))

(defvar *menu*
  "&#x3c;interface>
    &#x3c;menu id='app-menu'>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_New Window&#x3c;/attribute>
       &#x3c;attribute name='action'>app.new&#x3c;/attribute>
       &#x3c;attribute name='accel'>&lt;Primary&gt;n&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_About Bloatpad&#x3c;/attribute>
       &#x3c;attribute name='action'>app.about&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;section>
      &#x3c;item>
       &#x3c;attribute name='label' translatable='yes'>_Quit&#x3c;/attribute>
       &#x3c;attribute name='action'>app.quit&#x3c;/attribute>
       &#x3c;attribute name='accel'>&lt;Primary&gt;q&#x3c;/attribute>
      &#x3c;/item>
     &#x3c;/section>
     &#x3c;/menu>
    &#x3c;menu id='menubar'>
     &#x3c;submenu>
      &#x3c;attribute name='label' translatable='yes'>_Edit&#x3c;/attribute>
      &#x3c;section>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Copy&#x3c;/attribute>
        &#x3c;attribute name='action'>win.copy&#x3c;/attribute>
        &#x3c;attribute name='accel'>&lt;Primary&gt;c&#x3c;/attribute>
       &#x3c;/item>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Paste&#x3c;/attribute>
        &#x3c;attribute name='action'>win.paste&#x3c;/attribute>
        &#x3c;attribute name='accel'>&lt;Primary&gt;v&#x3c;/attribute>
       &#x3c;/item>
      &#x3c;/section>
     &#x3c;/submenu>
     &#x3c;submenu>
      &#x3c;attribute name='label' translatable='yes'>_View&#x3c;/attribute>
      &#x3c;section>
       &#x3c;item>
        &#x3c;attribute name='label' translatable='yes'>_Fullscreen&#x3c;/attribute>
        &#x3c;attribute name='action'>win.fullscreen&#x3c;/attribute>
        &#x3c;attribute name='accel'>F11&#x3c;/attribute>
       &#x3c;/item>
      &#x3c;/section>
     &#x3c;/submenu>
    &#x3c;/menu>
   &#x3c;/interface>")

(defun bloat-pad-startup (application)
  ;; Add action "new" to the application
  (let ((action (g-simple-action-new "new" nil)))
    ;; Connect a handler to the signal "activate"
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         ;; ensure-gtk-main increases the thread level for the new window
         (ensure-gtk-main)
         (new-window application nil)))
    ;; Add the action to the action map of the application
    (g-action-map-add-action application action))

  ;; Add action "about" to the application
  (let ((action (g-simple-action-new "about" nil)))
    ;; Connect a handler to the signal "activate"
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         (create-about-dialog)))
    ;; Add the action to the action map of the application
    (g-action-map-add-action application action))

  ;; Add action "quit" to the application
  (let ((action (g-simple-action-new "quit" nil)))
    ;; Connect a handler to the signal activate
    (g-signal-connect action "activate"
       (lambda (action parameter)
         (declare (ignore action parameter))
         ;; Destroy all windows of the application
         (dolist (window (gtk-application-get-windows application))
           (gtk-widget-destroy window))
         ;; Quit the main loop
         (leave-gtk-main)
         ;; Quit the application
         (g-application-quit application)))
    ;; Add the action to action map of the application
    (g-action-map-add-action application action))

  ;; Intitialize the application menu and the menubar
  (let ((builder (make-instance 'gtk-builder)))
    ;; Read the menus from a string
    (gtk-builder-add-from-string builder *menu*)
    ;; Set the application menu
    (setf (gtk-application-app-menu application)
          (gtk-builder-object builder "app-menu"))
    ;; Set the menubar
    (setf (gtk-application-menubar application)
          (gtk-builder-object builder "menubar"))))

(defun bloat-pad-open (application)
  (declare (ignore application))
  ;; Executed when the application is opened
  nil)

(defun bloat-pad-shutdown (application)
  (declare (ignore application))
  ;; Executed when the application is shut down
  nil)

(defmethod initialize-instance :after
    ((app bloat-pad) &#x26;key &#x26;allow-other-keys)
  (g-signal-connect app "activate" #'bloat-pad-activate)
  (g-signal-connect app "startup" #'bloat-pad-startup)
  (g-signal-connect app "open" #'bloat-pad-open)
  (g-signal-connect app "shutdown" #'bloat-pad-shutdown))

(defun bloat-pad-new ()
  (g-set-application-name "Bloatpad")
  (setf (gtk-settings-gtk-shell-shows-app-menu (gtk-settings-get-default))
        nil)
  (setf (gtk-settings-gtk-shell-shows-menubar (gtk-settings-get-default))
        nil)
  (make-instance 'bloat-pad
                 :application-id "com.crategus.bloatpad"
                 :flags :handles-open
                 :inactivity-timeout 30000
                 :register-session t))

(defun example-application (&#x26;optional (argc 0) (argv (null-pointer)))
  (let (;; Create an instance of the application Bloat Pad
        (bloat-pad (bloat-pad-new)))
    (format t "call G-APPLICATION-RUN.~%")
    ;; Run the application
    (g-application-run bloat-pad argv)
    (format t "back from G-APPLICATION-RUN.~%")))
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter id="GTK+_and_Cairo">
  <title>GTK+ and Cairo</title>
  <para>
   This tutorial is taken from the offical Cairo website at
   <ulink url="http://cairographics.org/tutorial/">cairographics.org/tutorial/</ulink> which has been derived
   from Michael Urman's Cairo tutorial for python programmers. The code snippets have been translated to Lisp
   and the text has only been changed as much as necessary.
  </para>
  <para>
   Cairo is a powerful 2d graphics library. This document introduces you to how Cairo works and many of the
   functions you will use to create the graphic experience you desire.
  </para>

  <section id="Cario_Drawing_Model">
   <title>Cairo's Drawing Model</title>
   <para>
    In order to explain the operations used by cairo, we first delve into a model of how Cairo models
    drawing. There are only a few concepts involved, which are then applied over and over by the different
    methods. First I will describe the nouns: destination, source, mask, path, and context.  After that I
    will describe the verbs which offer ways to manipulate the nouns and draw the graphics you wish to
    create.
   </para>

   <section id="Nouns">
    <title>Nouns</title>
    <para>
     Cairo's nouns are somewhat abstract.  To make them concrete I am including diagrams that depict how they
     interact. The first three nouns are the three layers in the diagrams you see in this section. The fourth
     noun, the path, is drawn on the middle layer when it is relevant. The final noun, the context, is not
     shown.
    </para>

    <bridgehead>Destination</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/destination.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The destination is the <emphasis>surface</emphasis> on which you are drawing. It may be tied to an
     array of pixels like in this tutorial, or it might be tied to a SVG or PDF file, or something else.
     This surface collects the elements of your graphic as you apply them, allowing you to build up a
     complex work as though painting on a canvas.
    </para>

    <bridgehead>Source</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/source.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The source is the "paint" you are about to work with. I show this as it is - plain black for several
     examples - but translucent to show lower layers. Unlike real paint, it does not have to be a single
     color; it can be a <emphasis>pattern</emphasis> or even a previously created destination
     <emphasis>surface</emphasis> (see <ulink url="http://cairographics.org/FAQ/#paint_from_a_surface">
     How do I paint from one surface to another?</ulink>). Also unlike real paint it can contain transparency
     information - the Alpha channel.
    </para>

    <bridgehead>Mask</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/the-mask.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The mask is the most important piece: it controls where you apply the source to the destination. I
     will show it as a yellow layer with holes where it lets the source through.  When you apply a drawing
     verb, it is like you stamp the source to the destination. Anywhere the mask allows, the source is
     copied. Anywhere the mask disallows, nothing happens.
    </para>

    <bridgehead>Path</bridgehead>
    <para>
     The path is somewhere between part of the mask and part of the context. I will show it as thin green
     lines on the mask layer. It is manipulated by path verbs, then used by drawing verbs.
    </para>

    <bridgehead>Context</bridgehead>
    <para>
     The context keeps track of everything that verbs affect. It tracks one source, one destination, and
     one mask. It also tracks several helper variables like your line width and style, your font face and
     size, and more. Most importantly it tracks the path, which is turned into a mask by drawing verbs.
    </para>
    <para>
     Before you can start to draw something with Cairo, you need to create the context. The context is 
     stored in Cairo's central data type, called <ulink url="&cairo-t;"><code>cairo-t</code></ulink>.
     When you create a Cairo context, it must be tied to a specific surface - for example, an image surface
     if you want to create a PNG file. There is also a data type for the surface, called
     <ulink url="&cairo-surface-t;"><code>cairo-surface-t</code></ulink>. You can initialize your Cairo
     context with the functions <ulink url="&cairo-image-surface-create;">
     <code>cairo-image-surface-create</code></ulink> and <ulink url="&cairo-create;">
     <code>cairo-create</code></ulink> like this:
    </para>
    <programlisting>
(let* ((surface (cairo-image-surface-create :argb32 120 120))
       (cr (cairo-create surface)))
  ... )
    </programlisting>
    <para>
     The Cairo context in this example is tied to an image surface of dimension 120 x 120 and 32 bits per
     pixel to store RGB and Alpha information. Surfaces can be created specific to most Cairo backends, see
     the <ulink url="http://www.crategus.com/books/cl-cffi-gtk/pages/cairo.html">
     Cairo API documentation</ulink> for details.
    </para>
   </section>

   <section id="Verbs">
    <title>Verbs</title>
    <para>
     The reason you are using Cairo in a program is to draw. Cairo internally draws with one fundamental
     drawing operation: the source and mask are freely placed somewhere over the destination. Then the
     layers are all pressed together and the paint from the source is transferred to the destination wherever
     the mask allows it. To that extent the following five drawing verbs, or operations, are all similar.
     They differ by how they construct the mask.
    </para>

    <bridgehead>Stroke</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/stroke.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> operation takes a virtual pen along
     the path. It allows the source to transfer through the mask in a thin (or thick) line around the path,
     according to the pen's <ulink url="&cairo-set-line-width;"><code>line width</code></ulink>,
     <ulink url="&cairo-set-dash;"><code>dash style</code></ulink>, and
     <ulink url="&cairo-set-line-cap;"><code>line caps</code></ulink>.
    </para>
    <programlisting>
(cairo-set-line-width cr 0.1)
(cairo-set-source-rgb cr 1.0 0.0 0.0)
(cairo-rectangle cr 0.25 0.25 0.5 0.5)
(cairo-stroke cr)
    </programlisting>
    <para>
     The following example shows the above code snippet in action and the code to produce the output:
    </para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/cairo-stroke.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <example id="example-cairo-stroke">
     <title>Demo Cairo Stroke</title>
     <programlisting>
(defun demo-cairo-stroke ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :type :toplevel
                                 :title "Demo Cairo Stroke"
                                 :border-width 12
                                 :default-width 400
                                 :default-height 400)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      ;; Signals used to handle the backing surface
      (g-signal-connect window "draw"
         (lambda (widget cr)
           (let ((cr (pointer cr))
                 ;; Get the GdkWindow for the widget
                 (window (gtk-widget-window widget)))
           ;; Clear surface
           (cairo-set-source-rgb cr 1.0 1.0 1.0)
           (cairo-paint cr)
           ;; Example is in 1.0 x 1.0 coordinate space
           (cairo-scale cr
                        (gdk-window-width window)
                        (gdk-window-height window))
           ;; Drawing code goes here
           (cairo-set-line-width cr 0.1)
           (cairo-set-source-rgb cr 1.0 0.0 0.0)
           (cairo-rectangle cr 0.25 0.25 0.5 0.5)
           (cairo-stroke cr)
           ;; Destroy the Cario context
           (cairo-destroy cr)
           t)))
      (gtk-widget-show-all window))))
     </programlisting>
    </example>

    <bridgehead>Fill</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/fill.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink> operation instead uses the path like the
     lines of a coloring book, and allows the source through the mask within the hole whose boundaries are
     the path. For complex paths (paths with multiple closed sub-paths - like a donut - or paths that
     self-intersect) this is influenced by the <ulink url="&cairo-set-fill-rule;">fill rule</ulink>. Note
     that while stroking the path transfers the source for half of the line width on each side of the path,
     filling a path fills directly up to the edge of the path and no further.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 1.0 0.0 0.0)
(cairo-rectangle cr 0.25 0.25 0.5 0.5)
(cairo-fill cr)
    </programlisting>

    <bridgehead>Show Text / Glyps</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/showtext.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-show-text;"><code>cairo-show-text</code></ulink> operation forms the mask from
     text. It may be easier to think of <ulink url="&cairo-show-text;"><code>cairo-show-text</code></ulink>
     as a shortcut for creating a path with <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink> and then using <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink> to transfer it. Be aware <ulink url="&cairo-show-text;">
     <code>cairo-show-text</code></ulink> caches glyphs so is much more efficient if you work with a lot of
     text.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0.0 0.0 0.0)
(cairo-select-font-face cr "Georgia" :normal :bold)
(cairo-set-font-size cr 1.2)
(let ((text-extents (cairo-text-extents cr "a")))
  (cairo-move-to cr
                 (- 0.5
                    (/ (cairo-text-extents-t-width text-extents) 2)
                    (cairo-text-extents-t-x-bearing text-extents))
                 (- 0.5
                    (/ (cairo-text-extents-t-height text-extents) 2)
                    (cairo-text-extents-t-y-bearing text-extents)))
  (cairo-show-text cr "a"))
    </programlisting>

    <bridgehead>Paint</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/paint.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-paint;"><code>cairo-paint</code></ulink> operation uses a mask that transfers
     the entire source to the destination. Some people consider this an infinitely large mask, and others
     consider it no mask; the result is the same. The related operation
     <ulink url="&cairo-paint-with-alpha;"><code>cairo-paint-with-alpha</code></ulink> similarly allows
     transfer of the full source to destination, but it transfers only the provided percentage of the color.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0.0 0.0 0.0)
(cairo-paint-with-alpha cr 0.5)
    </programlisting>

    <bridgehead>Mask</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/mask.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     The <ulink url="&cairo-mask;"><code>cairo-mask</code></ulink> and <ulink url="&cairo-mask-surface;">
     <code>cairo-mask-surface</code></ulink> operations allow transfer according to the transparency/opacity
     of a second source pattern or surface. Where the pattern or surface is opaque, the current source is
     transferred to the destination. Where the pattern or surface is transparent, nothing is transferred.
    </para>
    <programlisting>
(let ((linpat (cairo-pattern-create-linear 0 0 1 1))
      (radpat (cairo-pattern-create-radial 0.5 0.5 0.25 0.5 0.5 0.75)))

  (cairo-pattern-add-color-stop-rgb linpat 0 0 0.3 0.8)
  (cairo-pattern-add-color-stop-rgb linpat 1 0 0.8 0.3)

  (cairo-pattern-add-color-stop-rgba radpat 0 0 0 0 1)
  (cairo-pattern-add-color-stop-rgba radpat 0.5 0 0 0 0)

  (cairo-set-source cr linpat)
  (cairo-mask cr radpat))
    </programlisting>
   </section>
  </section>

  <section id="Drawing_with_Cairo">
   <title>Drawing with Cairo</title>
   <para>
    In order to create an image you desire, you have to prepare the context for each of the drawing verbs.
    To use <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> or <ulink url="&cairo-fill;">
    <code>cairo-fill</code></ulink> you first need a path. To use <ulink url="&cairo-show-text;">
    <code>cairo-show-text</code></ulink> you must position your text by its insertion point. To use
    <ulink url="&cairo-mask;"><code>cairo-mask</code></ulink> you need a second source pattern or surface.
    And to use any of the operations, including <ulink url="&cairo-paint;"><code>cairo-paint</code></ulink>,
    you need a primary source.
   </para>

   <section id="Preparing_and_Selecting_a_Source">
    <title>Preparing and Selecting a Source</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/setsourcergba.png" format="png"></imagedata>
      </imageobject>
     </mediaobject>
    <para>
     There are three main kinds of sources in cairo: colors, gradients, and images. Colors are the simplest;
     they use a uniform hue and opacity for the entire source. You can select these without any preparation
     with <ulink url="&cairo-set-source-rgb;"><code>cairo-set-source-rgb</code></ulink> and
     <ulink url="&cairo-set-source-rgba;"><code>cairo-set-source-rgba</code></ulink>. Using
     <code>(cairo-set-source-rgb cr r g b)</code> is equivalent to using
     <code>(cairo-set-source-rgba cr r g b 1.0)</code>, and it sets your source color to use full opacity.
    </para>
    <programlisting>
(cairo-set-source-rgb cr 0 0 0)
(cairo-move-to cr 0 0)
(cairo-line-to cr 1 1)
(cairo-move-to cr 1 0)
(cairo-line-to cr 0 1)
(cairo-set-line-width cr 0.2)
(cairo-stroke cr)

(cairo-rectangle cr 0 0 0.5 0.5)
(cairo-set-source-rgba cr 1 0 0 0.80)
(cairo-fill cr)

(cairo-rectangle cr 0 0.5 0.5 0.5)
(cairo-set-source-rgba cr 0 1 0 0.60)
(cairo-fill cr)

(cairo-rectangle cr 0.5 0 0.5 0.5)
(cairo-set-source-rgba cr 0 0 1 0.40)
(cairo-fill cr)
    </programlisting>
    <para>
     Gradients describe a progression of colors by setting a start and stop reference location and a series
     of "stops" along the way.  Linear gradients are built from two points which pass through parallel lines
     to define the start and stop locations.  Radial gradients are also built from two points, but each has
     an associated radius of the circle on which to define the start and stop locations.  Stops are added to 
     the gradient with <ulink url="&cairo-pattern-add-color-stop-rgb;">
     <code>cairo-pattern-add-color-stop-rgb</code></ulink> and
     <ulink url="&cairo-pattern-add-color-stop-rgba;"><code>cairo-pattern-add-color-stop-rgba</code></ulink>
     which take a color like <code>cairo-set-source-rgb*</code>, as well as an offset to indicate where it
     lies between the reference locations. The colors between adjacent stops are averaged over space to form
     a smooth blend. Finally, the behavior beyond the reference locations can be controlled with
     <ulink url="&cairo-pattern-set-extend;"><code>cairo-pattern-set-extend</code></ulink>.
    </para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/setsourcegradient.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <programlisting>
(let ((radpat (cairo-pattern-create-radial 0.25
                                           0.25 0.10 0.50 0.50 0.50))
      (linpat (cairo-pattern-create-linear 0.25 0.35 0.75 0.65)))
  (cairo-pattern-add-color-stop-rgb radpat 0.00 1.00 0.80 0.80)
  (cairo-pattern-add-color-stop-rgb radpat 1.00 0.90 0.00 0.00)
  (iter (for i from 1 below 10)
        (iter (for j from 1 below 10)
              (cairo-rectangle cr
                               (- (/ i 10.0) 0.04)
                               (- (/ j 10.0) 0.04)
                               0.08
                               0.08)))
  (cairo-set-source cr radpat)
  (cairo-fill cr)

  (cairo-pattern-add-color-stop-rgba linpat 0.00 1.0 1.0 1.0 0.0)
  (cairo-pattern-add-color-stop-rgba linpat 0.25 0.0 1.0 0.0 0.5)
  (cairo-pattern-add-color-stop-rgba linpat 0.50 1.0 1.0 1.0 0.0)
  (cairo-pattern-add-color-stop-rgba linpat 0.75 0.0 0.0 1.0 0.5)
  (cairo-pattern-add-color-stop-rgba linpat 1.00 1.0 1.0 1.0 0.0)

  (cairo-rectangle cr 0.0 0.0 1.0 1.0)
  (cairo-set-source cr linpat)
  (cairo-fill cr))
    </programlisting>
    <para>
     Images include both surfaces loaded from existing files with
     <ulink url="&cairo-image-surface-create-from-png;">
     <code>cairo-image-surface-create-from-png</code></ulink> and surfaces created from within Cairo as an
     earlier destination. As of Cairo 1.2, the easiest way to make and use an earlier destination as a
     source is with <ulink url="&cairo-push-group;"><code>cairo-push-group</code></ulink> and either
     <ulink url="&cairo-pop-group;"><code>cairo-pop-group</code></ulink> or
     <ulink url="&cairo-pop-group-to-source;"><code>cairo-pop-group-to-source</code></ulink>. Use
     <ulink url="&cairo-pop-group-to-source;"><code>cairo-pop-group-to-source</code></ulink> to use it just
     until you select a new source, and <ulink url="&cairo-pop-group;"><code>cairo-pop-group</code></ulink>
     when you want to save it so you can select it over and over again with <ulink url="&cairo-set-source;">
     <code>cairo-set-source</code></ulink>.
    </para>
   </section>

   <section id="Creating_a_Path">
    <title>Creating a Path</title>
    <para>
     Cairo always has an active path. If you call <ulink url="&cairo-stroke;">
     <code>cairo-stroke</code></ulink> it will draw the path with your line settings. If you call
     <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink> it will fill the inside of the path. But as
     often as not, the path is empty, and both calls will result in no change to your destination. Why is it
     empty so often? For one, it starts that way; but more importantly after each
     <ulink url="&cairo-stroke;"><code>cairo-stroke</code></ulink> or <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink> it is emptied again to let you start building your next path.
    </para>
    <para>
     What if you want to do multiple things with the same path? For instance to draw a red rectangle with a
     black border, you would want to fill the rectangle path with a red source, then stroke the same path
     with a black source.  A rectangle path is easy to create multiple times, but a lot of paths are more
     complex.
    </para>
    <para>
     Cairo supports easily reusing paths by having alternate versions of its operations. Both draw the same
     thing, but the alternate does not reset the path. For stroking, alongside <ulink url="&cairo-stroke;">
     <code>cairo-stroke</code></ulink> there is <ulink url="&cairo-stroke-preserve;">
     <code>cairo-stroke-preserve</code></ulink>; for filling, <ulink url="&cairo-fill-preserve;">
     <code>cairo-fill-preserve</code></ulink> joins <ulink url="&cairo-fill;">
     <code>cairo-fill</code></ulink>. Even setting the clip has a preserve variant. Apart from choosing when
     to preserve your path, there are only a couple common operations.
    </para>
   </section>

   <section id="Moving">
    <title>Moving</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-moveto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Cairo uses a connect-the-dots style system when creating paths.  Start at 1, draw a line to 2, then 3,
     and so forth.  When you start a path, or when you need to start a new sub-path, you want it to be like
     point 1: it has nothing connecting to it.  For this, use <ulink url="&cairo-move-to;">
     <code>cairo-move-to</code></ulink>.  This sets the current reference point without making the path
     connect the previous point to it.  There is also a relative coordinate variant,
     <ulink url="&cairo-rel-move-to;"><code>cairo-rel-move-to</code></ulink>, which sets the new reference a
     specified distance away from the current reference instead. After setting your first reference point,
     use the other path operations which both update the reference point and connect to it in some way.
    </para>
    <programlisting>
(cairo-move-to cr 0.25 0.25)
    </programlisting>

    <bridgehead>Straight Lines</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-lineto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Whether with absolute coordinates <ulink url="&cairo-line-to;"><code>cairo-line-to</code></ulink>
     (extend the path from the reference to this point), or relative coordinates
     <ulink url="&cairo-rel-line-to;"><code>cairo-rel-line-to</code></ulink> (extend the path from the
     reference this far in this direction), the path connection will be a straight line.  The new reference
     point will be at the other end of the line.
    </para>
    <programlisting>
(cairo-line-to cr 0.5 0.375)
(cairo-rel-line-to cr 0.25 -0.125)
    </programlisting>

    <bridgehead>Arcs</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-arcto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Arcs are parts of the outside of a circle.  Unlike straight lines, the point you directly specify is not
     on the path.  Instead it is the center of the circle that makes up the addition to the path.  Both a
     starting and ending point on the circle must be specified, and these points are connected either
     clockwise by <ulink url="&cairo-arc;"><code>cairo-arc</code></ulink> or counter-clockwise by
     <ulink url="&cairo-arc-negative;"><code>cairo-arc-negative</code></ulink>. If the previous reference
     point is not on this new curve, a straight line is added from it to where the arc begins. The reference
     point is then updated to where the arc ends. There are only absolute versions.
    </para>
    <programlisting>
(cairo-arc cr 0.5 0.5 (* 0.25 (sqrt 2)) (* -0.25 pi) (* 0.25 pi))
    </programlisting>

    <bridgehead>Curves</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-curveto.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Curves in Cairo are cubic Bezier splines.  They start at the current reference point and smoothly follow
     the direction of two other points (without going through them) to get to a third specified point.  Like
     lines, there are both absolute <ulink url="&cairo-curve-to;"><code>cairo-curve-to</code></ulink> and
     relative <ulink url="&cairo-rel-curve-to;"><code>cairo-rel-curve-to</code></ulink> versions. Note that
     the relative variant specifies all points relative to the previous reference point, rather than each
     relative to the preceding control point of the curve.
    </para>
    <programlisting>
(cairo-rel-curve-to cr -0.25 -0.125 -0.25 0.125 -0.5, 0)
    </programlisting>

    <bridgehead>Close the path</bridgehead>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/path-close.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
    <para>
     Cairo can also close the path by drawing a straight line to the beginning of the current sub-path. This
     straight line can be useful for the last edge of a polygon, but is not directly useful for curve-based
     shapes. A closed path is fundamentally different from an open path: it is one continuous path and has
     no start or end.  A closed path has no line caps for there is no place to put them.
    </para>
    <programlisting>
(cairo-close-path cr)
    </programlisting>

    <bridgehead>Text</bridgehead>
    <para>
     Finally text can be turned into a path with <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink>. Paths created from text are like any other path, supporting stroke
     or fill operations. This path is placed anchored to the current reference point, so
     <ulink url="&cairo-move-to;"><code>cairo-move-to</code></ulink> your desired location before turning
     text into a path. However there are performance concerns to doing this if you are working with a lot of
     text; when possible you should prefer using the verb <ulink url="&cairo-show-text;">
     <code>cairo-show-text</code></ulink> over <ulink url="&cairo-text-path;">
     <code>cairo-text-path</code></ulink> and <ulink url="&cairo-fill;"><code>cairo-fill</code></ulink>.
    </para>
   </section>
  </section>

  <section id="Understanding_Text">
   <title>Understanding Text</title>
   <mediaobject>
    <imageobject>
     <imagedata fileref="figures/textextents.png" format="png"></imagedata>
    </imageobject>
   </mediaobject>
   <para>
    To use text effectively you need to know where it will go. The methods <ulink url="&cairo-font-extents;">
    <code>cairo-font-extents</code></ulink> and <ulink url="&cairo-text-extents;">
    <code>cairo-text-extents</code></ulink> get you this information. Since this diagram is hard to see so
    small, I suggest getting its source and bump the size up to 600. It shows the relation between the  
    reference point (red dot); suggested next reference point (blue dot); bounding box (dashed blue lines);
    bearing displacement (solid blue line); and height, ascent, baseline, and descent lines (dashed green).
   </para>
   <para>
    The reference point is always on the baseline.  The descent line is below that, and reflects a rough
    bounding box for all characters in the font.  However it is an artistic choice intended to indicate
    alignment rather than a true bounding box.  The same is true for the ascent line above.  Next above that
    is the height line, the artist-recommended spacing between subsequent baselines.  All three of these are
    reported as distances from the baseline, and expected to be positive despite their differing directions.
   </para>
   <para>
    The bearing is the displacement from the reference point to the upper-left corner of the bounding box.
    It is often zero or a small positive value for x displacement, but can be negative x for characters like
    j as shown; it is almost always a negative value for y displacement.  The width and height then describe
    the size of the bounding box.  The advance takes you to the suggested reference point for the next
    letter.  Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative,
    or the advance is smaller than the width would suggest.
   </para>
   <para>
    In addition to placement, you also need to specify a face, style, and size.  Set the face and style
    together with <ulink url="&cairo-select-font-face;"><code>cairo-select-font-face</code></ulink>, and the
    size with <ulink url="&cairo-set-font-size;"><code>cairo-set-font-size</code></ulink>.  If you need even
    finer control, try getting a <ulink url="&cairo-font-options-t;">
    <code>cairo-font-options-t</code></ulink> with <ulink url="&cairo-get-font-options;">
    <code>cairo-get-font-options</code></ulink>, tweaking it, and setting it with
    <ulink url="&cairo-set-font-options;"><code>cairo-set-font-options</code></ulink>.
   </para>
  </section>

  <section id="Working_with_Transforms">
   <title>Working with Transforms</title>
   <para>
    Transforms have three major uses.  First they allow you to set up a coordinate system that is easy to
    think in and work in, yet have the output be of any size. Second they allow you to make helper functions
    that work at or around a (0, 0) but can be applied anywhere in the output image.  Thirdly they let you
    deform the image, turning a circular arc into an elliptical arc, etc.  Transforms are a way of setting
    up a relation between two coordinate systems.  The device-space coordinate system is tied to the surface,
    and cannot change.  The user-space coordinate system matches that space by default, but can be changed
    for the above reasons.  The helper functions <ulink url="&cairo-user-to-device;">
    <code>cairo-user-to-device</code></ulink> and <ulink url="&cairo-user-to-device-distance;">
    <code>cairo-user-to-device-distance</code></ulink> tell you what the device-coordinates are for a
    user-coordinates position or distance.  Correspondingly <ulink url="&cairo-device-to-user;">
    <code>cairo-device-to-user</code></ulink> and <ulink url="&cairo-device-to-user-distance;">
    <code>cairo-device-to-user-distance</code></ulink> tell you user-coordinates for a device-coordinates
    position or distance.  Remember to send positions through the non-distance variant, and relative moves
    or other distances through the distance variant.
   </para>
   <para>
    I leverage all of these reasons to draw the diagrams in this document.  Whether I am drawing 120 x 120
    or 600 x 600, I use <ulink url="&cairo-scale;"><code>cairo-scale</code></ulink> to give me a 1.0 x 1.0
    workspace.  To place the results along the right column, such as in the discussion of cairo's drawing
    model, I use <ulink url="&cairo-translate;"><code>cairo-translate</code></ulink>.  And to add the
    perspective view for the overlapping layers, I set up an arbitrary deformation with
    <ulink url="&cairo-transform;"><code>cairo-transform</code></ulink> on a <ulink url="&cairo-matrix-t;">
    <code>cairo-matrix-t</code></ulink>.
   </para>
   <para>
    To understand your transforms, read them bottom to top, applying them to the point you are drawing.  To
    figure out which transforms to create, think through this process in reverse.  For example if I want my
    1.0 x 1.0 workspace to be 100 x 100 pixels in the middle of a 120 x 120 pixel surface, I can set it up
    one of three ways:
   </para>
   <programlisting>
1. (cairo-translate cr 10 10)
   (cairo-scale cr 100 100)

2. (cairo-scale cr 100 100)
   (cairo-translate cr 0.1 0.1)

3. (let ((mat (cairo-matrix-init 100 0 0 100 10 10)))
     (cairo-transform cr mat)
     ... )
   </programlisting>
   <para>
    Use the first when relevant because it is often the most readable; use the third when necessary to
    access additional control not available with the primary functions.
   </para>
   <para>
    Be careful when trying to draw lines while under transform.  Even if you set your line width while the
    scale factor was 1, the line width setting is always in user-coordinates and is not modified by setting
    the scale.  While you are operating under a scale, the width of your line is multiplied by that scale.
    To specify a width of a line in pixels, use <ulink url="&cairo-device-to-user-distance;">
    <code>cairo-device-to-user-distance</code></ulink> to turn a (1, 1) device-space distance into, for
    example, a (0.01, 0.01) user-space distance.  Note that if your transform deforms the image there is not
    necessarily a way to specify a line with a uniform width.
   </para>
  </section>

  <section id="Where_to_Go_Next">
   <title>Where to Go Next</title>
   <para>
    This wraps up the tutorial. It does not cover all functions in Cairo, so for some "advanced" lesser-used
    features, you will need to look elsewhere. The code behind the examples (layer diagrams, drawing
    illustrations) uses a handful of techniques that are not described within, so analyzing them may be a
    good first step. Other examples on cairographics.org lead in different directions. As with everything,
    there is a large gap between knowing the rules of the tool, and being able to use it well. The final
    section of this document provides some ideas to help you traverse parts of the gap.
   </para>
  </section>

  <section id="Tips_and_Tricks">
   <title>Tips and Tricks</title>
   <para>
    In the previous sections you should have built up a firm grasp of the operations Cairo uses to create
    images. In this section I've put together a small handful of snippets I have found particularly useful
    or non-obvious.  I am still new to Cairo myself, so there may be other better ways to do these things.
    If you find a better way, or find a cool way to do something else, let me know and perhaps I can
    incorporate it into these tips.
   </para>

   <section id="Line_Width">
    <title>Line Width</title>
    <para>
     When you are working under a uniform scaling transform, you can not just use pixels for the width of
     your line.  However it is easy to translate it with the help of
     <ulink url="&cairo-device-to-user-distance;"><code>cairo-device-to-user-distance</code></ulink>
     (assuming that the pixel width is  1):
    </para>
    <programlisting>
(muliple-value-bind (ux uy)
    (cairo-device-to-user-distance cr)
  (cairo-set-line-width cr (min ux uy)))
    </programlisting>
    <para>
     When you are working under a deforming scale, you may wish to still have line widths that are uniform
     in device space.  For this you should return to a uniform scale before you stroke the path.  In the
     image, the arc on the left is stroked under a deformation, while the arc on the right is stroked under
     a uniform scale.
    </para>
    <programlisting>
(cairo-set-line-width cr 0.1)

(cairo-save cr)
(cairo-scale cr 0.5 1)
(cairo-arc cr 0.5 0.5 0.40 0 (* 2 pi))
(cairo-stroke cr)

(cairo-translate cr 1 0)
(cairo-arc cr 0.5 0.5 0.40 0 (* 2pi))
(cairo-restore cr)
(cairo-stroke cr)
    </programlisting>
   </section>

   <section id="Text_Alignment">
    <title>Text Alignment</title>
    <para>
     When you try to center text letter by letter at various locations, you have to decide how you want to
     center it.  For example the following code will actually center letters individually, leading to poor
     results when your letters are of different sizes.  (Unlike most examples, here I assume a 26 x 1
     workspace.)
    </para>
    <programlisting>
cairo_text_extents_t te;
char alphabet[] = "AbCdEfGhIjKlMnOpQrStUvWxYz";
char letter[2];

for (i=0; i &#x3c; strlen(alphabet); i++) {
    *letter = '\0';
    strncat (letter, alphabet + i, 1);

    cairo_text_extents (cr, letter, &#x26;te);
    cairo_move_to (cr, i + 0.5 - te.x_bearing - te.width / 2,
            0.5 - te.y_bearing - te.height / 2);
    cairo_show_text (cr, letter);
}
    </programlisting>
    <para>
     Instead the vertical centering must be based on the general size of the font, thus keeping your baseline
     steady.  Note that the exact positioning now depends on the metrics provided by the font itself, so the
     results are not necessarily the same from font to font.
    </para>
    <programlisting>
cairo_font_extents_t fe;
cairo_text_extents_t te;
char alphabet[] = "AbCdEfGhIjKlMnOpQrStUvWxYz";
char letter[2];

cairo_font_extents (cr, &#x26;fe);
for (i=0; i &#x3c; strlen(alphabet); i++) {
    *letter = '\0';
    strncat (letter, alphabet + i, 1);

    cairo_text_extents (cr, letter, &#x26;te);
    cairo_move_to (cr, i + 0.5 - te.x_bearing - te.width / 2,
            0.5 - fe.descent + fe.height / 2);
    cairo_show_text (cr, letter);
}
    </programlisting>
   </section>
  </section>

  <section id="Writing_a_Widget_Using_Cairo_and_GTK+">
   <title>Writing a Widget Using Cairo and GTK+</title>
   <figure id="figure-cairo-clock">
    <title>Cairo Clock</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="figures/cairo-clock.png" format="png"></imagedata>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    This demo shows a custom widget named <code>egg-clock-face</code> which draws a clock using
    Cairo.  This Cairo Clock example is inspired by the C code from Davyd Madeley.  
    <code>egg-clock-face</code> is defined as a subclass of the &gtk-drawing-area;
    class.  Only the property <code>time</code> is added to
    hold the actual time of the clock.  The <code>initialize-instance</code> method installs a
    timeout source with the function <ulink url="&g-timeout-add;"><code>g-timeout-add</code>
    </ulink>, which updates every second the <code>time</code> property of <code>egg-clock-face
    </code> and requests the redrawing of the widget.  The "draw" signal handler draws the clock
    into the &gtk-drawing-area; of the
    <code>egg-clock-face</code> widget.
   </para>

   <example id="example-cairo-clock">
    <title>Demo Cairo Clock</title>
    <programlisting>
(asdf:load-system :cl-cffi-gtk)

(defpackage :cairo-clock
  (:use :gtk :gdk :gobject :glib :pango :cairo :cffi :iterate :common-lisp)
  (:export #:demo-cairo-clock))

(in-package :cairo-clock)

;; Class egg-clock-face is a subclass of a GtkDrawingArea

(defclass egg-clock-face (gtk-drawing-area)
  ((time :initarg :time
         :initform (multiple-value-list (get-decoded-time))
         :accessor egg-clock-face-time))
  (:metaclass gobject-class))

(defmethod initialize-instance :after
    ((clock egg-clock-face) &#x26;key &#x26;allow-other-keys)
  ;; A timeout source for the time
  (g-timeout-add 1000
                 (lambda ()
                   (setf (egg-clock-face-time clock)
                         (multiple-value-list (get-decoded-time)))
                   (gtk-widget-queue-draw clock)
                   +g-source-continue+))
  ;; Signal handler which draws the clock
  (g-signal-connect clock "draw"
     (lambda (widget cr)
       (let ((cr (pointer cr))
             ;; Get the GdkWindow for the widget
             (window (gtk-widget-window widget)))
       ;; Clear surface
       (cairo-set-source-rgb cr 1.0 1.0 1.0)
       (cairo-paint cr)
       (let* ((x (/ (gdk-window-width window) 2))
              (y (/ (gdk-window-height window) 2))
              (radius (- (min x y) 12)))
         ;; Clock back
         (cairo-arc cr x y radius 0 (* 2 pi))
         (cairo-set-source-rgb cr 1 1 1)
         (cairo-fill-preserve cr)
         (cairo-set-source-rgb cr 0 0 0)
         (cairo-stroke cr)
         ;; Clock ticks
         (let ((inset 0.0)
               (angle 0.0))
           (dotimes (i 12)
             (cairo-save cr)
             (setf angle (/ (* i pi) 6))
             (if (eql 0 (mod i 3))
                 (setf inset (* 0.2 radius))
                 (progn
                   (setf inset (* 0.1 radius))
                   (cairo-set-line-width cr
                                         (* 0.5 (cairo-get-line-width cr)))))
             (cairo-move-to cr
                            (+ x (* (- radius inset) (cos angle)))
                            (+ y (* (- radius inset) (sin angle))))
             (cairo-line-to cr
                            (+ x (* radius (cos angle)))
                            (+ y (* radius (sin angle))))
             (cairo-stroke cr)
             (cairo-restore cr)))
         (let ((seconds (first (egg-clock-face-time clock)))
               (minutes (second (egg-clock-face-time clock)))
               (hours (third (egg-clock-face-time clock))))
           ;; The hour hand is rotated 30 degrees (pi/6 r) per hour
           ;; + 1/2 a degree (pi/360 r) per minute
           (let ((hours-angle (* (/ pi 6) hours))
                 (minutes-angle (* (/ pi 360) minutes)))
             (cairo-save cr)
             (cairo-set-line-width cr (* 2.5 (cairo-get-line-width cr)))
             (cairo-move-to cr x y)
             (cairo-line-to cr
                            (+ x
                               (* (/ radius 2)
                                  (sin (+ hours-angle minutes-angle))))
                            (+ y
                               (* (/ radius 2)
                                  (- (cos (+ hours-angle minutes-angle))))))
             (cairo-stroke cr)
             (cairo-restore cr))
           ;; The minute hand is rotated 6 degrees (pi/30 r)
           ;; per minute
           (let ((angle (* (/ pi 30) minutes)))
             (cairo-move-to cr x y)
             (cairo-line-to cr
                            (+ x (* radius 0.75 (sin angle)))
                            (+ y (* radius 0.75 (- (cos angle)))))
             (cairo-stroke cr))
           ;; Seconds hand: Operates identically to the minute hand
           (let ((angle (* (/ pi 30) seconds)))
             (cairo-save cr)
             (cairo-set-source-rgb cr 1 0 0)
             (cairo-move-to cr x y)
             (cairo-line-to cr (+ x (* radius 0.7 (sin angle)))
                               (+ y (* radius 0.7 (- (cos angle)))))
             (cairo-stroke cr)
             (cairo-restore cr))))
       ;; Destroy the Cario context
       (cairo-destroy cr)
       t))))

(defun demo-cairo-clock ()
  (within-main-loop
    (let ((window (make-instance 'gtk-window
                                 :title "Demo Cairo Clock"
                                 :default-width 250
                                 :default-height 250))
          (clock (make-instance 'egg-clock-face)))
      (g-signal-connect window "destroy"
                        (lambda (widget)
                          (declare (ignore widget))
                          (leave-gtk-main)))
      (gtk-container-add window clock)
      (gtk-widget-show-all window))))
    </programlisting>
   </example>
  </section>
 </chapter>

 <appendix id="Licenses">
  <title>Licenses</title>
  <para>
   The GTK+ 3 Tutorial for Lisp and the presented examples have been collected from different sources.  The
   original sources have been modified to describe the Lisp binding.  Numerous examples are taken from C
   code and translated to Lisp.
  </para>
  <orderedlist>
   <listitem>
    GTK+ 2.0 Tutorial, Tony Gale, Ian Main &#x26; the GTK team,
    The GTK Tutorial is Copyright (C) 1997 Ian Main,
    Copyright (C) 1998-2002 Tony Gale.
   </listitem>
   <listitem>
    Multiline Text Editing Widget, Vijay Kumar B.,
    Copyright (C) 2005 Vijay Kumar B.
   </listitem>
   <listitem>
    GTK+ 2.0 Tree View Tutorial by Tim-Philipp Mueller
   </listitem>
   <listitem>
    GTK+ 3 Reference Manual
   </listitem>
   <listitem>
    GDK 3 Reference Manual
   </listitem>
   <listitem>
    GObject Reference Manual,
    Copyright (C) 2005 - 2012 The GNOME Project, see http://www.gtk.org/
   </listitem>
   <listitem>
    Menus and Toolbars, Stewart Weiss,
    <ulink url="http://www.compsci.hunter.cuny.edu/~sweiss/course_materials/csci493.70/lecture_notes/GTK_menus.pdf">
    Menus and Toolbars in GTK+</ulink>
   </listitem>
  </orderedlist>
  <para>
   Permission is granted to make and distribute verbatim copies of this manual
   provided the copyright notice and this permission notice are preserved on all copies.
   Permission is granted to copy and distribute modified versions of this document
   under the conditions for verbatim copying, provided that this copyright notice is
   included exactly as in the original, and that the entire resulting derived work is
   distributed under the terms of a permission notice identical to this one.
   Permission is granted to copy and distribute translations of this document into
   another language, under the above conditions for modified versions.
   If you are intending to incorporate this document into a published work, please
   contact the maintainer, and we will make an effort to ensure that you have the
   most up to date information available.
  </para>
  <para>
   There is no guarantee that this document lives up to its intended purpose. This is
   simply provided as a free resource. As such, the authors and maintainers of the
   information provided within can not make any guarantee that the information is
   even accurate.
  </para>
 </appendix>

 <index>
  <title>Index</title>
 </index>

</book>





































